<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        部落格
    </title>
    <meta name="description" content= 千里之行，始于足下 >
    <meta name="keywords" content= Blog >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="部落格" type="application/atom+xml">
</head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            项目入门-《苍穹外卖》
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84.png" alt="知识结构"></p>
<ul>
<li><strong>SpringBoot启动流程</strong></li>
</ul>
<p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="SpringBoot启动流程"></p>
<ul>
<li><strong>用户一次请求流程</strong></li>
</ul>
<p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/request.png" alt="request"></p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><h2 id="如何将前端数据转发至后端处理？"><a href="#如何将前端数据转发至后端处理？" class="headerlink" title="如何将前端数据转发至后端处理？"></a>如何将前端数据转发至后端处理？</h2><h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h3><p>前端生成数据-&gt; nginx监听主机及端口（在conf配置 http默认端口80）-&gt; nginx识别传入路径forward到指定后端地址（Tomcat-默认8080端口）</p>
<p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/nginx_1.png" alt="nginx_1"></p>
<p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/nginx_2.png" alt="nginx_2"></p>
<ul>
<li>如果只有本机一台服务器，webservers为localhost</li>
<li>可为多台server分配不同权重以达到分流作用</li>
</ul>
<h2 id="接口设计与测试"><a href="#接口设计与测试" class="headerlink" title="接口设计与测试"></a>接口设计与测试</h2><ul>
<li><p>Yapi提供界面管理和维护接口</p>
</li>
<li><p>Swagger 为后端接口提供测试界面（取代postman）</p>
</li>
</ul>
<h3 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a>Swagger常用注解</h3><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/swagger_1.png" alt="swagger_1"></p>
<h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><h2 id="需求分析和设计"><a href="#需求分析和设计" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h2><ol>
<li>产品原型</li>
<li>接口设计（Yapi）</li>
<li>数据库设计</li>
</ol>
<h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p>用户请求-&gt;拦截器（校验JWT令牌）-&gt;Controller-&gt;service-&gt;mapper-&gt;database</p>
<h3 id="如何理解JWT？"><a href="#如何理解JWT？" class="headerlink" title="如何理解JWT？"></a>如何理解JWT？</h3><p>JWT（JSON Web Token）是一种数据形式，通常放在http头部被校验。</p>
<p>包括：</p>
<ul>
<li>Header：令牌类型（JWT） + 签名所使用算法</li>
<li>Payload：一些claims，可以理解为该JWT的设置参数</li>
<li>Signature：用于验证其在传输过程中未被篡改</li>
</ul>
<p>工作流程：</p>
<p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/swagger_2.png" alt="swagger_2"></p>
<ol>
<li><strong>用户登录</strong>：用户使用用户名和密码登录。</li>
<li><strong>生成 JWT</strong>：服务器验证用户凭据后，创建一个包含用户信息和其他必要声明的 JWT，并使用一个密钥对其进行签名。</li>
<li><strong>发送 JWT</strong>：服务器将 JWT 发送给客户端。</li>
<li><strong>存储 JWT</strong>：客户端通常将 JWT 存储在本地存储（如 Cookies）或内存中（如 localStorage）。</li>
<li><strong>发送请求</strong>：客户端在随后的每个请求中将 JWT 放在 HTTP 头部（通常是 Authorization 字段）中发送给服务器。</li>
<li><strong>验证 JWT</strong>：服务器接收到请求后，验证 JWT 的签名以确保其未被篡改，并根据有效载荷中的声明来处理请求。</li>
</ol>
<p><strong>简而言之：用户成功登录一次后，服务器创建了一个牌子（jwt）并签名（服务器亲自生成的）给用户（以后你就是熟人），用户拿到JWT后，以后每次发送数据都带上牌子（我是熟人），服务器检验签名及JWT信息让该用户进屋。</strong></p>
<h3 id="不同类中还有什么办法可以获取某个变量？"><a href="#不同类中还有什么办法可以获取某个变量？" class="headerlink" title="不同类中还有什么办法可以获取某个变量？"></a>不同类中还有什么办法可以获取某个变量？</h3><p>只要在同一线程中(Thread.currentThread().getID())，可以使用ThreadLocal来存取某一变量，该变量只有在同一线程内部才能获取</p>
<h3 id="Handle如何执行？"><a href="#Handle如何执行？" class="headerlink" title="Handle如何执行？"></a>Handle如何执行？</h3><h3 id="代码开发思路"><a href="#代码开发思路" class="headerlink" title="代码开发思路"></a>代码开发思路</h3><ul>
<li>Yapi查看接口（参数，返回值，请求方法）</li>
<li>定义DTO对象作为传输参数-&gt;controller（地址映射）</li>
<li>controller新建并调用对应service</li>
<li>service 调用 mapper方法</li>
<li>mapper语句由mapper.xml绑定，yml文件指定扫描xml地址</li>
<li>mapper拿到data，封装进Result返回给前端</li>
</ul>
<h3 id="分页PageHelper实现原理"><a href="#分页PageHelper实现原理" class="headerlink" title="分页PageHelper实现原理"></a>分页PageHelper实现原理</h3><p>PageHelper.startPage的底层实现，ThreadLocal线程存Page进内存里，在执行查询之前将Page作为sql语句的limit语句拼进XML对应语句里<strong>（动态SQL）</strong></p>
<p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/page_1.png" alt="page_1"></p>
<h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ol>
<li>配置属性类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;sky.alioss&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class AliOssProperties &#123;</span><br><span class="line"></span><br><span class="line">    private String endpoint;</span><br><span class="line">    private String accessKeyId;</span><br><span class="line">    private String accessKeySecret;</span><br><span class="line">    private String bucketName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从yml文件获取值赋值给属性类。定义配置类，加载配置类时，创建对象并获取属性类的值。</p>
<ol start="2">
<li>文件上传控制器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String originalFilename = file.getOriginalFilename();</span><br><span class="line">//截取后缀</span><br><span class="line">String extension = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));</span><br><span class="line">String objectName = UUID.randomUUID().toString() + extension; //搞个独一无人的新名字防止重名</span><br><span class="line">aliOssUtil.upload(file.getBytes(),objectName);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>上传工具类进行上传</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建OSSClient实例。</span><br><span class="line">OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">// 创建PutObject请求。</span><br><span class="line">ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));</span><br></pre></td></tr></table></figure>



<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p><strong>批量插入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertBatch&quot;&gt;</span><br><span class="line">    insert into dish_flavor (dish_id,name,value)</span><br><span class="line">        values</span><br><span class="line">   &lt;foreach collection=&quot;flavors&quot; item=&quot;df&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">       (#&#123;df.dish_id&#125;,#&#123;df.name&#125;,#&#123;df.value&#125;)</span><br><span class="line">   &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p><strong>返回数据库自增值（主键）的方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>左连接（外）&#x2F;右连接（外）&#x2F;全连接（外）&#x2F;内连接</strong></p>
<ul>
<li><p>左&#x2F;右连接：主表数据完全保留, 副表字段匹配到则数据保留,填充到结果集, 未匹配到数据置空.</p>
<p><code>SELECT *</code><br><code>FROM table1</code><br><code>LEFT JOIN table2 ON table1.column_name = table2.column_name;</code></p>
</li>
<li><p>全连接：两表取并集</p>
</li>
<li><p>内连接：取交集</p>
</li>
</ul>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul>
<li><p>key-value形式保存在内存中</p>
</li>
<li><p>常用数据类型：<img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/redis_1.png" alt="redis_1"></p>
</li>
<li><p>常用命令：</p>
<ul>
<li>String： Setex key second value  (数据的过期时间，过期后释放内存)</li>
<li>Hash: HSET key field value&#x2F;HGET key&#x2F;HDEL key&#x2F;HKEYS key &#x2F; HVALUES key</li>
<li>List: <img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/redis_2.png" alt="redis_2"></li>
<li>Set：<img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/redis_3.png" alt="redis_3"></li>
<li>sort(有序集合)：<img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/redis_4.png" alt="redis_4"></li>
</ul>
<h2 id="spring-redis"><a href="#spring-redis" class="headerlink" title="spring-redis"></a>spring-redis</h2><p><strong>流程</strong>：配置—&gt;配置类（Bean）通过该对象操作Redis</p>
</li>
</ul>
<h1 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h1><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p><strong>Http协议的客户端编程工具包</strong>：向服务端请求GET&#x2F;发送POST数据</p>
<p><strong>执行流程</strong>：创建httpclient对象-&gt;创建请求对象（HttpPost）-&gt;发送请求(对象封装为StringEntity)-&gt;解析结果-&gt;关闭资源</p>
<h2 id="小程序微信登录流程"><a href="#小程序微信登录流程" class="headerlink" title="小程序微信登录流程"></a>小程序微信登录流程</h2><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/api-login.png" alt="api-login"></p>
<ul>
<li>小程序要调用wx（第三方）：获取临时授权码（wx.login）-&gt;后端服务器以该码+app信息调用微信接口获取身份信息-&gt;后端服务器为小程序返回身份信息（token）-&gt;后续小程序在请求时都携带该token用于验证身份</li>
</ul>
<h2 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h2><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/wc-offer.png" alt="wc-offer"></p>
<ul>
<li>服务端为小程序返回订单号</li>
<li>点击支付后，服务端根据订单号和<strong>小程序各种配置信息调</strong>用wx接口获取<strong>交易标识</strong>并返回给小程序</li>
<li>小程序根据标识直接调用wx接口请求支付</li>
<li>为小程序返回支付结果&#x2F;根据交易标识中的回调地址为服务端返回支付结果</li>
</ul>
<h1 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h1><h2 id="缓存与Spring-Cache"><a href="#缓存与Spring-Cache" class="headerlink" title="缓存与Spring Cache"></a>缓存与Spring Cache</h2><p><strong>用途</strong>：多用户同时访问数据库时导致性能下降（查询商品等），引入缓存机制（放入内存）</p>
<p><strong>Spring Cache</strong>：基于注解实现缓存的功能（Redis）等</p>
<ul>
<li><p>CachePut(cacheNames &#x3D; “A”, key&#x3D;”#B(和形参有关)”) &#x2F;&#x2F;key构造为A：：B 将返回结果作为值存入Redis</p>
</li>
<li><p>Cacheable 查询缓存，若没查询到调数据库并存入</p>
</li>
<li><p>CacheEvict 清理缓存（cacheNames &#x3D; ，allEntries &#x3D; true(CacheNames下的全删了)）</p>
</li>
</ul>
<h1 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h1><h2 id="SpringTask"><a href="#SpringTask" class="headerlink" title="SpringTask"></a>SpringTask</h2><ul>
<li>用途：定时执行方法（查询&#x2F;更新状态），启动类增加注解@EnableScheduling</li>
<li>注解使用：在方法中加入@Scheduled(cron&#x3D;”cron表达式”)  表达式可通过在线网站生成</li>
<li>通常定义定时类配合mapper操作底层数据库</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul>
<li>用途：服务端和管理端保持长连接，相比对同一对象的调用和返回，通过它可以实现接收小程序对象数据，并处理转发值管理端（收发面向不同对象）</li>
<li>创建连接时通常也会经过nginx转发</li>
</ul>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ul>
<li><p>Result 在查询时指定泛型， 其他操作不用添加</p>
</li>
<li><p>对象属性拷贝：BeanUtils.copyProperties(src,des)</p>
</li>
<li><p>@AllArgsConstructor 生成构造函数注解</p>
</li>
<li><p>@RequestParam从请求的查询参数中获取值</p>
<ul>
<li>例： <code>?param1=value1&amp;param2=value2</code></li>
</ul>
</li>
<li><p>@PathVariable 从URL 路径中的部分获取值</p>
</li>
<li><p>例：&#x2F;users&#x2F;{userId}</p>
</li>
<li><p>构建器构建对象模式：例</p>
<ul>
<li><pre><code>Dish dish = Dish.builder()
                .status(status)
                .id(id)
                .build();
</code></pre>
</li>
</ul>
</li>
<li><p>对象封装时：DTO前端-&gt;后端，VO 反之</p>
</li>
</ul>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: 食芒果冰 | Theme By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">Page Views: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">Unique Visitors: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
