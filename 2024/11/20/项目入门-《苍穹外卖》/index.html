<!DOCTYPE html><html lang="zn-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 项目入门-《苍穹外卖》 · 部落格</title><meta name="description" content="项目入门-《苍穹外卖》 - Sen"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/nav.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://senwh.github.io/atom.xml" title="部落格"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="部落格" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">部落格</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>INDEX</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>ARCHIVES</p></a><ul class="shortcut-icons"><a href="https://github.com/SenWH" target="_blank"><img src="/images/github.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">项目入门-《苍穹外卖》</h1><div class="post-info">Nov 20, 2024</div><div class="post-content"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84.png" alt="知识结构"></p>
<ul>
<li><strong>SpringBoot启动流程</strong></li>
</ul>
<p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="SpringBoot启动流程"></p>
<ul>
<li><strong>用户一次请求流程</strong></li>
</ul>
<p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/request.png" alt="request"></p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><h2 id="如何将前端数据转发至后端处理？"><a href="#如何将前端数据转发至后端处理？" class="headerlink" title="如何将前端数据转发至后端处理？"></a>如何将前端数据转发至后端处理？</h2><h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h3><p>前端生成数据-&gt; nginx监听主机及端口（在conf配置 http默认端口80）-&gt; nginx识别传入路径forward到指定后端地址（Tomcat-默认8080端口）</p>
<p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/nginx_1.png" alt="nginx_1"></p>
<p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/nginx_2.png" alt="nginx_2"></p>
<ul>
<li>如果只有本机一台服务器，webservers为localhost</li>
<li>可为多台server分配不同权重以达到分流作用</li>
</ul>
<h2 id="接口设计与测试"><a href="#接口设计与测试" class="headerlink" title="接口设计与测试"></a>接口设计与测试</h2><ul>
<li><p>Yapi提供界面管理和维护接口</p>
</li>
<li><p>Swagger 为后端接口提供测试界面（取代postman）</p>
</li>
</ul>
<h3 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a>Swagger常用注解</h3><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/swagger_1.png" alt="swagger_1"></p>
<h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><h2 id="需求分析和设计"><a href="#需求分析和设计" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h2><ol>
<li>产品原型</li>
<li>接口设计（Yapi）</li>
<li>数据库设计</li>
</ol>
<h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p>用户请求-&gt;拦截器（校验JWT令牌）-&gt;Controller-&gt;service-&gt;mapper-&gt;database</p>
<h3 id="如何理解JWT？"><a href="#如何理解JWT？" class="headerlink" title="如何理解JWT？"></a>如何理解JWT？</h3><p>JWT（JSON Web Token）是一种数据形式，通常放在http头部被校验。</p>
<p>包括：</p>
<ul>
<li>Header：令牌类型（JWT） + 签名所使用算法</li>
<li>Payload：一些claims，可以理解为该JWT的设置参数</li>
<li>Signature：用于验证其在传输过程中未被篡改</li>
</ul>
<p>工作流程：</p>
<p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/swagger_2.png" alt="swagger_2"></p>
<ol>
<li><strong>用户登录</strong>：用户使用用户名和密码登录。</li>
<li><strong>生成 JWT</strong>：服务器验证用户凭据后，创建一个包含用户信息和其他必要声明的 JWT，并使用一个密钥对其进行签名。</li>
<li><strong>发送 JWT</strong>：服务器将 JWT 发送给客户端。</li>
<li><strong>存储 JWT</strong>：客户端通常将 JWT 存储在本地存储（如 Cookies）或内存中（如 localStorage）。</li>
<li><strong>发送请求</strong>：客户端在随后的每个请求中将 JWT 放在 HTTP 头部（通常是 Authorization 字段）中发送给服务器。</li>
<li><strong>验证 JWT</strong>：服务器接收到请求后，验证 JWT 的签名以确保其未被篡改，并根据有效载荷中的声明来处理请求。</li>
</ol>
<p><strong>简而言之：用户成功登录一次后，服务器创建了一个牌子（jwt）并签名（服务器亲自生成的）给用户（以后你就是熟人），用户拿到JWT后，以后每次发送数据都带上牌子（我是熟人），服务器检验签名及JWT信息让该用户进屋。</strong></p>
<h3 id="不同类中还有什么办法可以获取某个变量？"><a href="#不同类中还有什么办法可以获取某个变量？" class="headerlink" title="不同类中还有什么办法可以获取某个变量？"></a>不同类中还有什么办法可以获取某个变量？</h3><p>只要在同一线程中(Thread.currentThread().getID())，可以使用ThreadLocal来存取某一变量，该变量只有在同一线程内部才能获取</p>
<h3 id="Handle如何执行？"><a href="#Handle如何执行？" class="headerlink" title="Handle如何执行？"></a>Handle如何执行？</h3><h3 id="代码开发思路"><a href="#代码开发思路" class="headerlink" title="代码开发思路"></a>代码开发思路</h3><ul>
<li>Yapi查看接口（参数，返回值，请求方法）</li>
<li>定义DTO对象作为传输参数-&gt;controller（地址映射）</li>
<li>controller新建并调用对应service</li>
<li>service 调用 mapper方法</li>
<li>mapper语句由mapper.xml绑定，yml文件指定扫描xml地址</li>
<li>mapper拿到data，封装进Result返回给前端</li>
</ul>
<h3 id="分页PageHelper实现原理"><a href="#分页PageHelper实现原理" class="headerlink" title="分页PageHelper实现原理"></a>分页PageHelper实现原理</h3><p>PageHelper.startPage的底层实现，ThreadLocal线程存Page进内存里，在执行查询之前将Page作为sql语句的limit语句拼进XML对应语句里<strong>（动态SQL）</strong></p>
<p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/page_1.png" alt="page_1"></p>
<h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ol>
<li>配置属性类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;sky.alioss&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class AliOssProperties &#123;</span><br><span class="line"></span><br><span class="line">    private String endpoint;</span><br><span class="line">    private String accessKeyId;</span><br><span class="line">    private String accessKeySecret;</span><br><span class="line">    private String bucketName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从yml文件获取值赋值给属性类。定义配置类，加载配置类时，创建对象并获取属性类的值。</p>
<ol start="2">
<li>文件上传控制器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String originalFilename = file.getOriginalFilename();</span><br><span class="line">//截取后缀</span><br><span class="line">String extension = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));</span><br><span class="line">String objectName = UUID.randomUUID().toString() + extension; //搞个独一无人的新名字防止重名</span><br><span class="line">aliOssUtil.upload(file.getBytes(),objectName);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>上传工具类进行上传</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建OSSClient实例。</span><br><span class="line">OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">// 创建PutObject请求。</span><br><span class="line">ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));</span><br></pre></td></tr></table></figure>



<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p><strong>批量插入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertBatch&quot;&gt;</span><br><span class="line">    insert into dish_flavor (dish_id,name,value)</span><br><span class="line">        values</span><br><span class="line">   &lt;foreach collection=&quot;flavors&quot; item=&quot;df&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">       (#&#123;df.dish_id&#125;,#&#123;df.name&#125;,#&#123;df.value&#125;)</span><br><span class="line">   &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p><strong>返回数据库自增值（主键）的方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>左连接（外）&#x2F;右连接（外）&#x2F;全连接（外）&#x2F;内连接</strong></p>
<ul>
<li><p>左&#x2F;右连接：主表数据完全保留, 副表字段匹配到则数据保留,填充到结果集, 未匹配到数据置空.</p>
<p><code>SELECT *</code><br><code>FROM table1</code><br><code>LEFT JOIN table2 ON table1.column_name = table2.column_name;</code></p>
</li>
<li><p>全连接：两表取并集</p>
</li>
<li><p>内连接：取交集</p>
</li>
</ul>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul>
<li><p>key-value形式保存在内存中</p>
</li>
<li><p>常用数据类型：<img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/redis_1.png" alt="redis_1"></p>
</li>
<li><p>常用命令：</p>
<ul>
<li>String： Setex key second value  (数据的过期时间，过期后释放内存)</li>
<li>Hash: HSET key field value&#x2F;HGET key&#x2F;HDEL key&#x2F;HKEYS key &#x2F; HVALUES key</li>
<li>List: <img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/redis_2.png" alt="redis_2"></li>
<li>Set：<img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/redis_3.png" alt="redis_3"></li>
<li>sort(有序集合)：<img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/redis_4.png" alt="redis_4"></li>
</ul>
<h2 id="spring-redis"><a href="#spring-redis" class="headerlink" title="spring-redis"></a>spring-redis</h2><p><strong>流程</strong>：配置—&gt;配置类（Bean）通过该对象操作Redis</p>
</li>
</ul>
<h1 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h1><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p><strong>Http协议的客户端编程工具包</strong>：向服务端请求GET&#x2F;发送POST数据</p>
<p><strong>执行流程</strong>：创建httpclient对象-&gt;创建请求对象（HttpPost）-&gt;发送请求(对象封装为StringEntity)-&gt;解析结果-&gt;关闭资源</p>
<h2 id="小程序微信登录流程"><a href="#小程序微信登录流程" class="headerlink" title="小程序微信登录流程"></a>小程序微信登录流程</h2><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/api-login.png" alt="api-login"></p>
<ul>
<li>小程序要调用wx（第三方）：获取临时授权码（wx.login）-&gt;后端服务器以该码+app信息调用微信接口获取身份信息-&gt;后端服务器为小程序返回身份信息（token）-&gt;后续小程序在请求时都携带该token用于验证身份</li>
</ul>
<h2 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h2><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/wc-offer.png" alt="wc-offer"></p>
<ul>
<li>服务端为小程序返回订单号</li>
<li>点击支付后，服务端根据订单号和<strong>小程序各种配置信息调</strong>用wx接口获取<strong>交易标识</strong>并返回给小程序</li>
<li>小程序根据标识直接调用wx接口请求支付</li>
<li>为小程序返回支付结果&#x2F;根据交易标识中的回调地址为服务端返回支付结果</li>
</ul>
<h1 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h1><h2 id="缓存与Spring-Cache"><a href="#缓存与Spring-Cache" class="headerlink" title="缓存与Spring Cache"></a>缓存与Spring Cache</h2><p><strong>用途</strong>：多用户同时访问数据库时导致性能下降（查询商品等），引入缓存机制（放入内存）</p>
<p><strong>Spring Cache</strong>：基于注解实现缓存的功能（Redis）等</p>
<ul>
<li><p>CachePut(cacheNames &#x3D; “A”, key&#x3D;”#B(和形参有关)”) &#x2F;&#x2F;key构造为A：：B 将返回结果作为值存入Redis</p>
</li>
<li><p>Cacheable 查询缓存，若没查询到调数据库并存入</p>
</li>
<li><p>CacheEvict 清理缓存（cacheNames &#x3D; ，allEntries &#x3D; true(CacheNames下的全删了)）</p>
</li>
</ul>
<h1 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h1><h2 id="SpringTask"><a href="#SpringTask" class="headerlink" title="SpringTask"></a>SpringTask</h2><ul>
<li>用途：定时执行方法（查询&#x2F;更新状态），启动类增加注解@EnableScheduling</li>
<li>注解使用：在方法中加入@Scheduled(cron&#x3D;”cron表达式”)  表达式可通过在线网站生成</li>
<li>通常定义定时类配合mapper操作底层数据库</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul>
<li>用途：服务端和管理端保持长连接，相比对同一对象的调用和返回，通过它可以实现接收小程序对象数据，并处理转发值管理端（收发面向不同对象）</li>
<li>创建连接时通常也会经过nginx转发</li>
</ul>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ul>
<li><p>Result 在查询时指定泛型， 其他操作不用添加</p>
</li>
<li><p>对象属性拷贝：BeanUtils.copyProperties(src,des)</p>
</li>
<li><p>@AllArgsConstructor 生成构造函数注解</p>
</li>
<li><p>@RequestParam从请求的查询参数中获取值</p>
<ul>
<li>例： <code>?param1=value1&amp;param2=value2</code></li>
</ul>
</li>
<li><p>@PathVariable 从URL 路径中的部分获取值</p>
</li>
<li><p>例：&#x2F;users&#x2F;{userId}</p>
</li>
<li><p>构建器构建对象模式：例</p>
<ul>
<li><pre><code>Dish dish = Dish.builder()
                .status(status)
                .id(id)
                .build();
</code></pre>
</li>
</ul>
</li>
<li><p>对象封装时：DTO前端-&gt;后端，VO 反之</p>
</li>
</ul>
</div></article></div><div data-thread-key="2024/11/20/项目入门-《苍穹外卖》/" data-title="项目入门-《苍穹外卖》" data-url="https://senwh.github.io/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/" data-author-key="1" class="ds-thread"></div><div id="disqus_thread"></div></div><script>var duoshuoQuery = {short_name:"1234"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><script>var disqus_shortname = 'Sen';
var disqus_identifier = '2024/11/20/项目入门-《苍穹外卖》/';
var disqus_title = '项目入门-《苍穹外卖》';
var disqus_url = 'https://senwh.github.io/2024/11/20/项目入门-《苍穹外卖》/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//Sen.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a href="/2024/11/26/%E6%A0%91%E8%8E%93%E6%B4%BE5%E9%85%8D%E7%BD%AE/" class="prev">上一篇</a><a href="/2024/11/19/%E6%95%B0%E7%BB%84/" class="next">下一篇</a></div><div class="copyright"><p>© 2024 - 2025 <a href="https://senwh.github.io">Sen</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"Sen",'auto');ga('send','pageview');</script></body></html>