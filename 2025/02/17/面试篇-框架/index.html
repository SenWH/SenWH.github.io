<!DOCTYPE html><html lang="zn-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 面试篇-框架 · 部落格</title><meta name="description" content="面试篇-框架 - Sen"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/nav.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://senwh.github.io/atom.xml" title="部落格"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="部落格" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">部落格</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>INDEX</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>ARCHIVES</p></a><ul class="shortcut-icons"><a href="https://github.com/SenWH" target="_blank"><img src="/images/github.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">面试篇-框架</h1><div class="post-info">Feb 17, 2025</div><div class="post-content"><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="Bean线程安全问题"><a href="#Bean线程安全问题" class="headerlink" title="Bean线程安全问题"></a><strong>Bean线程安全问题</strong></h3><p>Spring框架中单例Bean是线程安全吗？</p>
<ul>
<li><strong>成员方法内状态可修改变量需考虑线程安全</strong>（DAO Service层变量通常不变）</li>
<li>单例模式，各线程共享该bean</li>
</ul>
<p>解决方案</p>
<ul>
<li>加锁</li>
<li>@Scope 设置为prototype 多例，每个新的线程会新建变量</li>
</ul>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><strong>面向切面编程</strong> ：对某个类方法源代码不进行修改的情况下实现增强</p>
<p><strong>关键元素</strong>：通过<strong>切面</strong>描述<strong>通知（存放共性（增强）操作的方法，被存在通知类中）</strong>和<strong>切入点（从连接点中选取）</strong>的关系</p>
<p><strong>步骤</strong></p>
<ol>
<li>导入坐标</li>
<li>制作连接点（DAO层通常是增删改查）</li>
<li>制作通知（类）</li>
<li>定义切入点-&gt;切入点的定义依托一个无实际意义的方法 <ul>
<li>为了更细粒度的控制，可以增加自定义注解，在需要增强方法前做好标识</li>
</ul>
</li>
<li>绑定切入点和通知关系（切面）-定义增强时机(before，around….)</li>
</ol>
<ul>
<li>4.5的操作实际上都在通知类</li>
</ul>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/AOP_1.png" alt="AOP_1"></p>
<p><strong>AOP底层实现</strong>：如果目标类使用了增强，则生成目标对象的代理对象执行方法（原因是不能乱动原来的对象）</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>记录操作日志</li>
<li>缓存处理</li>
<li>Spring内置的事务处理<ul>
<li>声明式事务管理（AOP）<ul>
<li>检查到@Transactional时，：Spring 使用 <code>TransactionInterceptor</code> 作为事务的切面（Aspect）。它定义了事务的前置增强（开始事务）和后置增强（提交或回滚事务）。</li>
<li>通过 <code>DataSourceTransactionManager</code>（或类似的事务管理器）与数据库交互</li>
</ul>
</li>
<li>编程式事务管理（侵入）</li>
</ul>
</li>
</ul>
<p><strong>Spring中事务失效场景</strong></p>
<ul>
<li>异常捕获处理<ul>
<li>遇到异常时只有自己主动抛出异常事务才会回滚</li>
<li>throw new RuntimeException(e)</li>
</ul>
</li>
<li>抛出检查异常<ul>
<li>Spring默认只回滚非检查异常（运行时异常，RuntimeExcption）</li>
<li>@Transactional配置（rollbackFor&#x3D;Exception.class）</li>
</ul>
</li>
<li>非public方法<ul>
<li>只有pulic方法才有事务管理</li>
</ul>
</li>
</ul>
<p><strong>Spring bean的生命周期</strong></p>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/bean.png" alt="bean"></p>
<ul>
<li><p>实例化：Spring 容器（如 <code>AnnotationConfigApplicationContext</code> 或 XML 配置的容器）根据 Bean 的定义（如 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 或通过 XML 配置的 <code>&lt;bean&gt;</code>）创建一个对象实例</p>
</li>
<li><pre><code class="java">@Autowired
</code></pre>
</li>
<li><p><code>Aware</code> 接口是一系列接口的统称，它们允许 Spring 容器中的 Bean 获取运行时上下文信息，如 Spring 的上下文（<code>ApplicationContext</code>）、Bean 工厂（<code>BeanFactory</code>）、资源加载器（<code>ResourceLoader</code>）（<strong>安全和权限管理等</strong>）</p>
</li>
<li><p>BeanPostProcessor用对对象进行增强（前&#x2F;后）</p>
<ul>
<li>AOP 的实现需要在 Bean 初始化之后创建代理对象，因此会使用到 BeanPostProcessor（动态代理：JDK 动态代理需要实现接口，而 CGLIB 代理是基于字节码生成的）</li>
</ul>
</li>
<li><p>实例化包括：@PostConstruct 和 <code>InitializingBean</code> 的 <code>afterPropertiesSet</code> 方法</p>
</li>
</ul>
</div></article></div><div data-thread-key="2025/02/17/面试篇-框架/" data-title="面试篇-框架" data-url="https://senwh.github.io/2025/02/17/%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/" data-author-key="1" class="ds-thread"></div><div id="disqus_thread"></div></div><script>var duoshuoQuery = {short_name:"1234"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><script>var disqus_shortname = 'Sen';
var disqus_identifier = '2025/02/17/面试篇-框架/';
var disqus_title = '面试篇-框架';
var disqus_url = 'https://senwh.github.io/2025/02/17/面试篇-框架/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//Sen.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a href="/2025/02/14/%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/" class="next">NEXT</a></div><div class="copyright"><p>© 2024 - 2025 <a href="https://senwh.github.io">Sen</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"Sen",'auto');ga('send','pageview');</script></body></html>