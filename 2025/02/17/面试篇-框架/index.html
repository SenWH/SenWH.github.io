<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        部落格
    </title>
    <meta name="description" content= 千里之行，始于足下 >
    <meta name="keywords" content= Blog >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="部落格" type="application/atom+xml">
</head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            面试篇-框架
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="Bean线程安全问题"><a href="#Bean线程安全问题" class="headerlink" title="Bean线程安全问题"></a><strong>Bean线程安全问题</strong></h3><p>Spring框架中单例Bean是线程安全吗？</p>
<ul>
<li><strong>成员方法内状态可修改变量需考虑线程安全</strong>（DAO Service层变量通常不变）</li>
<li>单例模式，各线程共享该bean</li>
</ul>
<p>解决方案</p>
<ul>
<li>加锁</li>
<li>@Scope 设置为prototype 多例，每个新的线程会新建变量</li>
</ul>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><strong>面向切面编程</strong> ：对某个类方法源代码不进行修改的情况下实现增强</p>
<p><strong>关键元素</strong>：通过<strong>切面</strong>描述<strong>通知（存放共性（增强）操作的方法，被存在通知类中）</strong>和<strong>切入点（从连接点中选取）</strong>的关系</p>
<p><strong>步骤</strong></p>
<ol>
<li>导入坐标</li>
<li>制作连接点（DAO层通常是增删改查）</li>
<li>制作通知（类）</li>
<li>定义切入点-&gt;切入点的定义依托一个无实际意义的方法 <ul>
<li>为了更细粒度的控制，可以增加自定义注解，在需要增强方法前做好标识</li>
</ul>
</li>
<li>绑定切入点和通知关系（切面）-定义增强时机(before，around….)</li>
</ol>
<ul>
<li>4.5的操作实际上都在通知类</li>
</ul>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/AOP_1.png" alt="AOP_1"></p>
<p><strong>AOP底层实现</strong>：如果目标类使用了增强，则生成目标对象的代理对象执行方法（原因是不能乱动原来的对象）</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>记录操作日志</li>
<li>缓存处理</li>
<li>Spring内置的事务处理<ul>
<li>声明式事务管理（AOP）<ul>
<li>检查到@Transactional时，：Spring 使用 <code>TransactionInterceptor</code> 作为事务的切面（Aspect）。它定义了事务的前置增强（开始事务）和后置增强（提交或回滚事务）。</li>
<li>通过 <code>DataSourceTransactionManager</code>（或类似的事务管理器）与数据库交互</li>
</ul>
</li>
<li>编程式事务管理（侵入）</li>
</ul>
</li>
</ul>
<h2 id="Spring中事务失效场景"><a href="#Spring中事务失效场景" class="headerlink" title="Spring中事务失效场景"></a><strong>Spring中事务失效场景</strong></h2><ul>
<li>异常捕获处理<ul>
<li>遇到异常时只有自己主动抛出异常事务才会回滚</li>
<li>throw new RuntimeException(e)</li>
</ul>
</li>
<li>抛出检查异常<ul>
<li>Spring默认只回滚非检查异常（运行时异常，RuntimeExcption）</li>
<li>@Transactional配置（rollbackFor&#x3D;Exception.class）</li>
</ul>
</li>
<li>非public方法<ul>
<li>只有pulic方法才有事务管理</li>
</ul>
</li>
</ul>
<h2 id="Spring-bean的生命周期"><a href="#Spring-bean的生命周期" class="headerlink" title="Spring bean的生命周期"></a><strong>Spring bean的生命周期</strong></h2><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/bean.png" alt="bean"></p>
<ul>
<li><p>实例化：Spring 容器（如 <code>AnnotationConfigApplicationContext</code> 或 XML 配置的容器）根据 Bean 的定义（如 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 或通过 XML 配置的 <code>&lt;bean&gt;</code>）创建一个对象实例</p>
</li>
<li><pre><code class="java">@Autowired
</code></pre>
</li>
<li><p><code>Aware</code> 接口是一系列接口的统称，它们允许 Spring 容器中的 Bean 获取运行时上下文信息，如 Spring 的上下文（<code>ApplicationContext</code>）、Bean 工厂（<code>BeanFactory</code>）、资源加载器（<code>ResourceLoader</code>）（<strong>安全和权限管理等</strong>）</p>
</li>
<li><p>BeanPostProcessor用对对象进行增强（前&#x2F;后）</p>
<ul>
<li>AOP 的实现需要在 Bean 初始化之后创建代理对象，因此会使用到 BeanPostProcessor（动态代理：JDK 动态代理需要实现接口，而 CGLIB 代理是基于字节码生成的）</li>
</ul>
</li>
<li><p>实例化包括：@PostConstruct 和 <code>InitializingBean</code> 的 <code>afterPropertiesSet</code> 方法</p>
</li>
</ul>
<h2 id="Spring中的循环依赖问题"><a href="#Spring中的循环依赖问题" class="headerlink" title="Spring中的循环依赖问题"></a>Spring中的循环依赖问题</h2><p><strong>定义：</strong>两个或多个 Bean 互相依赖对方，导致 Spring 容器在初始化这些 Bean 时陷入死锁或无法正常注入的情况</p>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-1.png" alt="{spring-1.png}"></p>
<p><strong>如何解决？</strong></p>
<p><strong>三级缓存</strong></p>
<ul>
<li>一级缓存：存放完整的单例-完成初始化后</li>
<li>二级缓存：可存放早期的bean对象-依赖注入阶段</li>
<li>三级缓存：缓存的是ObjectFactory-实例化时</li>
</ul>
<p><strong>本质：</strong>根据Bean的创建周期，提前暴露（二级在初始化前暴露，缓存的是非代理对象），当注入的是代理对象时，需要ObjectFactory（可生成普通对象和代理对象）生成。初始化后，只留一级缓存，剩下两个被清空</p>
<p><strong>如果在构造函数时产生循环引用-此时三级缓存不行了，因为这是在初始化的过程中</strong></p>
<p>解决：@Lazy，延迟实例化另一个对象</p>
<h2 id="SpringMvc的执行流程"><a href="#SpringMvc的执行流程" class="headerlink" title="SpringMvc的执行流程"></a>SpringMvc的执行流程</h2><h3 id="JSP阶段"><a href="#JSP阶段" class="headerlink" title="JSP阶段"></a>JSP阶段</h3><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-2.png" alt="spring-2"></p>
<ul>
<li>映射器返回的是<code>HandlerExecutionChain</code>：带有 <code>@Controller</code> 注解的类中某个带有 <code>@RequestMapping</code> 注解的方法+拦截器列表</li>
</ul>
<h3 id="前后端分离阶段"><a href="#前后端分离阶段" class="headerlink" title="前后端分离阶段"></a>前后端分离阶段</h3><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-3.png" alt="spring-3"></p>
<ul>
<li>前后端分离了，所以不用在后端生成页面，只需要返回JSON数据让前端自己处理</li>
</ul>
<h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><p><strong>配置流程</strong></p>
<ul>
<li><strong>启动类注解</strong>：Spring Boot 的启动类使用 <code>@SpringBootApplication</code> 注解，该注解是一个组合注解，包含 <code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 和 <code>@Configuration</code>。</li>
<li><strong>自动配置触发</strong>：<code>@EnableAutoConfiguration</code> 注解会触发自动配置机制，Spring Boot 会扫描 <code>META-INF/spring.factories</code> 文件，加载其中定义的自动配置类。</li>
<li><strong>条件注解过滤</strong>：Spring Boot 会根据条件注解（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>）判断是否需要加载某个配置类或 Bean。</li>
<li><strong>Bean 注册</strong>：符合条件的配置类会被加载，其中定义的 Bean 会被注册到 Spring 容器中，供其他组件使用。</li>
<li><strong>依赖注入</strong>：其他组件可以通过 <code>@Autowired</code> 或构造函数注入的方式使用这些自动装配的 Bean。</li>
</ul>
<p> <code>@EnableAutoConfiguration：</code>包含了两个元注解：</p>
<ul>
<li><p><code>@AutoConfigurationPackage 和 @Import(EnableAutoConfigurationImportSelector.class)</code></p>
</li>
<li><p><code>@AutoConfigurationPackage</code> 注解的作用是将<strong>当前应用的包路径注册到 Spring 容器</strong>中，以便 Spring Boot 能够在后续的自动配置过程中正确地扫描和加载相关的组件</p>
</li>
<li><p><code>@Import(EnableAutoConfigurationImportSelector.class)</code>从 <code>META-INF/spring.factories</code> 文件中加载配置类</p>
</li>
<li><p><code>spring.factories</code> 文件是 Spring Boot 自动配置的核心，包含了一系列的配置类，这些配置类通过<strong>条件注解</strong>（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnProperty</code> 等）来决定是否被加载</p>
</li>
</ul>
<h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><p><strong>Spring</strong></p>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-4.png" alt="{spring-4}"></p>
<p><strong>SpringMvc</strong></p>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-5.png" alt="{spring-5}"></p>
<p><strong>SpringBoot</strong></p>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-6.png" alt="{spring-6}"></p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>版权所有 © 2020 | 作者: 食芒果冰 | 主题 By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
