<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        部落格
    </title>
    <meta name="description" content= 千里之行，始于足下 >
    <meta name="keywords" content= Blog >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="部落格" type="application/atom+xml">
</head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            电商项目-演进文档
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="高并发交易系统架构优化实践演进文档"><a href="#高并发交易系统架构优化实践演进文档" class="headerlink" title="高并发交易系统架构优化实践演进文档"></a>高并发交易系统架构优化实践演进文档</h1><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><table>
<thead>
<tr>
<th>版本号</th>
<th>发布日期</th>
<th>主要变更</th>
<th>负责人</th>
</tr>
</thead>
<tbody><tr>
<td>v1.0.0</td>
<td>2025-1-10</td>
<td>基础功能完成（JWT）</td>
<td>L同学</td>
</tr>
<tr>
<td>v1.1.0</td>
<td>2025-02-22</td>
<td>缓存优化</td>
<td>L同学</td>
</tr>
<tr>
<td>v1.1.1</td>
<td>2025-02-26</td>
<td>分布式锁控制并发（库存扣减）</td>
<td>L同学</td>
</tr>
<tr>
<td>v1.1.2</td>
<td>2025-02-27</td>
<td>缓存、数据库优化（库存）</td>
<td>L同学</td>
</tr>
<tr>
<td>v1.2.0</td>
<td>2025-03-01</td>
<td><strong>缓存预扣库存 + 异步更新数据库</strong></td>
<td>L同学</td>
</tr>
<tr>
<td>v1.2.1</td>
<td>2025-02-27</td>
<td>异步通知和日志（ 低库存预警通过邮件、短信通知商家。）</td>
<td></td>
</tr>
<tr>
<td>v1.2.2</td>
<td>2025-02-29</td>
<td>秒杀流量削峰 订单超时自动取消（延迟队列）</td>
<td></td>
</tr>
<tr>
<td>v1.3.0</td>
<td>2025-03-01</td>
<td>数据一致性保障 <strong>幂等性设计拦截重复请求</strong></td>
<td></td>
</tr>
<tr>
<td>v1.3.1</td>
<td>2025-03-03</td>
<td>监控和压测 <strong>限流与熔断保护数据库</strong></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="版本详情"><a href="#版本详情" class="headerlink" title="版本详情"></a>版本详情</h2><h3 id="v1-0-0-基础功能完善（JWT-ThreadLocal"><a href="#v1-0-0-基础功能完善（JWT-ThreadLocal" class="headerlink" title="v1.0.0 -基础功能完善（JWT+ThreadLocal)"></a>v1.0.0 -基础功能完善（JWT+ThreadLocal)</h3><p><strong>流程：</strong></p>
<ul>
<li>登陆成功：claims放ID（标识用户）-定义签名算法（HS256-对称）-过期时间-<strong>生成jwt</strong></li>
<li>返回token给客户端</li>
<li>客户端消息请求头Authorization: Bearer <token>请求服务器</li>
<li>拦截器拦截方法：从请求头获取token-校验jwt（拿本地密匙处理token）</li>
<li>验证完整性和安全性后，解析出claims（里面含id）</li>
</ul>
<h3 id="v1-1-0-缓存优化"><a href="#v1-1-0-缓存优化" class="headerlink" title="v1.1.0 -缓存优化"></a>v1.1.0 -缓存优化</h3><p><strong>测试方案：</strong></p>
<ul>
<li><p>测试数据准备 - 有效数据池：预先生成10,0000个合法商品ID，写入BloomFilter和Redis </p>
</li>
<li><p>非法请求生成：使用JMeter随机生成20,000个不存在的商品ID（确保不会被BloomFilter命中）</p>
</li>
</ul>
<p><strong>JMeter脚本配置:</strong></p>
<ul>
<li><p>线程组配置： </p>
<ul>
<li>线程数：1000（模拟高并发） </li>
<li>循环数：100（10w线程并发）</li>
</ul>
</li>
<li><p>Ramp-Up时间：60秒（逐步加压） </p>
</li>
<li><p>HTTP请求设计： </p>
<ul>
<li>请求路径：GET &#x2F;product&#x2F;{productId}</li>
</ul>
</li>
</ul>
<p><strong>遇到问题：</strong></p>
<p>计算布隆过滤器拦截率时，拦截率超百分百-&gt;并发问题</p>
<p><strong>解决方案：</strong></p>
<p>使用原子类：AtomicLong（底层用Unsafe类，里面有CAS操作）</p>
<p><strong>技术方案：</strong></p>
<p><strong>热点数据缓存</strong></p>
<ul>
<li><p>Redis</p>
</li>
<li><p>序列化优化</p>
<ul>
<li>默认-&gt;JSON</li>
</ul>
</li>
<li><p>防穿透（空间换时间）</p>
<ul>
<li>缓存空数据</li>
<li><strong>布隆过滤器</strong></li>
</ul>
</li>
<li><p>防雪崩</p>
<ul>
<li>设置随机过期时间</li>
</ul>
</li>
</ul>
<h4 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h4><table>
<thead>
<tr>
<th>指标</th>
<th>优化前</th>
<th>优化后</th>
<th>测试条件</th>
</tr>
</thead>
<tbody><tr>
<td>布隆过滤器拦截率</td>
<td>85</td>
<td>98018&#x2F;100000&#x3D;98%</td>
<td>100000并发</td>
</tr>
<tr>
<td>商品查询P99</td>
<td>1200ms</td>
<td>350ms</td>
<td>200并发，持续1min</td>
</tr>
<tr>
<td>数据库连接等待</td>
<td>78%</td>
<td>12%</td>
<td>峰值压力期间</td>
</tr>
</tbody></table>
<hr>
<blockquote>
<p>通过引入Redis缓存，我们将高频查询的响应时间从200ms降低到5ms，QPS从500提升到3000，数据库CPU负载下降83%。同时设计了空值缓存和随机过期策略，缓存命中率稳定在98%以上，未出现缓存雪崩问题。</p>
</blockquote>
<h3 id="v1-1-1-分布式锁控制并发（库存扣减）"><a href="#v1-1-1-分布式锁控制并发（库存扣减）" class="headerlink" title="v1.1.1 - 分布式锁控制并发（库存扣减）"></a>v1.1.1 - 分布式锁控制并发（库存扣减）</h3><p><strong>问题</strong>：</p>
<p>A、高并发下出现<strong>超卖</strong>问题</p>
<p>B、行锁解决不了跨多个数据源&#x2F;分库分表（库存水平拆分到多个数据库）超卖&#x2F;高并发场景（如秒杀-访问同一商品）大量访问数据库性能下降，行锁释放增加延迟</p>
<p>C、Redis 分布式锁–锁的过期时间如何设定？</p>
<p><strong>技术方案：</strong></p>
<p>A、利用数据库的原子性（CAS） </p>
<ul>
<li><p><code>update inventory set stock = stock - delta where product_id=xxx and product_type=xxx and stock &gt;= delta</code></p>
</li>
<li><p>当执行 <code>UPDATE</code> 语句时，数据库会为符合条件的行 <strong>自动加行级排他锁（X Lock）</strong>，where搜索到的行都用排他锁所起来</p>
</li>
</ul>
<p>B、<strong>Redis 分布式锁</strong>–粒度为商品维度</p>
<ol>
<li><strong>互斥性</strong>：同一时刻只有一个客户端能持有锁。</li>
<li><strong>避免死锁</strong>：锁必须有超时机制，防止客户端崩溃后锁无法释放。</li>
<li><strong>容错性</strong>：即使部分 Redis 节点宕机，锁服务仍可用。</li>
<li><strong>可重入性</strong>（可选）：同一客户端可多次获取同一锁。</li>
</ol>
<p>使用了redis的setnx上锁lua脚本解锁，两者都是原子性的</p>
<p>redis是基于内存的，速度较快</p>
<p>C、引入守护线程续期机制（<strong>守护线程续期 + 原子性校验 + 资源管理</strong>）</p>
<p><strong>测试方案：</strong></p>
<p><strong>JMeter脚本配置:</strong></p>
<ul>
<li><p>线程组配置： </p>
<ul>
<li>线程数：2000（模拟高并发） </li>
<li>循环数：1</li>
</ul>
</li>
<li><p>Ramp-Up时间：1秒（瞬时并发） </p>
</li>
<li><p>HTTP请求设计： </p>
<ul>
<li>请求路径：Post&#x2F;user&#x2F;stock&#x2F;deduct</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>指标</th>
<th>优化前</th>
<th>优化后</th>
<th>测试条件</th>
</tr>
</thead>
<tbody><tr>
<td>平均响应时间</td>
<td>6625ms</td>
<td>16498ms</td>
<td>1000并发</td>
</tr>
<tr>
<td>吞吐量</td>
<td>127</td>
<td>18.4ms</td>
<td></td>
</tr>
<tr>
<td>超卖率</td>
<td>16.2%</td>
<td>12%</td>
<td></td>
</tr>
<tr>
<td>布隆过滤器拦截率</td>
<td></td>
<td>98018&#x2F;100000&#x3D;98%</td>
<td></td>
</tr>
</tbody></table>
<h3 id="v1-1-2-缓存优化、数据库优化（库存）"><a href="#v1-1-2-缓存优化、数据库优化（库存）" class="headerlink" title="v1.1.2 -缓存优化、数据库优化（库存）"></a>v1.1.2 -缓存优化、数据库优化（库存）</h3><p><strong>问题：</strong></p>
<p>A、锁的粒度：为购物车每个商品加锁（锁的粒度过细）（<strong>Redis性能瓶颈</strong>）；若改为用户粒度（可解决业务层重复请求（重复点击）），<strong>对多用户失效</strong>（超卖）</p>
<p>B、Redis 锁失效时的数据不一致</p>
<p>C、高频查询商品库存时性能瓶颈（如全表扫描）</p>
<p><strong>技术方案：</strong></p>
<p>A、库存分库分布，锁粒度为库存分片</p>
<p>B、作为兜底机制，防止 Redis 锁失效时的数据不一致</p>
<p>C、通过覆盖索引避免回表，其次将库存校验和扣减合并为一条原子 SQL</p>
<p>D、数据库优化：唯一索引(product_id, product_type) 防止重复商品录入，加速商品维度查询<br>覆盖索引(stock, version) 让扣减操作直接通过索引完成，避免回表</p>
<h3 id="面试讲述技巧："><a href="#面试讲述技巧：" class="headerlink" title="面试讲述技巧："></a>面试讲述技巧：</h3><ol>
<li>按「问题→方案→结果」三段式描述每个优化点 2. 准备1-2个详细的技术决策案例：     <strong>案例：缓存选型决策</strong>   - 候选方案：     1. Redis单缓存（成本低，但网络延迟影响性能）     </li>
<li>Caffeine本地缓存（速度快，但集群一致性难保证）     </li>
<li>多级缓存方案（本地缓存+Redis）   - 决策依据：     - 业务特点：商品信息变更频率低（每天&lt;10次）     - 最终选择：Caffeine本地缓存 + 广播刷新   - 实现效果：商品查询RT降低82%</li>
</ol>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: 食芒果冰 | Theme By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">Page Views: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">Unique Visitors: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
