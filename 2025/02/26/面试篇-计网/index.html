<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        部落格
    </title>
    <meta name="description" content= 千里之行，始于足下 >
    <meta name="keywords" content= Blog >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="部落格" type="application/atom+xml">
</head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            面试篇-计网
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="键入网址到网页显示，期间发生了什么？"><a href="#键入网址到网页显示，期间发生了什么？" class="headerlink" title="键入网址到网页显示，期间发生了什么？"></a>键入网址到网页显示，期间发生了什么？</h2><ul>
<li><strong>应用程序：</strong>URL-&gt;Http报文-&gt;DNS解析（递归+缓存）（本地、根、顶级、权威）</li>
<li><strong>传输层：</strong>应用层用socket调用协议栈（TCP&#x2F;UDP IP ICMP ARP）-&gt;封装（Http）TCP报文(超MSS切割)-其监听浏览器端口 http（80）&#x2F;https(443)-<strong>先三次握手</strong></li>
<li><strong>网络层：</strong>根据路由表找到下一跳MAC地址，将目标地址写入IP头部</li>
<li><strong>网络层\数据链路层：</strong>若路由表找不到下一跳MAC地址，ARP协议广播目标IP以获得MAC地址（缓存），取得地址后封装到目的地址以IPv4协议发送</li>
<li><strong>物理层：</strong>网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列（FCS）</li>
<li><strong>网卡</strong>会将包转为电信号，通过网线发送出去</li>
<li><strong>交换机</strong>根据（FCS）校验包，成功则放入缓冲区,查MAC地址表（MAC-端口）-<strong>没有则广播</strong></li>
<li><strong>路由器</strong>校验包（FCS），查看MAC地址，匹配则放入缓存。根据IP地址查找封装下一跳MAC地址进头部&#x2F;接收</li>
<li>接收后-&gt;网络层-&gt;传输层-&gt;应用层-四次挥手</li>
</ul>
<h2 id="电脑插入网线后涉及哪些协议"><a href="#电脑插入网线后涉及哪些协议" class="headerlink" title="电脑插入网线后涉及哪些协议"></a>电脑插入网线后涉及哪些协议</h2><ul>
<li>首先电脑插入网线意味着连上网了，假设是动态分配IP，DHCP会给电脑分配IP地址。</li>
</ul>
<h2 id="Linux-收发网络包的流程"><a href="#Linux-收发网络包的流程" class="headerlink" title="Linux 收发网络包的流程"></a>Linux 收发网络包的流程</h2><ul>
<li>应用层发起系统调用（socket）-&gt;数据copy进<strong>sk_buff 内存</strong>-&gt;发送缓存</li>
<li>TCPcopy了sk_buff（收到ACK之后再清除） -协议栈处理</li>
<li>IP 层发现 sk_buff 大于 MTU ,申请内存，将原来的 sk_buff 拷贝为多个小的 sk_buff <strong>故发送发生了（2-3次）copy</strong></li>
<li>网卡<strong>接收到一个网络包后</strong>，会通过 <strong>DMA 技术</strong>，将网络包写入到指定的内存地址，也就是写入到 <strong>Ring Buffer</strong></li>
<li>使用<strong>NAPI 机制</strong>，它是混合「中断和轮询」的方式来接收网络包。避免每接收到一次就中断，先屏蔽中断（时间片轮询）解除屏蔽中断（软（件）中断），处理</li>
<li>往上传，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区「拷贝」到应用层的缓冲区，<strong>唤醒用户线程</strong></li>
<li>Data-&gt;segment-&gt;packet-&gt;frame</li>
</ul>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><ul>
<li>1xx <strong>提示信息</strong>，是协议处理中的一种中间状态</li>
<li><strong>成功</strong>：200（有body)、204（无body）、206（部分body）</li>
<li><strong>资源变动，需要重定向地址：</strong>301（永久）、302（临时）、304（用缓存的就行，缓存和我这里的一致）</li>
<li><strong>报文有误</strong>：400 （不知道为啥错）、403（禁止）、404（资源服务器找不到）</li>
<li><strong>服务器错出</strong>：500（不知道）、501（功能还不支持）、502（网关的问题）、503（服务器繁忙）</li>
</ul>
<h2 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h2><h3 id="HTTP-请求字段"><a href="#HTTP-请求字段" class="headerlink" title="HTTP 请求字段"></a>HTTP 请求字段</h3><table>
<thead>
<tr>
<th><strong>请求行字段</strong></th>
<th>用于标识请求的类型、资源路径和协议版本。</th>
</tr>
</thead>
<tbody><tr>
<td>方法（如 GET、POST）</td>
<td>指定请求的类型，例如获取资源（GET）、提交数据（POST）等。</td>
</tr>
<tr>
<td>URI</td>
<td>请求的资源路径，如 <code>/index.html</code>。</td>
</tr>
<tr>
<td>HTTP 版本</td>
<td>指定使用的 HTTP 协议版本，例如 <code>HTTP/1.1</code> 或 <code>HTTP/2</code>。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>请求头部字段</strong></th>
<th>提供关于请求的附加信息。</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>指定请求的主机名和端口号，例如 <code>www.example.com</code>。</td>
</tr>
<tr>
<td>Accept</td>
<td>客户端可接受的响应内容类型，如 <code>text/html</code>、<code>application/json</code> 等。</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>客户端可接受的编码方式，如 <code>gzip</code>、<code>deflate</code> 等。</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求体的媒体类型，如 <code>application/json</code>、<code>application/x-www-form-urlencoded</code> 等。</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求体的长度（以字节为单位）。</td>
</tr>
<tr>
<td>Authorization</td>
<td>用于认证的凭证，如 <code>Basic</code>、<code>Bearer</code> 等。</td>
</tr>
<tr>
<td>Cookie</td>
<td>客户端存储的 Cookie 信息。</td>
</tr>
</tbody></table>
<h3 id="HTTP-响应字段"><a href="#HTTP-响应字段" class="headerlink" title="HTTP 响应字段"></a>HTTP 响应字段</h3><table>
<thead>
<tr>
<th><strong>状态行字段</strong></th>
<th>用于标识响应的协议版本、请求结果和简短描述。</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP 版本</td>
<td>指定使用的 HTTP 协议版本，例如 <code>HTTP/1.1</code> 或 <code>HTTP/2</code>。</td>
</tr>
<tr>
<td>状态码</td>
<td>表示请求结果的三位数字代码，如 <code>200 OK</code>、<code>404 Not Found</code> 等。</td>
</tr>
<tr>
<td>状态消息</td>
<td>对状态码的简短描述，如 <code>OK</code>、<code>Not Found</code> 等。</td>
</tr>
<tr>
<td><strong>响应头部字段</strong></td>
<td>提供关于响应的附加信息。</td>
</tr>
<tr>
<td>Content-Type</td>
<td>响应体的媒体类型，如 <code>text/html</code>、<code>application/json</code> 等。</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应体的长度（以字节为单位）。</td>
</tr>
<tr>
<td>Location</td>
<td>重定向的 URL。</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>服务器设置的 Cookie 信息。</td>
</tr>
<tr>
<td><strong>响应体</strong></td>
<td>包含服务器返回的数据，如 HTML 页面、JSON 数据等。</td>
</tr>
</tbody></table>
<h2 id="HTTP-缓存技术"><a href="#HTTP-缓存技术" class="headerlink" title="HTTP 缓存技术"></a>HTTP 缓存技术</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p><strong>定义：</strong>只要<strong>浏览器判断缓存</strong>没有过期，则直接使用浏览器的本地缓存。响应体状态码旁显示（ from disk cache）</p>
<p><strong>用法：</strong>请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期（Cache-Control 的优先级高于 Expires）</p>
<ul>
<li><code>Cache-Control</code>， 是一个相对时间</li>
<li><code>Expires</code>，是一个绝对时间</li>
</ul>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p><strong>定义：</strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存<strong>（304）</strong></p>
<p><strong>实现：</strong></p>
<ul>
<li><code>If-Modified-Since</code>服务器检查资源的最后修改时间是否晚于<code>Last-Modified</code>-&gt;（304&#x2F;200）</li>
<li>服务器检查资源<code>If-None-Match</code> 和请求的<code>ETag</code> -&gt;（304&#x2F;200）</li>
<li>ETag 的优先级更高，其能识别以下情况</li>
<li>没有修改文件内容情况下文件的最后修改时间可能也会改变</li>
<li><code>If-Modified-Since</code> 能检查到的粒度是秒级的，ETag比其更精细</li>
<li><strong>配合Cache-Control 字段来使用（过期），只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong></li>
</ul>
<h2 id="HTTP-1-1-特性"><a href="#HTTP-1-1-特性" class="headerlink" title="HTTP&#x2F;1.1 特性"></a>HTTP&#x2F;1.1 特性</h2><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>简单、易于扩展、广泛</li>
<li>无状态（减轻服务器负担、关联性的操作时麻烦）-&gt;cookie、明文传输、不安全（不验证身份信息、不防篡改）</li>
</ul>
<h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><p><strong>Https：</strong></p>
<ul>
<li>SSL&#x2F;TLS 安全协议，使得报文能够加密传输</li>
<li>HTTPS 在 TCP 三次握手之后，还需进行 <strong>SSL&#x2F;TLS 的握手过程</strong></li>
<li>端口号不同</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li>
</ul>
<p><strong>解决哪些问题？</strong></p>
<ul>
<li>数据泄漏-混合加密（非对称+对称）<ul>
<li>在通信<strong>建立前采用非对称加密</strong>的方式交换「会话秘钥」<ul>
<li>公钥加密，私钥解密、耗性能</li>
</ul>
</li>
<li>在<strong>通信过程中</strong>全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据<ul>
<li>速度快、需要保证密匙不泄露</li>
</ul>
</li>
</ul>
</li>
<li>数据篡改-摘要算法+数字签名<ul>
<li>哈希函数来计算出内容的哈希值（指纹）（单向）-接收方同样计算后匹配</li>
<li><strong>不能保证「内容 + 哈希值」不会被中间人替换</strong><ul>
<li>数字签名：私钥加密（<strong>对内容的哈希值加密</strong>），公钥解密</li>
</ul>
</li>
</ul>
</li>
<li>身份冒充-数字证书<ul>
<li>如果私钥和公钥是伪造的-&gt;<strong>接收方误认为签名是发送方的</strong>（也能解密）</li>
<li>接收方去找CA注册数字证书（身份信息+公钥），CA拿自己私钥签名（这是个好人），接收方给发送方证书（我是好人），发送方拿CA公钥解密（含接收方的身份信息和公钥），拿接收方的公钥加密+自己证书，接收方验证证书、自己私钥解密</li>
</ul>
</li>
</ul>
<h2 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h2><p><strong>RSA算法</strong>-密钥交换算法</p>
<ul>
<li><p>客户端发送（TLS版本）、自身随机数、支持的加密算法</p>
</li>
<li><p>服务器端确认版本，发送自身随机数、选好加密算法、还有自己的证书</p>
</li>
<li><p>客户端验证证书、拿服务器公钥加密新随机数、发送握手结束信息</p>
</li>
<li><p>客户端和服务器将三个随机数生成密钥、握手结束通知</p>
</li>
<li><p><strong>缺陷：</strong>一旦服务器的私钥被盗了就G了</p>
</li>
</ul>
<p><strong>证书验证信任链：</strong></p>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/%E8%AF%81%E4%B9%A6%E9%93%BE.png" alt="img"></p>
<p><strong>确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题</strong></p>
<h2 id="如何保证完整性？"><a href="#如何保证完整性？" class="headerlink" title="如何保证完整性？"></a>如何保证完整性？</h2><ul>
<li>原始数据被切割-&gt;原始数据+（哈希函数（原始数据）+密钥）-&gt;消息摘要&#x3D;<strong>消息认证码</strong>MAC)</li>
<li>接收方对接收数据哈希算法对比MAC，保证完整性。再对原始数据进行哈希获得消息摘要，对比</li>
</ul>
<h2 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h2><ul>
<li><p>HTTP&#x2F;1.1</p>
<ul>
<li>短连接</li>
</ul>
</li>
<li><p>HTTP&#x2F;1.1</p>
<ul>
<li><p>长连接、支持管道（一直发）</p>
</li>
<li><p>纯文本形式的报文</p>
</li>
<li><p><strong>缺点：</strong>发送队头阻塞（依赖接收方能力）-请求响应模型&#x2F;头部未压缩</p>
</li>
</ul>
</li>
<li><p>HTTP&#x2F;1.2</p>
<ul>
<li>头部压缩<ul>
<li><code>HPACK</code> 算法-收发维护头部索引表，有重复头只需要发索引</li>
</ul>
</li>
<li>二进制发送（对计算机友好）</li>
<li>多个 Stream（封装了1.1的请求-响应报文（含多个frame-二进制压缩）） 复用在一条 TCP 连接-接收端根据StreamId重组</li>
<li>服务器端可用<strong>主动</strong>发<ul>
<li>客户端建立的 Stream 必须是<strong>奇数号</strong>，而服务器建立的 Stream 必须是偶数号</li>
</ul>
</li>
<li><strong>缺点：</strong>重组如果丢包，所有其他包需等其重传（阻塞）</li>
</ul>
</li>
<li><p>HTTP&#x2F;1.3</p>
<ul>
<li>QUIC 协议（<strong>伪</strong> TCP + TLS + HTTP&#x2F;2 的多路复用）</li>
<li>无队头阻塞（各stream独立，无需等前面stream接收完整）</li>
<li>握手过程只需要 1 RTT</li>
<li><strong>连接迁移</strong>（IP变化时消除连接成本）</li>
</ul>
</li>
</ul>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/27-HTTP3.jpeg" alt="HTTP/1 ~ HTTP/3"></p>
<h2 id="既然有-HTTP-协议，为什么还要有-RPC？"><a href="#既然有-HTTP-协议，为什么还要有-RPC？" class="headerlink" title="既然有 HTTP 协议，为什么还要有 RPC？"></a>既然有 HTTP 协议，为什么还要有 RPC？</h2><p><strong>定义：</strong>RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。-<strong>像调用本地方法一样调用远程方法</strong>，常用于微服务架构</p>
<p><strong>出现原因：</strong></p>
<p>TCP基于字节流-&gt;无边界-&gt;黏包，于是就有了各种协议，<strong>HTTP 和各类 RPC 协议</strong>就是在 TCP 之上定义的应用层协议</p>
<p><strong>特点：</strong></p>
<ul>
<li>一般会有专门的<strong>中间服务</strong>去保存服务名和IP信息（类别DNS）</li>
<li>长连接+连接池（便于连接复用）</li>
<li>二进制格式</li>
</ul>
<h2 id="既然有-HTTP-协议，为什么还要有-WebSocket？"><a href="#既然有-HTTP-协议，为什么还要有-WebSocket？" class="headerlink" title="既然有 HTTP 协议，为什么还要有 WebSocket？"></a>既然有 HTTP 协议，为什么还要有 WebSocket？</h2><p>需求：<strong>服务器主动发消息给客户端的场景</strong></p>
<p>场景：</p>
<ul>
<li>短轮询：扫前端二维码<ul>
<li>出现卡顿（轮询有间隔）</li>
</ul>
</li>
<li>长轮询：百度网盘二维码、Rabbit消息队列<ul>
<li>超时间隔增大</li>
</ul>
</li>
</ul>
<p><strong>出现原因：</strong>HTTP&#x2F;1.1 半双工-以前的需求不考虑网页广告这种（服务器主动）-》**基于TCP的新协议 **WebSocket</p>
<p><strong>过程：</strong>打开需要双工的页面需要升级协议（http-&gt;WebSocket）</p>
<ul>
<li>HTTP 请求里带上一些<strong>特殊的header 头</strong>（升级协议）</li>
<li><strong>三次TCP握手之后</strong>，跟http就没关系了</li>
</ul>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/format,png-20230309230534096.png" alt="TCP 头格式"></p>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/format,png-20230309230439961.png" alt="UDP 头部格式"></p>
<p><strong>TCP 和 UDP 可以使用同一个端口吗？</strong></p>
<p>传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。能找到就行，应用程序分别监听TCP&#x2F;UDP的端口。也就是说尽管端口号范围是重叠的也不会影响收发</p>
<h2 id="三次握手流程"><a href="#三次握手流程" class="headerlink" title="三次握手流程"></a>三次握手流程</h2><ul>
<li>客户端随机序号，SYN&#x3D;1  （SYN_SENT）</li>
<li>服务端随机序号，确认应答+1(下一个可接受的序号为)，SYN&#x3D;1,ACK&#x3D;1  (SYN_RCVD)</li>
<li>客户端确认应答+1，ACK&#x3D;1 (ESTABILISHED)</li>
<li>TCP协议允许第三次握手携带数据（连接此时已基本建立）</li>
</ul>
<p><strong>为什么是三次握手？不是两次、四次？</strong></p>
<ul>
<li><strong>防止「历史连接」初始化了连接</strong>&#x2F;同步双方初始序列号<ul>
<li>客户端可用判断确认号的序号判断建立是不是最新的连接，而选择是否发送 RST 报文结束连接</li>
<li><strong>两次连接没有这个过程</strong>，在客户端发送RST之前，服务器端可一直发送数据<strong>，浪费资源</strong></li>
</ul>
</li>
</ul>
<p><strong>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</strong></p>
<ul>
<li>避免历史数据混淆</li>
<li>防止重放攻击</li>
<li>序号生成ISN &#x3D; M（时钟递增参数） + F(localhost, localport, remotehost, remoteport)哈希</li>
<li>序号有可能回绕+时间标识，小于时间标识认为是旧的</li>
</ul>
<p><strong>既然 IP 层会分片，为什么 TCP 层还需要 MSS（1460-不带头） 呢？</strong>（1460+20+8+12&#x3D;1500）</p>
<ul>
<li>如果靠IP分片，丢失一次，所有分片都要重传；如果TCP用MSS，每次只要重传分片所含的那个报文</li>
</ul>
<p><strong>第一次握手丢失了，会发生什么？</strong></p>
<ul>
<li>设定最大重传次数（每次重传隔2^n秒） 客户端重传</li>
</ul>
<p><strong>第二次握手丢失了，会发生什么？</strong></p>
<ul>
<li>设定最大重传次数（每次重传隔2^n秒）-客户端+服务端 都重传</li>
</ul>
<p><strong>第三次握手丢失了，会发生什么？</strong></p>
<ul>
<li>设定最大重传次数（每次重传隔2^n秒） 服务端重传</li>
</ul>
<p><strong>什么是 SYN 攻击？如何避免 SYN 攻击？</strong></p>
<p>linux维护两个队列：半连接&#x2F;全连接</p>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/format,png-20230309230622886.png" alt="正常流程"></p>
<p><strong>被攻击：</strong>一直发SYN，SYN一直等ACK，<strong>半开放连接队列满了，后续再在收到 SYN 报文就会丢弃</strong></p>
<p><strong>解决方案：</strong></p>
<ul>
<li>SYN Cookie技术<ul>
<li>服务器收到SYN不分配资源，而是生成cookies返回客户端，客户端ack带上cookies验证</li>
</ul>
</li>
<li>增大 TCP 半连接队列</li>
<li>减少重传次数</li>
</ul>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p>
<p><strong>为什么挥手需要四次？</strong></p>
<p><strong>FIN表示：我不发了，但是我还能收</strong></p>
<p><strong>ACK：我晓得了</strong></p>
<p><strong>第一次挥手丢失了，会发生什么？</strong></p>
<ul>
<li>重传-超次数后 客户端closed</li>
</ul>
<p><strong>第二次挥手丢失了，会发生什么？</strong></p>
<ul>
<li>重传-超次数后 客户端closed</li>
</ul>
<p><strong>第三次挥手丢失了，会发生什么？</strong></p>
<ul>
<li>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数。重传-超次数后 服务端closed—客户端FIN_WAIT2等超时后也closed</li>
</ul>
<p><strong>第四次挥手丢失了，会发生什么？</strong></p>
<ul>
<li>客户端拿到FIN开始TIME_WAIT （2MSL），服务器拿不到ACK一直重传FIN，客户端每次拿到FIN刷新时间2MSL， 服务端超重传次数closed，客户端超2MSL closed</li>
</ul>
<p><strong>为什么需要 TIME_WAIT 状态？</strong></p>
<ul>
<li><p>序号循环使用，新连接收到的包可能是旧连接发来的识别不了（2MSL可用保证无论客户端发的包还是服务端发的包都已经GG了）</p>
</li>
<li><p>尽量保证最后的ACK能到达服务端（给服务端发现丢失重传FIN的机会）</p>
</li>
</ul>
<p><strong>TIME_WAIT 过多有什么危害？</strong></p>
<ul>
<li><p><strong>端口资源耗尽</strong>：每个TCP连接都需要使用一个端口 新连接无法建立</p>
</li>
<li><p><strong>系统性能下降：</strong>内存占用、cpu占用</p>
</li>
</ul>
<p><strong>TIME_WAIT 大量的原因</strong></p>
<ul>
<li>大量短连接</li>
<li>长连接超时</li>
<li>HTTP 长连接的请求数量达到上限</li>
</ul>
<p><strong>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</strong>（FIN发不出来，服务端的程序没有调用 close 函数关闭连接）</p>
<p>TCP服务端各步骤出现问题：</p>
<ul>
<li>创建服务端 socket，bind 绑定端口、listen 监听端口</li>
<li>将服务端 socket 注册到 epoll<ul>
<li><strong>Epoll</strong> 是 Linux 提供的一种高效的 I&#x2F;O 多路复用机制，用于同时监控多个文件描述符（如套接字、文件等），以确定哪些文件描述符已经准备好进行 I&#x2F;O 操作</li>
</ul>
</li>
<li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket<ul>
<li><code>epoll_wait</code> 阻塞等待 Epoll 实例中的事件。当有文件描述符准备好进行 I&#x2F;O 操作时，<code>epoll_wait</code> 会返回这些文件描述符及其对应的事件类型</li>
</ul>
</li>
<li>将已连接的 socket 注册到 epoll</li>
<li>epoll_wait 等待事件发生</li>
<li>对方连接关闭时，我方调用 close</li>
</ul>
<p><strong>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</strong></p>
<p>内核负责四次挥手</p>
<p><strong>没有 accept，能建立 TCP 连接吗？</strong></p>
<p>accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。</p>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/3.jpg" alt="半连接队列与全连接队列"></p>
<h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><ul>
<li>超时重传（计时器）<ul>
<li>不好确定时间</li>
</ul>
</li>
<li>快速重传（客户端连续接收3个相同的ACK重传）<ul>
<li>无法判断需要重传的包数量</li>
</ul>
</li>
<li>选择性确认（接收方标识给发送方已收到的包）</li>
<li>Duplicate SACK 重复选择性确认（标识重复收到的包）<ul>
<li>对面网络延时，导致ack误会让它重发</li>
<li>ack丢包</li>
</ul>
</li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul>
<li>窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值</li>
</ul>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>让「发送方」根据「接收方」的实际接收能力控制发送的数据量</p>
<ul>
<li>发送方和接收方通过 SYN 和 ACK 消息交换初始窗口大小</li>
<li>发送方根据 SNDWND 发送数据，接收方接收数据并存储在缓冲区，，接收方通过确认消息（ACK）告知发送方其缓冲区的可用空间</li>
<li>接收方的缓冲区逐渐填满，接收窗口大小逐渐减小。发送方根据接收窗口大小动态调整发送窗口大小，减少发送速率</li>
<li>接收方的缓冲区满了，接收窗口大小设置为 0，发送方等待发送</li>
<li>窗口大小&#x3D;缓存队列大小（OS可变）-未被处理的数据大小</li>
</ul>
<p><strong>TCP不允许先减少缓存再收缩窗口-如果先减少，按着旧窗口大小会有溢出的情况</strong></p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p><strong>拥塞窗口控制：</strong></p>
<ul>
<li>swnd &#x3D; min(cwnd, rwnd)</li>
<li>随着拥塞情况（接收ack情况）变化而变化</li>
</ul>
<p><strong>控制算法</strong></p>
<ul>
<li>慢启动<ul>
<li><strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1</strong> –&gt;指数增长</li>
<li>超慢门限启动拥塞避免</li>
</ul>
</li>
<li>拥塞避免<ul>
<li>+1 线性增长</li>
</ul>
</li>
<li>拥塞发生-重传<ul>
<li>超时重传<ul>
<li>ssthresh &#x3D;cwnd&#x2F;2 cwnd重置未为1</li>
</ul>
</li>
<li>快速重传（接收3个ack）–<strong>网络没那么糟糕，不用直接置1</strong><ul>
<li>cwnd &#x3D; cwnd&#x2F;2+ssthresh&#x3D;cwnd+快速恢复</li>
</ul>
</li>
</ul>
</li>
<li>快速恢复<ul>
<li>拥塞窗口 cwnd &#x3D; ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；（<strong>尽快恢复，能收到ack意味着可能是流量控制那边问题，网络还好</strong>）</li>
<li>如果收到新数据的 ACK 后，把 <strong>cwnd 设置为第一步中的 ssthresh</strong> 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
</li>
</ul>
<p><strong>TCP 是面向字节流的协议，UDP 是面向报文的协议？这里的「面向字节流」和「面向报文」该如何理解。</strong></p>
<ul>
<li>TCP不保留报文的边界。发送方将数据分割成多个 TCP 段</li>
<li>UDP 将数据视为独立的报文，每个报文都携带完整的信息。发送方将数据分割成多个 UDP 报文，并通过网络发送这些报文。</li>
</ul>
<p><strong>TCP的黏包问题</strong>–应用层处理</p>
<ul>
<li>固定长度</li>
<li>消息分割符（包内有的话加转义）</li>
<li>长度标识</li>
</ul>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/7.jpg" alt="IP 地址分类"></p>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/8.jpg" alt="img"></p>
<p><strong>无分类地址 CIDR</strong>：a.b.c.d&#x2F;x</p>
<p><strong>子网掩码</strong></p>
<p><strong>RARP 协议你知道是什么吗？</strong></p>
<ul>
<li>已知 MAC 地址求 IP 地址（打印机服务器）</li>
</ul>
<p><strong>DHCP：</strong></p>
<ul>
<li>客户端首先发起 DHCP 发现报文（DHCP DISCOVER）（广播）-你在哪</li>
<li>DHCP 提供报文（DHCP OFFER） 向客户端做出响应（广播）-我在着，可分配的IP是</li>
<li><strong>DHCP 请求报文</strong>，单点-OK我要这个了</li>
<li>响应 -ok</li>
</ul>
<p><strong>NAT：</strong></p>
<ul>
<li>两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的<strong>端口号</strong>作为区分</li>
</ul>
<p><strong>ICMP：</strong></p>
<ul>
<li><p><strong>回送消息</strong>用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，ping 命令就是利用这个消息实现-端主机发送<strong>回送请求</strong>的消息（类型8），端主机发回来的<strong>回送应答</strong>（类型0）</p>
</li>
<li><p>一类是用于<strong>诊断</strong>的查询消息，也就是「查询报文类型」</p>
</li>
<li><p>另一类是通知出错原因的错误消息，也就是「差错报文类型」</p>
</li>
</ul>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/9.jpg" alt="目标不可达类型的常见代码号"></p>
<blockquote>
<p>重定向消息（ICMP Redirect Message） —— 类型 <code>5</code>（通过它告诉主机有更好的路由）</p>
<p>超时消息（ICMP Time Exceeded Message） —— 类型 <code>11</code></p>
</blockquote>
<h2 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h2><p>基于 ICMP 协议（<strong>ICMP 回送请求消息</strong>-类型8）</p>
<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/13.jpg" alt="主机 A 的 ICMP 回送请求报文"></p>
<ul>
<li><p>会自动加 <code>1</code>。为了能够计算往返时间 <code>RTT</code>，加入发送时间</p>
</li>
<li><p>主机 <code>B</code> 会构建一个 <strong>ICMP 回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为 <code>0</code></p>
</li>
</ul>
<h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><ul>
<li><strong>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器</strong>（TTL分别设置1，2，3…）<ul>
<li>traceroute 在发送 <code>UDP</code> 包时，会填入一个<strong>不可能的端口号</strong>（故意找错找返回的借口），目的主机收到 UDP 包后，会返回 ICMP 差错报文消息类型是「<strong>端口不可达」</strong></li>
</ul>
</li>
<li><strong>路径MTU发现</strong>（找最优MTU）-&gt;故意设置不分片，从而确定路径的 MTU<ul>
<li>将 <code>IP</code> 包首部的<strong>分片禁止标志位设置为 1</strong></li>
<li>路由器返回不可达消息的类型为「<strong>需要进行分片但设置了不分片位</strong>」+MTU信息</li>
<li>发送方收到后减小MTU</li>
</ul>
</li>
</ul>
<h2 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"><a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="headerlink" title="127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗"></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h2><ul>
<li>localhost 就不叫 IP，它是一个域名，默认会把它解析为 127.0.0.1</li>
<li>listen 的是本机的 0.0.0.0 , 那么它表示本机上的所有IPV4地址。服务器 listen 的是 0.0.0.0，那么此时用127.0.0.1和本机地址都可以访问到服务</li>
</ul>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: 食芒果冰 | Theme By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">Page Views: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">Unique Visitors: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
