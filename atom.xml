<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>部落格</title>
  
  
  <link href="https://senwh.github.io/atom.xml" rel="self"/>
  
  <link href="https://senwh.github.io/"/>
  <updated>2025-05-29T08:48:26.731Z</updated>
  <id>https://senwh.github.io/</id>
  
  <author>
    <name>Sen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>系统设计问答</title>
    <link href="https://senwh.github.io/2025/05/09/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%97%AE%E7%AD%94/"/>
    <id>https://senwh.github.io/2025/05/09/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%97%AE%E7%AD%94/</id>
    <published>2025-05-09T12:53:04.000Z</published>
    <updated>2025-05-29T08:48:26.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何设计一个阻塞队列？"><a href="#如何设计一个阻塞队列？" class="headerlink" title="如何设计一个阻塞队列？"></a>如何设计一个阻塞队列？</h2><ul><li>首先我会考虑线程安全的问题，阻塞队列的操作主要有两个，一个是push，一个task，需要保证他们在多线程情况下操作的线程安全，可以考虑使用synchronized或者ReentrantLock来实现。第二个要有阻塞和唤醒的机制，当队列为空的时候，阻塞消费者线程，使用wait()+notify 或者信号量。队列满的时候可以阻塞生产者线程。第三个可以考虑容量设置，如果设置为有界的话，考虑满之后设计拒绝策略，如果无界的话会有内存溢出风险，要做相应的应对措施。</li></ul><h2 id="如何设计一个线程安全的LRU？"><a href="#如何设计一个线程安全的LRU？" class="headerlink" title="如何设计一个线程安全的LRU？"></a>如何设计一个线程安全的LRU？</h2><ul><li>首先最简单的方式就是给各put&#x2F;get方法上锁，通过synchronied或者RenentransLock等。如果想避免锁的开销，使用无锁的方式的话可以考虑使用乐观锁的思想去对链表中的结点操作，在处理双向链表和Map的过程中，一个是链表结点的移动需要保证前后指针引用更新的原子性，可以对结点使用AtomicReference修饰，它是基于乐观锁的思想，通过CAS的方式修改node的指针。另外在使用Map维护key和结点时这个过程也要保证并发安全，可以 直接使用ConcurrentHashMap来保证并发安全，它的底层原理是通过volatile修饰key value，保证线程对内容的可见性。另外在无哈希冲突时，使用CAS去存入值，当然如果遇到哈希冲突了通过给头节点用synchronized上锁保证并发安全。</li></ul><h2 id="如何设计一个Map？"><a href="#如何设计一个Map？" class="headerlink" title="如何设计一个Map？"></a>如何设计一个Map？</h2><ul><li>首先我会考虑数据结构的选择，需要快速访问某个元素可以用哈希表，例如HashMap，如果对键有顺序要求可以使用红黑树例如HashTree或者LinkHashMap。另外从并发安全的角度考虑的话，可以通过锁的方式，例如synchronized，参考ConcurrentHashMap。另外，考虑性能方面的话，首先考虑扩容的开销的话，一个是预分配好初始化的大小，减少扩容次数。另外可以参考HashMap的一些扩容细节，例如在计算索引位置的时候用与运算代替取模运算，减少计算开销。另外，根据需求考虑负载因子的设计，因子越大利用率越高，当然越容易冲突。当然哈希函数的设计也很重要，使映射尽量均匀减少冲突。在冲突之后，如何解决冲突也是需要考虑的，如果是key比较稀疏的，可以参考ThreadLocal处理冲突的设计，使用开发地址法，不需要额外创建结点的开销。对应key比较密集的，可以参考HashMap使用拉链法，用空间换时间。</li></ul><h2 id="如何设计一个注册中心？"><a href="#如何设计一个注册中心？" class="headerlink" title="如何设计一个注册中心？"></a>如何设计一个注册中心？</h2><ul><li>首先其需要提供服务注册和服务发现的功能，也就是说将服务提供者将自己的地址和服务注册到服务中心，客户端可以根据服务名称获得服务端的IP地址。可以通过持久性数据库、缓存、本地内存来实现。其次，还需要健康检查的功能，可以参考TCP，Netty，websocket的心跳机制，使用定期ping来保证与客户端实例互通，或者让客户端在访问服务端的实例失败时告诉nacos，及时发现损坏的节点。第三个点在高并发请求时，需要负载均衡来分流，可以用一些算法，例如轮询、随机、按最小连接数等。当然，还要考虑高可用的问题，也就是通过集群来实现，一旦出现集群，就要考虑一致性的问题，可以参考nacos，使用raft协议。</li></ul><h2 id="如何设计一个消息队列？"><a href="#如何设计一个消息队列？" class="headerlink" title="如何设计一个消息队列？"></a>如何设计一个消息队列？</h2><ul><li>首先考虑模型选型，一个点对点的模型，例如RabbitMQ，这种结构简单，只要维护路由信息，但是只适用特定场景。发布订阅模型，例如RocketMQ或者kafka，支持消息被多个消费者消费，从拓展性来说大大提高，服务端只要订阅Topic，不用维护路由信息。当然随着消费者增多，保证消息都能正确被消费，或者按顺序消费也是个挑战，对于RockMQ来说，可以使用重试+ack机制保证可靠性，分布式事务保证服务消费的一致性。第二点保证高可靠，高可靠从两方法讨论，一个是持久化，另一个是集群。对于RocketMQ来说，其持久化是通过CommitLog顺序写入磁盘，索引读的方式，对比kafka同一分区顺序写，但随着分区增多，表现为随机写，相比之下，RocketMQ这种方式减少磁盘寻道时间。当然涉及到落盘，又要考虑根据业务需要权衡性能和可靠性的问题了，涉及同步异步的设置。如果是集群的话又要考虑一致性的问题，RocketMQ是用Raft协议来保证的。第三点的话，从功能特性来考虑，RocketMQ提供了延时队列，死信队列，消息过滤等功能。另外从性能优化的角度来说，对于需要高吞吐的场景，可以参考kafka的消息压缩、批量发送，零拷贝。</li></ul><h2 id="设计一个支持亿级用户的短视频推荐与播放系统"><a href="#设计一个支持亿级用户的短视频推荐与播放系统" class="headerlink" title="设计一个支持亿级用户的短视频推荐与播放系统"></a>设计一个支持亿级用户的短视频推荐与播放系统</h2><h2 id="设计一个海量短视频文件存储系统"><a href="#设计一个海量短视频文件存储系统" class="headerlink" title="设计一个海量短视频文件存储系统"></a>设计一个海量短视频文件存储系统</h2><h2 id="设计一个支持瞬时10万QPS的秒杀系统-12306"><a href="#设计一个支持瞬时10万QPS的秒杀系统-12306" class="headerlink" title="设计一个支持瞬时10万QPS的秒杀系统(12306)"></a>设计一个支持瞬时10万QPS的秒杀系统(12306)</h2><h2 id="实现一个feed流系统"><a href="#实现一个feed流系统" class="headerlink" title="实现一个feed流系统"></a>实现一个feed流系统</h2><ul><li>首先feed流是指用户关注的多个对象发布内容，按时间或热度更新给用户的场景。那它其实面临着高并发、数据量大、实时性要求高的需求。整个链路其实就是客户端、网关、服务层、缓存+DB。表设计的话主要涉及到关注者、被关注者、发布内容，数据库里两个表，一个是存关注和被关注者，另外一个就是发布者及其内容的表。按热度&#x2F;更新时间查看的需求，可以将数据放到redis的zset里面。对于强实时性，可以直接通过websocket推送更新的信息，，一些热门用户可以通过将更新数据放到消息队列，push给用户，普通用户拉取，降低数据库压力。</li></ul><h2 id="如何设计一个线程池"><a href="#如何设计一个线程池" class="headerlink" title="如何设计一个线程池"></a>如何设计一个线程池</h2><ul><li>首先线程池主要是用于减少线程创建销毁带来的性能开销，核心部分我觉得要考虑任务队列、工作线程、拒绝策略、线程关闭。首先要设立一个变量技术线程数大小，用于判断是否创建新线程。第二点任务提交和线程获取任务时需要保证并发安全，同时在无任务时需要阻塞线程，任务来时唤醒。第三点队列满了，任务怎么处理。第四点，考虑关闭线程池。</li></ul><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ul><li>在订单量较大的时候，为了避免单表过大导致索引树的高度上升，进而导致IO次数的增加。可以对单表进行拆分，在拆分的时候首先考虑是分片键。首先目标是同一个用户的数据分在一个分片上，避免跨表查询，那么可以用用户id作为分片键。另外用户通常会根据订单号去查找具体订单详情，基于前面说的用用户id作为分片键，可以考虑直接接用户id参与订单id的生成，这样只要通过订单id这样一个参数就可以实现分片的索引。另外的一个分片的选择可以按订单创建进行分库分片，参考淘宝来说，以30天为界限，30天后的订单数据分到其他库中，可以用一些性能稍差的数据库来存储这种冷数据。至于分片算法的话对于分片数量变化不太频繁的情况可以直接用简单的对分片键取模，或者维护一张哈希表做映射，这样配置更灵活。对于分片数量会变动比较多的，可以使用一致性哈希。然后前面提到的其实就是所谓的水平分表。对表来说也可以按字段来分，对于订单基本信息这样频繁查看的就使用一个基本信息表来存储，对于订单详情、备注等数量量大但是访问不多的可以重新划分一个表。在并发量比较大的时候，单个数据库实例可能压力比较大，可以考虑按对库按业务拆分，例如订单库，库存库等，也可以通过按创建时间为key进行分片。当然从商家角度来说，为了方便商家查找，可以冗余一个订单库，分片键可以按地区id或者按创建时间。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何设计一个阻塞队列？&quot;&gt;&lt;a href=&quot;#如何设计一个阻塞队列？&quot; class=&quot;headerlink&quot; title=&quot;如何设计一个阻塞队列？&quot;&gt;&lt;/a&gt;如何设计一个阻塞队列？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先我会考虑线程安全的问题，阻塞队列的操作主要有两个，一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>项目问答及场景题扩展</title>
    <link href="https://senwh.github.io/2025/04/29/%E9%A1%B9%E7%9B%AE%E9%97%AE%E7%AD%94%E5%8F%8A%E5%9C%BA%E6%99%AF%E9%A2%98%E6%89%A9%E5%B1%95/"/>
    <id>https://senwh.github.io/2025/04/29/%E9%A1%B9%E7%9B%AE%E9%97%AE%E7%AD%94%E5%8F%8A%E5%9C%BA%E6%99%AF%E9%A2%98%E6%89%A9%E5%B1%95/</id>
    <published>2025-04-29T12:40:12.000Z</published>
    <updated>2025-06-03T07:28:53.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="餐饮订购系统"><a href="#餐饮订购系统" class="headerlink" title="餐饮订购系统"></a>餐饮订购系统</h1><h3 id="介绍一下项目？里面有什么亮点难点？"><a href="#介绍一下项目？里面有什么亮点难点？" class="headerlink" title="介绍一下项目？里面有什么亮点难点？"></a>介绍一下项目？里面有什么亮点难点？</h3><p>我设计的是一个餐饮订购平台，其包括优惠券秒杀，用户登录，订单和库存管理等核心功能。在技术上，商品浏览和购物车模块通常请求量较大所以引入redis缓存加快请求响应，但引入缓存后考虑到可能会有缓存穿透的问题，所以加入布隆过滤器对非法数据进行过滤。用户在下单支付后，需要通知商家发货，所以使用了可以服务器主动推送的Websock协议，用户在下单后可能会未支付，需要对这些订单进行处理，这可以用延时队列来处理，考虑到RocketMQ提供了延时队列的功能，并且能保证消息的可靠传输，所以将消息投递到消息队列中，超时后被消费，修改订单状态。除此之外，在优惠券抢购中，在这种高并发的场景下，有两个难点需要被解决，一个是防止超卖，另外一个因为库存被预热到redis中，还需要考虑redis和DB的一致性。针对超卖的问题，其引发的原因主要是多个用户即多个线程同时读写库存，我使用的解决方案是lua脚本执行原子性读写。针对一致性的问题，也是使用RocketMQ的ACK和重传机制保证最终一致性。</p><h2 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h2><h2 id="介绍一下登录流程？服务端是如何记住用户登录状态的？"><a href="#介绍一下登录流程？服务端是如何记住用户登录状态的？" class="headerlink" title="介绍一下登录流程？服务端是如何记住用户登录状态的？"></a>介绍一下登录流程？服务端是如何记住用户登录状态的？</h2><ul><li>登录流程基于JWT+拦截器的无状态鉴权体系：用户在提交账号密码后，服务端验证并生成Java web token 返回给客户端，客户端在后续请求中携带该Token，服务器通过拦截器解析Token并验证用户身份。</li></ul><h2 id="需要我再讲讲具体的签名验证过程吗？"><a href="#需要我再讲讲具体的签名验证过程吗？" class="headerlink" title="需要我再讲讲具体的签名验证过程吗？"></a>需要我再讲讲具体的签名验证过程吗？</h2><ul><li>JWT由三部分组成，分别是Header，payload，signature。首次生成signature时，对Header和payload和服务器密钥用算法加密生成签名。后续获取到token只要比对签名就可以判断内容是否被篡改。</li></ul><h3 id="为什么选择JWT而不是Session-Cookie机制？"><a href="#为什么选择JWT而不是Session-Cookie机制？" class="headerlink" title="为什么选择JWT而不是Session-Cookie机制？"></a>为什么选择JWT而不是Session-Cookie机制？</h3><p>首先第一个点JWT是无状态的，也就是说在服务器端不需要存储其他额外的信息，一个是减轻了服务器的负担，另一个就是Session-Cookie机制这种机制的话，对于在分布式场景下，需要多个服务器去同步同一个用户的信息，增加开销。第二个点就是JWT更加安全，对于跨域请求伪造，cookies在每次请求的时候都会自动发送，以至于被攻击，而jwt可以放在请求头的authorization里面，在需要时才发送</p><ul><li>jwt之所以不受同源限制是因为他需要显示添加到请求头，用户自定义控制风险。Cookies是发送请求时自带，为了避免CSRF需要同源限制</li></ul><h2 id="如果密钥泄露导致Token被伪造，如何快速发现和止损？"><a href="#如果密钥泄露导致Token被伪造，如何快速发现和止损？" class="headerlink" title="如果密钥泄露导致Token被伪造，如何快速发现和止损？"></a>如果密钥泄露导致Token被伪造，如何快速发现和止损？</h2><ul><li>可以采用双token方案，access token 用于鉴权并设立较短的时间， fresh token 设立较长的过期时间，服务端需记录其绑定的用户ID和设备信息，以便检测异常使用。当检测access token到期时，根据fresh token 重新生成新的access token。</li></ul><h3 id="拦截器和过滤器的底层原理"><a href="#拦截器和过滤器的底层原理" class="headerlink" title="拦截器和过滤器的底层原理"></a>拦截器和过滤器的底层原理</h3><ul><li>前端发送请求先到DispatcherServlet，然后到HandlerMapping匹配Hander，再到Hander Adaptor执行Handle，拦截器处理器执行前执行prehandle，视图渲染前执行postHandle,浏览器响应前执行afterComplete。拦截Spring管理的Controller请求，适用认证与权限验证。执行顺序Filter前置-&gt;Interceptor-&gt;Filter后置</li><li>过滤器底层是执行回调函数，处理粒度是在HTTP请求和响应层面，适用全局编码处理。拦截器体现AOP思想，即对web请求应用同一组方法，分别在处理器执行前执行prehandle，视图渲染前执行postHandle,浏览器响应前执行afterComplete。拦截Spring管理的Controller请求，适用认证与权限验证。执行顺序Filter前置-&gt;Interceptor-&gt;Filter后置</li><li>（Spring MVC）拦截器执行顺序 查找处理器-&gt;prehandle-&gt;处理器执行-&gt;postHandle-&gt;视图渲染-&gt;afterComplete-&gt;浏览器响应</li></ul><h3 id="为什么使用ThreadLocal？"><a href="#为什么使用ThreadLocal？" class="headerlink" title="为什么使用ThreadLocal？"></a>为什么使用ThreadLocal？</h3><ul><li>一个是为保证了并发安全，在有多个用户登录时，意味着有多个线程访问，使用一个变量例如用户id会出现竞态条件，利用ThreadLocal的线程隔离性，为每个线程分配独立的变量副本，保证线程安全。第二点因为用户登录和订单服务放在同一个服务实例中，如果显示传参太复杂，通过ThreadLocal可以隐式传参，简化代码逻辑。</li></ul><h3 id="如果ThreadLocal里的Entry不用弱引用，需要做哪些处理？在使用类似ThreadLocal这种全局变量还需要注意什么？"><a href="#如果ThreadLocal里的Entry不用弱引用，需要做哪些处理？在使用类似ThreadLocal这种全局变量还需要注意什么？" class="headerlink" title="如果ThreadLocal里的Entry不用弱引用，需要做哪些处理？在使用类似ThreadLocal这种全局变量还需要注意什么？"></a>如果ThreadLocal里的Entry不用弱引用，需要做哪些处理？在使用类似ThreadLocal这种全局变量还需要注意什么？</h3><ul><li>手动处理&#x2F;定时处理&#x2F;任务处理完后遍历处理&#x2F;需要注意一是，如果存储在 <code>ThreadLocal</code> 中的对象是可变的（例如一个可变集合），仍然可能存在线程安全问题&#x2F;如果任务之间不能共享 <code>ThreadLocal</code> 数据，可以考虑为每个任务分配独立的线程&#x2F;需要任务之间共享 <code>ThreadLocal</code> 数据，可以使用 <code>InheritableThreadLocal</code></li></ul><h2 id="商品浏览模块-购物车模块"><a href="#商品浏览模块-购物车模块" class="headerlink" title="商品浏览模块&#x2F;购物车模块"></a>商品浏览模块&#x2F;购物车模块</h2><h3 id="对于项目中布隆过滤器的设计是怎么样的，你为什么这么设计？"><a href="#对于项目中布隆过滤器的设计是怎么样的，你为什么这么设计？" class="headerlink" title="对于项目中布隆过滤器的设计是怎么样的，你为什么这么设计？"></a>对于项目中布隆过滤器的设计是怎么样的，你为什么这么设计？</h3><ul><li>在项目中，为了防止恶意请求访问不存在的商品ID，在redis缓存层之前加了一层布隆过滤器，用于快速判断商品ID是否存在。我是设定项目目前有1w个商品，商品id是64位长整型，误判率设置为0.1%（设置为0.1主要权衡性能和准确性，如果误判率设置太小，意味这着需要更大的位数组，对于电商项目来说，更注重性能），通过公式计算，需要大概18KB的位数组和10个哈希函数。</li><li>1000w商品id，误判率0.1%，位数组为17MB，10个哈希函数</li></ul><h3 id="如果商品数据每日新增百万级，如何动态更新布隆过滤器？"><a href="#如果商品数据每日新增百万级，如何动态更新布隆过滤器？" class="headerlink" title="如果商品数据每日新增百万级，如何动态更新布隆过滤器？"></a>如果商品数据每日新增百万级，如何动态更新布隆过滤器？</h3><ul><li>首先我会考虑更新的时机，1个是考虑到白天会有大量用户访问业务，如果这时候更新布隆过滤器会导致短时间的过滤服务停止，会产生缓存穿透问题，所以可以根据访问记录，选择访问数量少的时段，例如定期在凌晨更新，第二个点考虑到更新布隆器时会有过滤服务停止时机，考虑增加一个备份的布隆过滤器，在需要更换的时候直接替换，这时候就是用空间来换时间。第三个点的话可以考虑将布隆过滤器分片，这样每次更新的话，这更新一部分数据的过滤器。第四点的话，也是牺牲性能，考虑使用计数型布隆过滤器。</li></ul><h3 id="在使用Redis缓存热点商品数据和购物车记录中，redis是如何设计的？为什么这么设计？为什么使用redis？"><a href="#在使用Redis缓存热点商品数据和购物车记录中，redis是如何设计的？为什么这么设计？为什么使用redis？" class="headerlink" title="在使用Redis缓存热点商品数据和购物车记录中，redis是如何设计的？为什么这么设计？为什么使用redis？"></a>在使用Redis缓存热点商品数据和购物车记录中，redis是如何设计的？为什么这么设计？为什么使用redis？</h3><ul><li>对于一些商品的基本信息，例如商品名，商品口味等不需要频繁变动的，使用了String类型执行存储，key为商品id，value为JSON字符串。对于购物车这种需要频繁访问和变动的则用Hash来存储，方便随时获取某一字段的value。对比Memcache，提供丰富的数据结构，事务、持久化机制等</li></ul><h3 id="你如何定义“热点商品”？如何自动识别并缓存它们？如果某个热点商品的缓存突然失效，导致大量请求穿透到数据库，如何预防？"><a href="#你如何定义“热点商品”？如何自动识别并缓存它们？如果某个热点商品的缓存突然失效，导致大量请求穿透到数据库，如何预防？" class="headerlink" title="你如何定义“热点商品”？如何自动识别并缓存它们？如果某个热点商品的缓存突然失效，导致大量请求穿透到数据库，如何预防？"></a>你如何定义“热点商品”？如何自动识别并缓存它们？如果某个热点商品的缓存突然失效，导致大量请求穿透到数据库，如何预防？</h3><ul><li>热点商品可以通过商品的访问次数，或者加入到购物车的次数来识别。具体来说，如果是单体项目，可以直接用本地内存例如直接用HashMap去存储商品次数，在分布式环境下，可以使用redis存储。</li><li>一个是定期去判断该商品是否为热点商品，如果是就更新过期时间，第二点就是并发控制，在突然失效的时候，控制只让一个线程访问数据，更新缓存。 第三点就是，服务降级嘛，拒绝一些请求，防止系统奔溃。</li></ul><h3 id="如何保证redis和数据库的一致性？"><a href="#如何保证redis和数据库的一致性？" class="headerlink" title="如何保证redis和数据库的一致性？"></a>如何保证redis和数据库的一致性？</h3><ul><li>对于普通商品详情页，是一种读多写少的场景，对于数据一致性要求不是很严格。所以我使用的是旁路缓存，写入数据库后删缓存，虽然它不能保证强一致性，但是它通过过期时间实现最终一致性。对比更新缓存复杂性增加，做更新失败的判断逻辑，另外每次都要将数据放到redis更新。对于延迟双删：需要额外的定时任务或消息队列。当然对于读写穿透，也就是让缓存层同步数据库以保证强一致性，但这种方法给缓存层带来更大的压力的同时，同步意味着需要牺牲性能，所以没采用这种方法。对于热点数据，例如优惠券的库存，我的目标是只要保证最终一致性就行，所以采用异步更新数据库的方式，以提升系统性能。如果要保证强一致的话就要牺牲性能，通过同步的方式保证一致性。</li></ul><h3 id="如果redis缓存删除失败了，或者异步更新数据库失败了怎么办？"><a href="#如果redis缓存删除失败了，或者异步更新数据库失败了怎么办？" class="headerlink" title="如果redis缓存删除失败了，或者异步更新数据库失败了怎么办？"></a>如果redis缓存删除失败了，或者异步更新数据库失败了怎么办？</h3><ul><li>首先缓存删除失败通常可能是网络IO或者redis服务器繁忙的问题，那么可以使用重试机制，根据网络条件设置重试间隔或者避免频繁重试的话可以使用指数退避。当然对于商品详情页来说只要实现最终一致的话，依赖redis的过期时间即可保证最终一致性。在异步更新数据库的时候失败，也可以使用重试的机制，当到达最大重试次数，会投入死信队列，设立定时任务重新将消息重新投递。</li></ul><h3 id="对于redis缓存，购物车模块中为每个用户分配多大内存？500M能存放多少购物车数据？"><a href="#对于redis缓存，购物车模块中为每个用户分配多大内存？500M能存放多少购物车数据？" class="headerlink" title="对于redis缓存，购物车模块中为每个用户分配多大内存？500M能存放多少购物车数据？"></a>对于redis缓存，购物车模块中为每个用户分配多大内存？500M能存放多少购物车数据？</h3><ul><li>首先购物车模块用的是Hash数据结构，一个用户一个商品id为64位整数，8个字节。商品数量设计为4个字节，属性+价格大概20个字节，redis自身Hash额外开销大概在70字节，平均下来一个商品需要100字节。如果每个用户为最大为100个商品，那么就分配10kB的内存。</li></ul><h3 id="购物车数据用Redis-Hash存储，用户ID为Key，商品ID为Field。如果用户购物车中有数万商品，这个设计会有什么问题？如何优化？如果用户清空购物车，如何保证缓存与DB原子性？"><a href="#购物车数据用Redis-Hash存储，用户ID为Key，商品ID为Field。如果用户购物车中有数万商品，这个设计会有什么问题？如何优化？如果用户清空购物车，如何保证缓存与DB原子性？" class="headerlink" title="购物车数据用Redis Hash存储，用户ID为Key，商品ID为Field。如果用户购物车中有数万商品，这个设计会有什么问题？如何优化？如果用户清空购物车，如何保证缓存与DB原子性？"></a>购物车数据用Redis Hash存储，用户ID为Key，商品ID为Field。如果用户购物车中有数万商品，这个设计会有什么问题？如何优化？如果用户清空购物车，如何保证缓存与DB原子性？</h3><ul><li>一个Hash存大量的field意味着，Hash在扩容的时候会按照2的幂次方扩容，那么很容易产生内存碎片。可以考虑对商品按id&#x2F;热点id进行分片。清空购物车保证与DB原子性，清空购物车通常不需要强一致性，可以使用消息队列解耦，用通过重试机制保证最终一致性。如果需要强一致性的话可以使用2PC分布式事务，保证数据库和缓存强一致性。</li></ul><h3 id="多端（Web-APP）同时修改购物车，如何保证数据正确性？"><a href="#多端（Web-APP）同时修改购物车，如何保证数据正确性？" class="headerlink" title="多端（Web&#x2F;APP）同时修改购物车，如何保证数据正确性？"></a>多端（Web&#x2F;APP）同时修改购物车，如何保证数据正确性？</h3><ul><li>在这种并发不高的情况，可以使用redis的watch命令实现乐观锁，watch+key ，如果key对应的value在被更改前被其他线程更改了，则抛出异常执行重试逻辑。当然如果是高并发的场景，可以考虑使用分布式锁，对用户id进行加锁。</li></ul><h3 id="购物车数据需要持久化吗？何时同步到DB？"><a href="#购物车数据需要持久化吗？何时同步到DB？" class="headerlink" title="购物车数据需要持久化吗？何时同步到DB？"></a>购物车数据需要持久化吗？何时同步到DB？</h3><ul><li>对于订餐场景，我考虑的只是作为一直临时性的存储，只存放在redis里面，会话结束后删除。如果希望会话结束之后还存在的话，可以根据实时性需求和性能的取舍，通过实时同步或者批量同步或者异步到数据库</li></ul><h3 id="你提到在商品浏览和购物车模块中使用了-Redis-缓存。那么你是如何设置缓存的过期时间的？有没有考虑过不同的数据类型需要不同的过期策略？"><a href="#你提到在商品浏览和购物车模块中使用了-Redis-缓存。那么你是如何设置缓存的过期时间的？有没有考虑过不同的数据类型需要不同的过期策略？" class="headerlink" title="你提到在商品浏览和购物车模块中使用了 Redis 缓存。那么你是如何设置缓存的过期时间的？有没有考虑过不同的数据类型需要不同的过期策略？"></a>你提到在商品浏览和购物车模块中使用了 Redis 缓存。那么你是如何设置缓存的过期时间的？有没有考虑过不同的数据类型需要不同的过期策略？</h3><ul><li>首先在电商的场景下，基本商品信息通常读多写少，所以我为他们设立了1小时的过期时间。对于商品详情（当然如果商品量比较大redis内存有限，可以根据商品的访问频率来设定过期时间，热门商品可以设立更长的过期时间），对于购物车来说，写操作比较频繁，过期时间可以更短。那么处理过期的商品信息有几种方案，一个是为每个key开启定时器，则直接删除对应的key，或者使用延时队列处理，这两张方法精确度比较高，但是随着key的增多，定时器的开销和队列的开销会上升。通过redis懒删除+定期随机抽样删除的方式处理过期商品，通过设立定期抽样删除的频率做性能和内存回收的权衡嘛，懒删除的话可以保证过期商品可以被正确处理</li></ul><h3 id="你的-Redis-实例是如何配置淘汰策略的？是使用默认的-LRU-策略，还是选择了其他策略？为什么？"><a href="#你的-Redis-实例是如何配置淘汰策略的？是使用默认的-LRU-策略，还是选择了其他策略？为什么？" class="headerlink" title="你的 Redis 实例是如何配置淘汰策略的？是使用默认的 LRU 策略，还是选择了其他策略？为什么？"></a>你的 Redis 实例是如何配置淘汰策略的？是使用默认的 LRU 策略，还是选择了其他策略？为什么？</h3><ul><li>对于这个系统来说，对于商品浏览和购物车来说是，是典型的热点数据频繁访问，LRU也就是最近最少使用访问淘汰策略，可以更好识别出热门商品数据，其他淘汰策略例如随机淘汰，适合访问频率比较均匀的。LFU虽然长期来看也能鉴别出热门数据，但是它的实现是要为每个key维护一个计数器以统计频率，可能会有开销。</li></ul><h3 id="热点-Key-问题解决方案"><a href="#热点-Key-问题解决方案" class="headerlink" title="热点 Key 问题解决方案"></a>热点 Key 问题解决方案</h3><ul><li>本地缓存，热点分片（分片算法），提前预热</li></ul><h3 id="Redis-大key会有什么问题？解决方案？"><a href="#Redis-大key会有什么问题？解决方案？" class="headerlink" title="Redis 大key会有什么问题？解决方案？"></a>Redis 大key会有什么问题？解决方案？</h3><ul><li>删除时单线程阻塞，持久化开销大：RDB AOF，网络IO,主从复制&#x2F;业务分片，按字段切分</li></ul><h3 id="订单模块"><a href="#订单模块" class="headerlink" title="订单模块"></a>订单模块</h3><h3 id="为什么使用Websock？"><a href="#为什么使用Websock？" class="headerlink" title="为什么使用Websock？"></a>为什么使用Websock？</h3><ul><li>首先相比于传统的HTTP请求（即使是短轮询或者长轮询），WebSocket提供更低的延迟，因为它本身就是建立了持久连接。其次它允许服务端主动向客户端推送消息。所以比较适合订餐系统中及时通知商家的场景。</li></ul><h3 id="WebSocket建立过程"><a href="#WebSocket建立过程" class="headerlink" title="WebSocket建立过程"></a>WebSocket建立过程</h3><ul><li>首先客户端向服务端发送一个Http请求，里面包含websocket的路径，upgrade字段设置为websocket。</li></ul><h3 id="如何保证商户在线时实时接收订单通知？若商户离线一段时间后重新上线，如何补发未处理的订单通知？"><a href="#如何保证商户在线时实时接收订单通知？若商户离线一段时间后重新上线，如何补发未处理的订单通知？" class="headerlink" title="如何保证商户在线时实时接收订单通知？若商户离线一段时间后重新上线，如何补发未处理的订单通知？"></a>如何保证商户在线时实时接收订单通知？若商户离线一段时间后重新上线，如何补发未处理的订单通知？</h3><ul><li>首先websock建立的是持久连接，并且使用了心跳机制，通过定期给客户端发送ping检测网络断连，断联后可以考虑使用指数退避算法避免频繁重连。如果商户离线，未处理的订单通知可以先放进消息队列，等到重连后客户端再重新消费。或者将未处理订单记录放进表中，商户上线后服务端查询订单未读通知，重新推送，再或者存入Redis Sorted Set（按时间排序），按时间取出消息重新推送。可以通过使用Nginx将根据商户id，将websock连接分配到不同服务实例。</li></ul><h3 id="WebSocket-性能有什么问题？WebSocket-服务如何横向扩展以支持10万级商户同时在线？"><a href="#WebSocket-性能有什么问题？WebSocket-服务如何横向扩展以支持10万级商户同时在线？" class="headerlink" title="WebSocket 性能有什么问题？WebSocket 服务如何横向扩展以支持10万级商户同时在线？"></a>WebSocket 性能有什么问题？WebSocket 服务如何横向扩展以支持10万级商户同时在线？</h3><ul><li>连接开销大，每个websocket连接都要占用服务器资源，并发量大的时候会造成压力。另外为了保持连接活跃并检测断线情况，通常需要定期发送心跳包，增加服务器负担。可以水平拓展多个websocket实例，使用反向代理服务器来分发 WebSocket 连接到多个后端服务器实例上，确保每个服务器处理的连接数在一个可接受的范围内。</li></ul><h3 id="如何防止网络抖动导致消息丢失？"><a href="#如何防止网络抖动导致消息丢失？" class="headerlink" title="如何防止网络抖动导致消息丢失？"></a>如何防止网络抖动导致消息丢失？</h3><ul><li>为每个消息生成唯一的ID，加入确认机制，如果没收到ack就重传。对于重要消息可以通过消息队列来传输，因为RocketMQ或kafka会提供可靠性保障。</li></ul><h3 id="为什么使用RocketMQ处理超时订单？"><a href="#为什么使用RocketMQ处理超时订单？" class="headerlink" title="为什么使用RocketMQ处理超时订单？"></a>为什么使用RocketMQ处理超时订单？</h3><ul><li>首先它支持延迟消息，生产者发送带延迟消息的订单，消息在指定时间之后才允许被消费。第二个就是对比直接使用数据库定时任务，去查询超时订单，可以减轻数据库压力，也就是说在高并发场景下效果更好。最后就是，它提供可靠的消息传递，通过重试机制，和死信队列保证最终一致性。当然使用Redis的Zset也可以实现延时队列的功能，但是每次需要轮询Zset触发处理到期任务，在数据量较大的适合性能产生瓶颈</li></ul><h3 id="超时订单技术选型"><a href="#超时订单技术选型" class="headerlink" title="超时订单技术选型"></a>超时订单技术选型</h3><ul><li>JAVA自带的DelayQueue优先队列，轮询队列头部，牺牲内存，不适合分布式处理。RocketMQ每个订单对应一条消息，且不会马上消费，给MQ带来很大的存储成本，不适合大量订单场景。定时任务扫描，周期性扫描数据库，随着订单量增大，数据库扫描压力增大。Redis的Zset的key为订单类型：score为时间戳+超时时间 memeber为订单号，高并发时候会获取同一个订单号。</li></ul><h3 id="使用RocketMQ延时队列处理超时订单，如果消息堆积（比如大量用户未支付），如何优化消费速度？"><a href="#使用RocketMQ延时队列处理超时订单，如果消息堆积（比如大量用户未支付），如何优化消费速度？" class="headerlink" title="使用RocketMQ延时队列处理超时订单，如果消息堆积（比如大量用户未支付），如何优化消费速度？"></a>使用RocketMQ延时队列处理超时订单，如果消息堆积（比如大量用户未支付），如何优化消费速度？</h3><ul><li>增加分区和消费者实例，调整消费线程数，批量消费减少IO</li></ul><h3 id="RocketMQ-只支持固定延迟级别（如1s-5s-10s），如何实现自定义延迟（如精确30分钟）？"><a href="#RocketMQ-只支持固定延迟级别（如1s-5s-10s），如何实现自定义延迟（如精确30分钟）？" class="headerlink" title="RocketMQ 只支持固定延迟级别（如1s, 5s, 10s），如何实现自定义延迟（如精确30分钟）？"></a>RocketMQ 只支持固定延迟级别（如1s, 5s, 10s），如何实现自定义延迟（如精确30分钟）？</h3><ul><li>第一种方案可以考虑，先用最合适的固定延迟级别，然后到期消费后，在消费端的逻辑做判断，如果没到时可以考虑先将消息存储，定时任务再触发去消费该消息，可能考虑消费者宕机消息丢失情况。第二种就在消费者端做判断，重新将消息发回RocketMQ，做延迟队列的组合</li></ul><h3 id="延时队列底层原理"><a href="#延时队列底层原理" class="headerlink" title="延时队列底层原理"></a>延时队列底层原理</h3><ul><li>根据延时级别将消息存储到内部定时Topic-&gt;时间轮算法：Broker启动，为每个延迟级别创建一个时间轮槽位，组成环形结构。每个槽位对应一个定时任务队列（消息）-&gt;消息进入定时主题时解析延时级别 计算存入目标槽位。broker启动后台线程池（驱动，消息到期检测，投递），每秒驱动时间轮遍历槽位消息重定向到目标Topic用于被消费</li></ul><h3 id="介绍一下项目的订单模型？"><a href="#介绍一下项目的订单模型？" class="headerlink" title="介绍一下项目的订单模型？"></a>介绍一下项目的订单模型？</h3><ul><li>首先订单表包括订单的基本信息订单ID，用户ID，总金额，订单状态，创建时间等。还有订单详情表，包括订单ID,收货地址，商品详情等。订单也关联实体有，例如用户，商品，库存，支付记录等。另外，订单从创建到结束包括多个状态，例如待支付，超时，已支付，已退款。</li></ul><h3 id="在大量订单情况下，有什么解决方案？"><a href="#在大量订单情况下，有什么解决方案？" class="headerlink" title="在大量订单情况下，有什么解决方案？"></a>在大量订单情况下，有什么解决方案？</h3><ul><li>在高并发请求的场景下，将数据库分片，分散请求的流量，分片键可以选择订单ID，用户ID或者按照创建时间。对于单表较大导致IO次数过多的情况下，考虑使用，按冷热字段分表例如订单基本信息表和详情表。或者根据订单id+用户id分表。分片算法在没有频繁变动分片数量时候可以用简单的哈希取模，或者维护一个映射表，在频繁变动的情况使用一致性哈希。</li></ul><h2 id="优惠券模块"><a href="#优惠券模块" class="headerlink" title="优惠券模块"></a>优惠券模块</h2><h3 id="讲讲优惠券抢券模块流程，和数据库表设置"><a href="#讲讲优惠券抢券模块流程，和数据库表设置" class="headerlink" title="讲讲优惠券抢券模块流程，和数据库表设置"></a>讲讲优惠券抢券模块流程，和数据库表设置</h3><ul><li>用户选择优惠券后下单，前端发送用户id和优惠券id，服务端进行幂等校验，使用Redis Set记录用户是否已经领取过优惠券（用户id和优惠券id），为了避免对数据库进行频繁写入造成性能瓶颈，扣除redis中的预热库存，使用RocktMQ进行异步批量提交，DB消费消息，更新用户优惠券表和优惠券库存表。</li><li>数据库表主要设计了三个表，一个是优惠券基本信息表，一个用户领取表，记录用户和优惠券的关系，一个是优惠券库存表记录优惠券库存</li></ul><h3 id="幂等性的实现方案"><a href="#幂等性的实现方案" class="headerlink" title="幂等性的实现方案"></a>幂等性的实现方案</h3><ul><li>set的key为券id，value为user id。命令SADD key member ，若成功添加证明无重复元素，返回1，若返回0则是有重复元素。</li><li>数据库层面：券id+user id作为唯一索引</li><li>用户进入订单确认页的时候生成一个token，并返回给客户端，客户端后续携带token，若存在token则第一次访问，执行服务后删除token</li></ul><h3 id="预扣库存成功后，若系统崩溃导致未写入数据库，如何恢复数据一致性？"><a href="#预扣库存成功后，若系统崩溃导致未写入数据库，如何恢复数据一致性？" class="headerlink" title="预扣库存成功后，若系统崩溃导致未写入数据库，如何恢复数据一致性？"></a>预扣库存成功后，若系统崩溃导致未写入数据库，如何恢复数据一致性？</h3><ul><li>利用RocketMQ持久化来保证系统崩溃了也能被恢复，消费失败时尝试重试策略，到达重试次数移入死信队列，进行人工处理。为了避免不重复消费，可以给消息添加唯一标识符，消费时判断，或者在数据库中添加字段标记是否成功处理。如果只要求最终一致性，可以启用一个定时任务，检查redis中库存和数据库实际库存一致，做补偿。</li><li>如果要回滚redis，首先可以使用数据库事务+redis事务的方法，先开启数据库事务如果数据库更新成功，再提交redis事务，如果redis扣除成功则提交事务否则回滚数据库事务。第二点就是redis写入成功意味着redis IO是正常的，可以将redis扣除库存的日志写入redis中，如果数据库更新成功就删除日志，否则根据日志回滚。</li></ul><h3 id="为什么选择Lua脚本而不是Redis事务（MULTI-EXEC）？"><a href="#为什么选择Lua脚本而不是Redis事务（MULTI-EXEC）？" class="headerlink" title="为什么选择Lua脚本而不是Redis事务（MULTI&#x2F;EXEC）？"></a>为什么选择Lua脚本而不是Redis事务（MULTI&#x2F;EXEC）？</h3><ul><li>Lua脚本将几条命令封装为一条原子命令执行，期间不可中断。如果使用地是Redis事务，主要用的是Multi&#x2F;exec，在exec之前其他客户端也可以发送命令，导致事务失败。第二就是减少了网络传输地次数，lua脚本是一条命令只要一次传输，redis事务要多次传输</li></ul><h3 id="“随机不重复轮询子库存”具体如何实现？如何避免不同用户请求集中在同一分片？如果某个分片库存提前耗尽，如何动态跳过该分片？"><a href="#“随机不重复轮询子库存”具体如何实现？如何避免不同用户请求集中在同一分片？如果某个分片库存提前耗尽，如何动态跳过该分片？" class="headerlink" title="“随机不重复轮询子库存”具体如何实现？如何避免不同用户请求集中在同一分片？如果某个分片库存提前耗尽，如何动态跳过该分片？"></a>“随机不重复轮询子库存”具体如何实现？如何避免不同用户请求集中在同一分片？如果某个分片库存提前耗尽，如何动态跳过该分片？</h3><ul><li>为了避免每次库存扣减都从第一个分片开始，造成单实例压力过大。维护一个分片ID的数组，和一个整型计数器。当有一个新的请求时，打乱分片id数组，使得每次请求分片按不同顺序分片扣除库存。可以用一个表记录每个分片剩余量，当剩余量为0时跳过。对比哈希取模去进行负载均衡的话，其扩展性比较差，在添加实例时，需要按新的数量取模，重新分布库存。</li></ul><h3 id="讲讲超卖产生的原因以及如何防止超卖？"><a href="#讲讲超卖产生的原因以及如何防止超卖？" class="headerlink" title="讲讲超卖产生的原因以及如何防止超卖？"></a>讲讲超卖产生的原因以及如何防止超卖？</h3><ul><li>超卖的主要原因是判断库存数量和扣除库存这两步不是原子的，当多个线程修改同一个优惠券库存时，由于同一个线程两次读数据不一致，导致库存多扣。有几种思路可以解决，如果是直接访问数据库去扣除库存，在单服务实例时，在业务层可以使用JVM锁例如Synchronized或者ReentransLock，如果是多服务实例时JVM锁失效，可以考虑使用redis分布式锁。在数据库层面，可以使用互斥锁，例如update语句或者for update，或者可以使用乐观锁的思想，通过CAS去保证并发安全。另外本项目采取的思路是，由于考虑到在抢券时并发激烈，先将库存预热到redis里，将判断库存和扣减库存两个命令写成lua脚本，利用redis命令执行是单线程的，将lua脚本作为一条命令放入redis执行，以保证判断库存和扣减库存是原子性的。 扣除完后将消息投递到消息队列中，数据库服务异步消费。这种方法既保证线程安全同时减轻数据库负担。</li></ul><h3 id="讲讲分布式锁"><a href="#讲讲分布式锁" class="headerlink" title="讲讲分布式锁"></a>讲讲分布式锁</h3><ul><li>使用setnx key value EX time 保证设置键和过期时间为原子性执行。防止线程A获取锁后实例挂了，没释放，此时又没设置过期时间。–如果在执行过程中，锁过期了，导致其他线程获得锁同时访问资源导致操作错误。所以使用锁续期，开启一个线程每个5秒查看锁是否存在，如果存在则继续续期为10s。当然如果，B已经获取了分布式锁，A有可能会误删锁，所以可以为每个线程上锁时生成一个唯一标识写入value中，在删除锁时先匹配标识，一致才可以删除，这个过程也需要原子性，所以也要通过lua脚本。—-在Redis主从一致环境下，如果主还未同步锁给从实例GG，此时会有AB线程都会获得锁的情况，导致资源被并行访问导致脏数据。可以使用RedLock算法，即线程锁时，需要将锁写入一定数量的从节点从保证上锁成功，以牺牲性能换取高可靠。</li></ul><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><h3 id="介绍一下工作流程"><a href="#介绍一下工作流程" class="headerlink" title="介绍一下工作流程"></a>介绍一下工作流程</h3><ul><li>服务端先将接口服务的全限定名和IP地址+端口注册到注册中心，客户端通过接口名调用服务，动态代理拦截接口方法，根据服务接口的全限定名获取方法地址，底层基于TCP，添加版本类型，包类型，序列化类型，和数据长度作为包头，定义实现了序列化接口的RPC发送类，里面定义了调用的方法名和参数类型以及具体参数。将RPC发送类序列化后，根据地址传输到服务端。服务端解析包头，根据数据长度获取包长，根据包类型和序列化方式，反序列化获取需要调用的方法名，以及所用的参数。调用服务获得结果后，按同样的方法返回给客户端。</li></ul><h3 id="为什么选择Netty而不是传统BIO或直接使用Java-NIO？如何优化Netty的线程模型以支撑10万级QPS？"><a href="#为什么选择Netty而不是传统BIO或直接使用Java-NIO？如何优化Netty的线程模型以支撑10万级QPS？" class="headerlink" title="为什么选择Netty而不是传统BIO或直接使用Java NIO？如何优化Netty的线程模型以支撑10万级QPS？"></a>为什么选择Netty而不是传统BIO或直接使用Java NIO？如何优化Netty的线程模型以支撑10万级QPS？</h3><ul><li>首先它相比于传统的BIO，在进行IO连接的时候，使用的是事件驱动的方法，只用更少的线程去支撑海量的连接，避免资源耗尽。另外对比用JAVA NIO的话，java NIO需要自己去创建seletor，注册事件，netty封装了底层这些细节，提供更高层次的API</li></ul><h3 id="介绍BIO-NIO-JAVA-NIO"><a href="#介绍BIO-NIO-JAVA-NIO" class="headerlink" title="介绍BIO NIO JAVA NIO"></a>介绍BIO NIO JAVA NIO</h3><ul><li>BIO就说BlockingIO，也就是阻塞IO，也就是说服务端创建一个线程处理客户端的读写连接时，当数据还没到来，线程会被阻塞。随着连接数增多，也就是工作线程增多，大量线程的阻塞导致占用大量系统资源。而JAVA NIO则是New IO，本质上是使用了IO多路复用的方法处理多个连接。多路则是指多个连接，复用则是指用一个或者少量的线程去处理这些连接。具体来说，IO多路复用用三种机制，分别是（select，poll和epoll），对于select来说，对每个连接都维护一个文件描述符fd，将fd的事件例如连接、读、写就绪注册到select上，执行select的时候阻塞等待fd上事件的到来，内核态轮询fd事件到来时将修改标志位并返回fd的集合，用户态轮询所有fd，查询事件发生的fd进行处理，以实现单个线程监听多个连接的事件实现多路复用。select有个弊端就是监控的fd有限，poll则是通过动态数组存储fd以扩展可用的fd数量。而epoll则是将fd构成了一棵红黑树，当有事件来临时则，通过触发的方式将fd加入到一个双向链表中，用户只要进行一次系统调用则可获取触发事件的fd列表，不需要对所有fd进行轮询。</li></ul><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><ul><li>处理一次IO为三部分：连接处理（注册事件–accept）、IO读写（Handle）、业务处理（Handle）—-单Reactor是指，连接、IO处理，业务处理都用同一个线程—一旦阻塞不能处理后续节点连接—-6.0之前redis是这个模型。<strong>多线程 Reactor 模型</strong>：主线程处理连接，以及读写，子线程池（此时非阻塞体现在如果channel无读事件，会立刻返回以实现线程池的线程复用）处理业务，发挥多核优势，但IO读写还是用一个线程导致其他读写阻塞。主从Reactor多线程模型是指，连接和IO分别用不同线程处理，主为处理连接注册事件（accept），（线程池）创建线程处理IO读写，业务处理时用多个线程（线程池）。</li></ul><h3 id="Netty整体工作机制"><a href="#Netty整体工作机制" class="headerlink" title="Netty整体工作机制"></a>Netty整体工作机制</h3><ul><li>网络通信层 客户端服务端启动，监听指定端口—事件调度器主从多线程模型 Boss，Worker—服务编排层，即work处理使用处理链（业务是否多线程自己处理）</li></ul><h3 id="Netty性能好在哪里？"><a href="#Netty性能好在哪里？" class="headerlink" title="Netty性能好在哪里？"></a>Netty性能好在哪里？</h3><ul><li>IO连接使用多Reactor模型、使用零拷贝机制，即通过api直接读写直接内存，避免拷贝进堆内存，提供多种序列化方式，包括性能告得protobuf</li></ul><h3 id="你是如何解决粘包拆包的？Netty是如何实现的"><a href="#你是如何解决粘包拆包的？Netty是如何实现的" class="headerlink" title="你是如何解决粘包拆包的？Netty是如何实现的"></a>你是如何解决粘包拆包的？Netty是如何实现的</h3><ul><li>因为我底层用的是TCP，TCP是基于字节流的，而且保证有序到达。所以我通过在包头前面添加一个包长字段，解析出长度后，每次获取包长的字节数，以解决粘包拆包问题。Netty是封装了3种解决粘包的方案，一种是固定消息长度，每次收发固定长度的消息。第二种是以特定分隔符结尾，第三种应该是跟我这个思想一样，标明固定长度。</li></ul><h3 id="为什么需要支持多种序列化方式？讲讲序列化和反序列化？如何设计一个可扩展的序列化框架？"><a href="#为什么需要支持多种序列化方式？讲讲序列化和反序列化？如何设计一个可扩展的序列化框架？" class="headerlink" title="为什么需要支持多种序列化方式？讲讲序列化和反序列化？如何设计一个可扩展的序列化框架？"></a>为什么需要支持多种序列化方式？讲讲序列化和反序列化？如何设计一个可扩展的序列化框架？</h3><ul><li>一个是兼容不同的编程语言和平台，二是根据需求来指定序列化方式，例如JSON便于阅读，适用于开发阶段。Protobuf是基于二进制的，性能更好。首先在抽象层可以定义一个通用的接口，包括序列化方法和反序列化方法。其次可以使用工厂模式来获取序列化编码器，注册的时候直接在工厂内部将序列化代码和编码器放入一个Map中，每次使用序列化代码调用工厂即可。</li></ul><h3 id="Protobuf和JSON的性能差异有多大？介绍一下Protobuf"><a href="#Protobuf和JSON的性能差异有多大？介绍一下Protobuf" class="headerlink" title="Protobuf和JSON的性能差异有多大？介绍一下Protobuf"></a>Protobuf和JSON的性能差异有多大？介绍一下Protobuf</h3><ul><li>Protobuf使用二进制格式而不是文本格式，减少了传输的体积，大概快3-10倍。通过定义<code>.proto</code>文件来描述数据结构，Protobuf能够自动生成对应多种编程语言的源代码。在反序列化的时候，根据<code>.proto</code>文件指定的结构还原对象。</li></ul><h3 id="为什么选择JDK动态代理而非CGLIB？"><a href="#为什么选择JDK动态代理而非CGLIB？" class="headerlink" title="为什么选择JDK动态代理而非CGLIB？"></a>为什么选择JDK动态代理而非CGLIB？</h3><ul><li>客户端使用RPC调用服务的时候，是调用了服务接口，而JDK动态代理适用实现接口的类，在这个场景下性能比CGLIB好，因为前者通过反射调用目标方法开销小，CGLIB通过字节码操作技术生成目标类的一个子类来实现代理功能。</li></ul><h3 id="如何保证服务注册的实时性？Nacos如何避免服务列表的脏读？对比Zookeeper，Nacos的优劣是什么？"><a href="#如何保证服务注册的实时性？Nacos如何避免服务列表的脏读？对比Zookeeper，Nacos的优劣是什么？" class="headerlink" title="如何保证服务注册的实时性？Nacos如何避免服务列表的脏读？对比Zookeeper，Nacos的优劣是什么？"></a>如何保证服务注册的实时性？Nacos如何避免服务列表的脏读？对比Zookeeper，Nacos的优劣是什么？</h3><ul><li>主要用两点，一个是心跳机制：客户端定期向服务注册中心发送心跳包，以表明其仍然存活。如果服务中心一段时间没收到，则认为服务不可用，从列表删除。第二个是重试机制，在服务调用失败的时候，能够快速选择其他好的服务或者重试。Nacos内部实现了高效的缓存一致性协议，确保客户端缓存和服务端的数据一致性。另外Nacos主动推送自己的最新服务给客户端。Zookeeper强调强一致性，适用强一致性场景，牺牲了性能。Nacos更专注于服务注册，提供合适的API，例如服务注册，健康检查等功能。</li></ul><h3 id="如何设计一个注册中心？"><a href="#如何设计一个注册中心？" class="headerlink" title="如何设计一个注册中心？"></a>如何设计一个注册中心？</h3><ul><li>服务注册与发现（Map），健康检查(心跳机制)，负载均衡，高可用（集群，一致性算法），可拓展</li></ul><h3 id="如果某个服务节点响应时间突然变长，如何动态调整权重？"><a href="#如果某个服务节点响应时间突然变长，如何动态调整权重？" class="headerlink" title="如果某个服务节点响应时间突然变长，如何动态调整权重？"></a>如果某个服务节点响应时间突然变长，如何动态调整权重？</h3><ul><li>根据ping的响应时间调整权重。</li></ul><h3 id="讲讲Nacos的Raft"><a href="#讲讲Nacos的Raft" class="headerlink" title="讲讲Nacos的Raft"></a>讲讲Nacos的Raft</h3><ul><li>raft有三种角色，一个是Leader，follower和Condidate，首先是选举，Leader宕机后或到达任期之后，follower按一定随机时间生成Condiate，通过请求投票，当获取超半数之后升级为leader。主从是读写分离，为了保证一致性，写操作统一写入leader，leader同步日志到follower，超过一定数量后给客户端响应。</li></ul><h3 id="如何实现RPC调用超时和重试机制？"><a href="#如何实现RPC调用超时和重试机制？" class="headerlink" title="如何实现RPC调用超时和重试机制？"></a>如何实现RPC调用超时和重试机制？</h3><ul><li>调用时设计超时时间，超时指数退避重试。幂等性，唯一标识符。</li></ul><h3 id="如果有个系统要应用到你的RPC框架，需要做哪些事情？"><a href="#如果有个系统要应用到你的RPC框架，需要做哪些事情？" class="headerlink" title="如果有个系统要应用到你的RPC框架，需要做哪些事情？"></a>如果有个系统要应用到你的RPC框架，需要做哪些事情？</h3><h3 id="性能瓶颈在哪里？"><a href="#性能瓶颈在哪里？" class="headerlink" title="性能瓶颈在哪里？"></a>性能瓶颈在哪里？</h3><ul><li>首先是网络IO–可以通过使用合适的序列化方式例如protobuf减少数据量，或者批量调用减少网络次数。第二个是序列化，选用高效的序列化方法也很重要。另外在客户端，当频繁调用服务时意味着要频繁到注册中心请求服务成为性能瓶颈，可以使用缓存来提升性能。第三点是服务端处理大量RPC请求时也可能成为瓶颈，一个是服务端处理业务时使用线程池处理，第二点可以使用负载均衡。</li></ul><h1 id="问题排查及解决方案"><a href="#问题排查及解决方案" class="headerlink" title="问题排查及解决方案"></a>问题排查及解决方案</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p><strong>定位</strong></p><ul><li>开启慢日志</li><li>Explain（模拟优化器执行）<ul><li>key：使用的索引</li><li>type: system（表中只有一行数据) ，const(只有一行索引匹配)，eq_ref（主键或唯一索引的等值连接），ref（非主键非唯一索引），range（索引范围），index（全表索引），all（全表扫描）</li></ul></li></ul><p><strong>优化角度</strong></p><ul><li>数据量<ul><li>数据量越大IO次数越多</li></ul></li><li>取数据方式<ul><li>磁盘还是缓存</li><li>是否能结合谓词条件命中全局索引</li></ul></li><li>数据加工方式<ul><li>排序、子查询、聚合、关联等取到临时表中，对数据加工</li><li>合适的join方式</li></ul></li></ul><p><strong>优化思路</strong></p><ul><li><p>减少数据扫描</p><ul><li><p>数据分页优化</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">select * from table_demo <span class="type">where</span> <span class="variable">type</span> <span class="operator">=</span> ?  limit A,B; </span><br><span class="line">---limit+offset，每次查询B条数据都要扫描跳过前A-<span class="number">1</span>条数据</span><br><span class="line"></span><br><span class="line">lastId = <span class="number">0</span> or <span class="title function_">min</span><span class="params">(id)</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">select * from table_demo <span class="type">where</span> <span class="variable">type</span> <span class="operator">=</span> ? and id &gt;&#123;#lastId&#125;  limit ?;</span><br><span class="line">lastId = max(id)</span><br><span class="line">&#125; <span class="keyword">while</span> (isNotEmpty)</span><br><span class="line">---记录偏移ID，新页直接定位到上一次的<span class="type">ID</span></span><br><span class="line"></span><br><span class="line"><span class="variable">minId</span> <span class="operator">=</span> min(id) maxId = max(id)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> minId; i&lt;= maxId; i+=pageSize)&#123;</span><br><span class="line">select * from table_demo <span class="type">where</span> <span class="variable">type</span> <span class="operator">=</span> ? and id between i and i+ pageSize;</span><br><span class="line">&#125;</span><br><span class="line">--- between and，分段查询 虽然可以减少扫描遍历情况，但是不适用于查询的键分布不均的情况，多了一些不必要的查询</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Groud By分组优化</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select job , avg(sal) from table_demo <span class="type">where</span>  <span class="variable">job</span> <span class="operator">=</span> ‘manager<span class="string">&#x27; group by job</span></span><br><span class="line"><span class="string">先过滤后分组</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>范围查询</p><blockquote><p>单键索引: 查询到主键索引时，先排序后回表Multi Range Read(MRR)），可以减少IO次数（一个页中有多个连续行）</p><p>联合索引：Mysql5.6+，等式放范围查询的右边会通过索引下推过滤回表的主键数，当然：等值最左匹配才是优解</p></blockquote></li><li><p>Order By</p><blockquote><p>索引覆盖排序 ：order前建立索引时已经排好序</p></blockquote></li><li><p>业务划分</p><blockquote><p>date &#x3D; now; minDate &#x3D; now - 10 days<br>while(date &gt; minDate) {<br>select * from order where order_date&#x3D;{<em>#date} and status&#x3D;’S’ and update_time &lt; now-5min limit 500</em>  date &#x3D; data + 1}</p><p>对比: 快在可以对order_date索引（status如果太均匀失效了），避免一次性读太大量的表进内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from order where status=<span class="string">&#x27;S&#x27;</span> and update_time &lt; now-5min  limit <span class="number">500</span></span><br></pre></td></tr></table></figure></blockquote></li></ul></li><li><p>数据库结构优化</p><ul><li>范式优化：消除冗余</li><li>反范式优化：适当加冗余-避免join操作（有时候不满足第三范式也能提升速度）</li><li>按物理结构拆分表，避免全表扫描（例如按日期）</li></ul></li><li><p>SQL语句优化</p><ul><li>区分 in 和 exists（in先执行子查询后逐行判断-适合内表小的情况（子查询返回的结果少），后者遍历外表逐行执行子查询，遇到匹配项停止减少扫描。因为每次子查询需要开销，在少量数据的时候还是用in）</li><li>尽量避免使用子查询-&gt;join&#x2F;反范式优化</li></ul></li><li><p>大表优化</p><ul><li>分库分表</li><li>读写分离（主从复制）</li><li>定期归档（历史数据移除，减少主表大小）</li></ul></li></ul><h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><h2 id="接口超时"><a href="#接口超时" class="headerlink" title="接口超时"></a>接口超时</h2><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><h1 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h1><h2 id="高频统计类"><a href="#高频统计类" class="headerlink" title="高频统计类"></a>高频统计类</h2><h3 id="TOP-K问题-次数出现最多元素"><a href="#TOP-K问题-次数出现最多元素" class="headerlink" title="TOP K问题 &#x2F; 次数出现最多元素"></a>TOP K问题 &#x2F; 次数出现最多元素</h3><ul><li>方法一：首先将大文件转成小文件：具体来说，可用使用Hash元素取模M分成M个小文件，目的是将相同的元素放在同一文件中。然后，将小文件加载进内存中用HashMap记录元素出现次数，遍历HashMap构造有100个节点的小根堆。接下来就是遍历所有文件，重复HashMap记录次数，然后将元素次数和小根堆堆顶元素比较，若大于其则交换重构堆。—-该方法不足之处在于，若大量元素都相似，容易导致生成的小文件过大，大于内存。</li><li>方法二：首先先对文件里的字符串排序，保证相同的字符串连续。具体来说：大文件顺序按固定大小切分为子文件，子文件分别进内存后对字符串排序。使用多路归并排序，即初始化M个结点的最小堆，每个结点代表各子文件输入流的第一个元素，从最小堆中取出最小元素，并将其写入输出文件，同时堆顶元素对应文件读入下一个元素放入堆中，重复过程直至大文件有序。 然后，维护一个K结点的最小堆，节点为元素对应出现次数，遇到新元素则统计完元素数量后元堆顶元素比较，若大于则取出堆顶元素并加入。</li></ul><h2 id="存在性判断与去重"><a href="#存在性判断与去重" class="headerlink" title="存在性判断与去重"></a>存在性判断与去重</h2><h3 id="判断元素存在"><a href="#判断元素存在" class="headerlink" title="判断元素存在"></a>判断元素存在</h3><ul><li>方法一：排序后，遍历</li><li>方法二：位图法：40亿个整数可以用2的32次方表示，也就是512MB。初始化个数组位为0，若数字存在对应位置置1，遍历位图。</li></ul><h3 id="找出不重复元素"><a href="#找出不重复元素" class="headerlink" title="找出不重复元素"></a>找出不重复元素</h3><ul><li>方法一：排序后，遍历</li><li>方法二：位图法：40亿个整数可以用2的32次方表示，2bit作为信息为 00为不存在 01为1个元素 10为重复元素，2*512MB&#x3D;1GB</li></ul><h2 id="交集与合并的问题"><a href="#交集与合并的问题" class="headerlink" title="交集与合并的问题"></a>交集与合并的问题</h2><h3 id="大文件交集"><a href="#大文件交集" class="headerlink" title="大文件交集"></a>大文件交集</h3><ul><li>两个大文件用相同的哈希函数和取模基数，保证相同的URL都在相同序号的子文件中。只要比较子文件的内容即可</li></ul><h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><ul><li>从最高位开始划分数据，进而到次高进制，重复过程直到定位到中位数所在区间并且满足内存空间大小</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;餐饮订购系统&quot;&gt;&lt;a href=&quot;#餐饮订购系统&quot; class=&quot;headerlink&quot; title=&quot;餐饮订购系统&quot;&gt;&lt;/a&gt;餐饮订购系统&lt;/h1&gt;&lt;h3 id=&quot;介绍一下项目？里面有什么亮点难点？&quot;&gt;&lt;a href=&quot;#介绍一下项目？里面有什么亮点难点？&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股问答</title>
    <link href="https://senwh.github.io/2025/04/29/%E5%85%AB%E8%82%A1%E9%97%AE%E7%AD%94/"/>
    <id>https://senwh.github.io/2025/04/29/%E5%85%AB%E8%82%A1%E9%97%AE%E7%AD%94/</id>
    <published>2025-04-29T12:39:37.000Z</published>
    <updated>2025-05-30T08:16:13.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><ul><li>主要体现在解决问题的方式不同，面向过程以过程，或者说是步骤为中心去解决问题，具体来说可以将一个线性的任务分割为一个个子过程，优点是结构简单，对比面向对象的话少了实例建立开销，但是涉及到复杂的编程时较困难。对于面向对象思想来说以对象实体为核心，将问题中涉及到的实体抽象出来，赋予属性和方法。通过多个实体协作完成任务，在需要修改时通常只要对某个实体属性或者方法修改，更易于拓展。</li></ul><h3 id="抽象类和接口的区别，使用场景？"><a href="#抽象类和接口的区别，使用场景？" class="headerlink" title="抽象类和接口的区别，使用场景？"></a>抽象类和接口的区别，使用场景？</h3><ul><li>首先从设计思想上来说，抽象类就是将一组有相似方法或功能的类里的方法或属性抽象出来封装为抽象类，目的就是相当于提供了一个类模板，包含共同的方法和状态，从而依据该模板生成子类，体现一种垂直继承，类只能继承一个抽象类。接口则是对不同类的相似方法进行抽象，提供一组行为规范，体现一种水平实现的方式，一个类可以实现多个接口，以获得多种方法功能。从结构差异来说，由于抽象类生来就是为了被继承，所以它的方法都是public和protect，另外抽象类里的抽象方法都需要被非抽象类的子类实现，也就是说严格按照类模板生成子类。对于接口来说，它的方法都是java8之前都是抽象方法，也就是说实现接口时，抽象方法都需要被实现。</li></ul><h3 id="聊聊JAVA的反射"><a href="#聊聊JAVA的反射" class="headerlink" title="聊聊JAVA的反射"></a>聊聊JAVA的反射</h3><ul><li>首先反射的反对应的就是正，所谓正其实就是编译前就确定了要创建的对象类型，通过new的方式直接创建，那这种方法其实代码耦合度比较大，每次修改对象类型都要通过改源代码。反射其实就是提供了一种机制，程序在运行时才确定具体类型，也就是说可以通过传参的方式确定某个具体类，降低了耦合性。所谓的反其实就说通过局部信息获取类的全局信息，通过全限定名，即可或者对应对象的构造函数。它的底层原理其实就说每个类维护一个class对象，里面包含类所有的信息，包括属性，方法等。通过找到class对象，即可调用对应方法，访问属性。当然这种方法缺点也很明显， 一个是性能差点，因为每次调用方法要去匹配对应的class对象和并获取方法，另外能访问状态，如果是私有状态，就意味破坏了类的封装性。至于应用场景的话，在动态代理时就用到了反射，它的原理就是通过class对象实例化出一个代理类，反射调用执行对应方法。</li></ul><h3 id="聊聊JAVA泛型"><a href="#聊聊JAVA泛型" class="headerlink" title="聊聊JAVA泛型"></a>聊聊JAVA泛型</h3><ul><li>泛型本质就是参数化类型，也就是说在使用时才指定具体的类型，例如在一些集合中用到。这样有几个好处，一个是编译时就能通过类型检查，是否每个集合元素都是合理的，而不用等到运行才出错。第二个就是泛型其实也是一种多态的体现，底层代码只需要用一个参数来表示传入类型，避免冗余代码。</li></ul><h3 id="JAVA中的异常"><a href="#JAVA中的异常" class="headerlink" title="JAVA中的异常"></a>JAVA中的异常</h3><ul><li>异常体系的根是Throwable继承Object，他有两个分支，分别是Error和Exception，Error通常是内存溢出，栈溢出，比较严重的错误，程序无法处理。而Exception包括运行时异常和非运行时异常，前者通常是运行中出现的错误数组越界、空指针，不需要实现抛出异常，因为代码逻辑应该在代码审查阶段应该发现，后者则是IO，或则sql语句这类的异常，需要显示抛出，因为通常由于外部环境影响，在设计代码前要通过异常机制处理可能出现的问题。throw将方法体内部主动扔出异常，包括运行和非运行。throws则是在方法名声明非运行异常。</li></ul><h3 id="Java中的集合"><a href="#Java中的集合" class="headerlink" title="Java中的集合"></a>Java中的集合</h3><ul><li>Java集合有两个父接口，Collection下的子接口包括list（实现类有ArrayList，LinkedList，Vector），set（HashSet,TreeSet），queue(包括优先级队列，双向队列等)，Map的实现类有HashMap，线程安全的ConcurrentHashMap，HashTable。按顺序的有基于红黑树的TreeMap，LinkedHashMap</li></ul><h3 id="Java中String，StringBuffer，StringBuilder"><a href="#Java中String，StringBuffer，StringBuilder" class="headerlink" title="Java中String，StringBuffer，StringBuilder"></a>Java中String，StringBuffer，StringBuilder</h3><ul><li>String底层是一个final类型的char数组，保证了String的不可变性。利用String的不可变性，其常被用于做Hash的Key值，另外JVM在堆中维护的字符串常量池页要求不可变性，当然不可变性页也意味它是线程安全的。StringBuilder提供了字符串拼接的方法，底层是通过创建新的数组，将旧的数组复制过去，但它没控制并发安全，所以是不安全的。StringBuffer也是提供了字符串的拼接方法，但它是线程安全的。底层是通过syncronized加在append等方法上，保证线程安全。</li></ul><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="讲讲线程池的工作原理？"><a href="#讲讲线程池的工作原理？" class="headerlink" title="讲讲线程池的工作原理？"></a>讲讲线程池的工作原理？</h3><ul><li>首先判断当前线程是否小于核心线程数，若小于则创建新线程执行任务。若大于核心线程数则将任务放入阻塞队列，此时阻塞队列已满，且当前线程数小于总线程数，则创建新线程执行任务。如果已达最大线程数，则对新任务执行拒绝策略。当线程执行完首次任务后，阻塞从队列中取出任务或者判断是否到存活时间结束线程。<ul><li>这里需要注意一个点：新线程提交时，先考虑创建线程而不是判断核心线程有没有空闲（判断线程状态需要加锁开销），未到核心线程先创建新线程</li></ul></li></ul><h3 id="核心线程数在不执行任务时，是如何判断有新任务需要执行？"><a href="#核心线程数在不执行任务时，是如何判断有新任务需要执行？" class="headerlink" title="核心线程数在不执行任务时，是如何判断有新任务需要执行？"></a>核心线程数在不执行任务时，是如何判断有新任务需要执行？</h3><ul><li>线程初次提交任务（firsetTask）时直接执行，执行完在while里获取阻塞队列的任务task &#x3D; getTask()，如果线程小于核心线程数take()，线程阻塞等待任务，非核心线程数poll（time，unit）阻塞time存活时间返回null，退出循环，线程结束</li></ul><h3 id="如何设计一个类似线程池的阻塞队列？"><a href="#如何设计一个类似线程池的阻塞队列？" class="headerlink" title="如何设计一个类似线程池的阻塞队列？"></a>如何设计一个类似线程池的阻塞队列？</h3><ul><li>数据结构：有界队列考虑数组固定容量防止内存溢出，适合流量控制的场景，写入取出用同一把锁性能差。无界队列考虑链表，适合任务数量可预计的场景，有内存溢出的风险，写入取出用同不同锁。优先级队列：堆的结构。SynchronousQueue，直接提交，适合高吞吐场景</li><li>线程安全：take()-&gt;ReentrantLock上锁+condition.await()等待时释放锁，此时while在循环判断队空，当队存在元素signal唤醒线程。ReentransLock配合condition使用，当执行await时候，线程进入等待状态加入Condition等待队列，signal释放锁后，Condition里的线程重新加入AQS等待队列</li></ul><h3 id="源码细节"><a href="#源码细节" class="headerlink" title="源码细节"></a>源码细节</h3><ul><li>execute（command）-&gt;ctl变量（高三位表示运行池状态，低29位表示当前线程数）-CAS线程数量添加工作线程addworker-&gt;创建线程addworker t.start&#x2F;加入队列workQueue.offer(command)&#x2F;addworker&#x2F;reject-&gt;work.run()-&gt;while(task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null)-&gt;在getTask（）中，take()方法阻塞等待队列进新线程，若大于核心线程且超时poll（time，unit），ctl–</li><li>关闭Shundown interruptIdleWorkers，关闭空闲出来的线程；Shundownnow interruptWorkers，黑猫白猫统统关掉</li><li>拒绝策略：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbortPolicy :throw new RejectedExecutionException 抛异常</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiscardPolicy:&#123;&#125; 什么也不做（丢弃）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiscardOldestPolicy: e.getQueue().poll(); e.execute(r);  拿oldest（头节点）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CallerRunsPolicy: r.run();  传入的线程为this，提交execute任务的线程执行该任务，可能会导致后续提交被阻塞</span><br></pre></td></tr></table></figure><h2 id="Volatile-Synchronized-ReentransLock"><a href="#Volatile-Synchronized-ReentransLock" class="headerlink" title="Volatile Synchronized ReentransLock"></a>Volatile Synchronized ReentransLock</h2><h3 id="使用场景区别？"><a href="#使用场景区别？" class="headerlink" title="使用场景区别？"></a>使用场景区别？</h3><ul><li>Volatile 修饰单个变量，保证在多线程环境下的可见性和防止编译器对该<strong>变量</strong>进行重排序（不提供原子性保障），没有获取锁释放锁的操作，轻量级—常用在线程&#x2F;状态标志位</li><li>Synchronized 用于方法或者代码块同步，不需要显示获得锁&#x2F;释放锁，线程获得锁失败后被阻塞后，不能被中断，因为synchronized实现线程阻塞是在操作系统级别，不会显示的去检查锁中断标志位。第三在性能方面，一个它是一种非公平锁，在一定程度上减少线程等待唤醒的开销。同时引入了锁升级的过程，根据锁的竞争程度，去升级锁，尽可能减少锁的开销。本意是尽可能简化上锁释放锁的操作。</li><li>ReentransLock 提供更细粒度的并发控制，也就是说提供更多的api操作。 首先它需要显示获得锁和释放锁，其次它可以通过检查线程中断标志位，使得等待获取锁的线程可以被中断。第三，它可以实现公平锁或者非公平锁，另外它也提供了一种超时等待的机制，通过CAS去获取锁，获取锁失败则取消等待，避免线程阻塞引发性能开销。</li></ul><h3 id="在多线程环境下，Volatile-如何保证变量的可见性和禁止重排序？为什么它不能保证原子性？结合内存屏障和-JMM（Java内存模型）-解释其原理。"><a href="#在多线程环境下，Volatile-如何保证变量的可见性和禁止重排序？为什么它不能保证原子性？结合内存屏障和-JMM（Java内存模型）-解释其原理。" class="headerlink" title="在多线程环境下，Volatile 如何保证变量的可见性和禁止重排序？为什么它不能保证原子性？结合内存屏障和 JMM（Java内存模型） 解释其原理。"></a>在多线程环境下，Volatile 如何保证变量的可见性和禁止重排序？为什么它不能保证原子性？结合<strong>内存屏障</strong>和 <strong>JMM（Java内存模型）</strong> 解释其原理。</h3><ul><li>首先在Java的内存模型中，为了提升性能，每个线程拥有自己独立的本地缓存，还有共享内存。当然，引入了缓存之后无可避免的就会出现一致性的问题。那么Volatitle变量其实是一种轻量级的方式在一定程度上解决了一致性问题。具体来说，当使用Volatitle修饰一个变量的时候，后续在对这个变量进行读写操作的时候，会在指令执行前插入一个内存屏障，它可以使变量操作前的写操作的执行结果直接写入共享内存，对变量的读操作总是越过缓存去读共享内存中的数据，这样就保证了数据的可见性。除此之外，JVM虽然可以保证变量间相互有直接依赖关系的变量执行过程中的有序性，但是对于无直接依赖关系的变量可以会执行指令重排序，在多线程的环境下可能会出现并发问题。那么内存屏障同时也可以保证屏障前后的指令不会被编译器重排序导致出现预期以外的结果。</li></ul><h3 id="volatile-如何防止指令重排序？举个单例模式中双重检查锁失效的例子。"><a href="#volatile-如何防止指令重排序？举个单例模式中双重检查锁失效的例子。" class="headerlink" title="volatile 如何防止指令重排序？举个单例模式中双重检查锁失效的例子。"></a>volatile 如何防止指令重排序？举个单例模式中双重检查锁失效的例子。</h3><p>对象创建包括：分配内存空间、对象初始化（分配零值-插入写屏障，禁止重排序），引用指向对象（给instance赋值-写操作-立刻刷新道内存），如果后两步重排序，会导致引用访问一个未初始化的对象导致出错</p><h3 id="公平锁和非公平锁是什么？"><a href="#公平锁和非公平锁是什么？" class="headerlink" title="公平锁和非公平锁是什么？"></a>公平锁和非公平锁是什么？</h3><ul><li>公平锁是指线程获取互斥锁遵循先来先服务的原则，ReentroLock可以实现这样的功能，使用一个队列存储等待的线程，每次锁空闲时总是唤醒等待时间最长的线程获取锁，而新来的任务会追加到队列尾部。–要求线程执行顺序（银行业务），当然它其实就是牺牲了性能，避免线程饥饿的情况，因为每次都需要对线程进行阻塞和唤醒。非公平锁是指任何线程都可以尝试获得锁，例如Synchroniezd和ReentroLock都可以实现非公平锁，由于新来的任务可以直接尝试获得锁，减少线程等待&#x2F;唤醒的开销，可能会引起线程饥饿。—吞吐量优先的场景</li></ul><h3 id="可重入锁和不可重入锁？"><a href="#可重入锁和不可重入锁？" class="headerlink" title="可重入锁和不可重入锁？"></a>可重入锁和不可重入锁？</h3><ul><li>可重入锁是指允许同一个线程多次获得同一把锁而不导致死锁。在递归调用的时候可能会重复访问同一把锁，使用可重复锁避免死锁情况发生。</li></ul><h3 id="Reentrantlock如何实现公平锁的？"><a href="#Reentrantlock如何实现公平锁的？" class="headerlink" title="Reentrantlock如何实现公平锁的？"></a>Reentrantlock如何实现公平锁的？</h3><ul><li>使用了一个等待队列来维护管理等待获得锁的线程，如果队列无线程则新来的线程可以直接尝试获得锁，如果队列里有线程，只允许队头的线程获得锁，新来的线程加到队列尾部。</li></ul><h3 id="在-JDK-1-6-之后引入了锁升级机制，从偏向锁到轻量级锁再到重量级锁。请详细说明每个阶段的触发条件，以及为什么需要这种设计？结合对象头中的-Mark-Word-结构说明。"><a href="#在-JDK-1-6-之后引入了锁升级机制，从偏向锁到轻量级锁再到重量级锁。请详细说明每个阶段的触发条件，以及为什么需要这种设计？结合对象头中的-Mark-Word-结构说明。" class="headerlink" title="在 JDK 1.6 之后引入了锁升级机制，从偏向锁到轻量级锁再到重量级锁。请详细说明每个阶段的触发条件，以及为什么需要这种设计？结合对象头中的 Mark Word 结构说明。"></a>在 JDK 1.6 之后引入了锁升级机制，从偏向锁到轻量级锁再到重量级锁。请详细说明每个阶段的触发条件，以及为什么需要这种设计？结合对象头中的 <strong>Mark Word</strong> 结构说明。</h3><ul><li>允许锁从偏向锁开始，按照锁的竞争情况将锁升级成轻量级锁和重量锁。旨在减少线程获取锁的开销同时保证在高并发情况下的线程安全。</li><li>首先一个线程首次访问同步块获得锁的时候，锁如果还处于空闲状态，会在对象头中的MarkWord记录该线程id，并且标记未偏向锁，如果期间没有其他线程访问锁，下一次该线程获得锁的时候，线程id匹配了，不用重新通过CAS取获得锁。当一个线程发现锁已经被其他线程持有并且是偏向锁时，偏向锁撤销并升级为轻量级锁，在栈帧中创建锁记录，将对象头的MarkWord放到锁记录中（恢复时放回），然后CAS尝试将对象头的MarkWord替换成指向当前线程的指针，若成功则意味获得锁。线程通过自旋CAS获得锁，如果在一定次数之内如果没获取锁成功，意味着锁竞争激烈，膨胀为重量锁。将MarkWord指向对象的Monitor。当一个线程尝试获取重量级锁但没能成功的时候，将线程放入等待队列，被操作系统挂起，当持有锁线程释放锁是，队列中的线程会被唤醒去竞争锁。</li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="底层原理？ThreadLocal-如何实现线程间数据隔离？结合-Thread、ThreadLocalMap-和-Entry-的结构说明其存储机制。为什么-Entry-的-key-使用弱引用（WeakReference）？"><a href="#底层原理？ThreadLocal-如何实现线程间数据隔离？结合-Thread、ThreadLocalMap-和-Entry-的结构说明其存储机制。为什么-Entry-的-key-使用弱引用（WeakReference）？" class="headerlink" title="底层原理？ThreadLocal 如何实现线程间数据隔离？结合 Thread、ThreadLocalMap 和 Entry 的结构说明其存储机制。为什么 Entry 的 key 使用弱引用（WeakReference）？"></a>底层原理？ThreadLocal 如何实现线程间数据隔离？结合 Thread、ThreadLocalMap 和 Entry 的结构说明其存储机制。为什么 Entry 的 key 使用弱引用（WeakReference）？</h3><ul><li>允许每个线程创建维护独立的变量副本，底层原理是每个线程维护一个ThreadLocalMap，key为ThreadLocal，value为Entry，Entry存放的是对key的一个弱引用以及具体存放的Object value值。这样设计是为了保证，在不需要引用某个ThreadLocal时，由于线程池复用了线程，线程仍持有对ThreadLocalMap的引用，也就是继续持有对key的引用，导致内存泄漏。所以map持有的是对key的弱引用，当没有其他强引用，即可被回收。</li><li>直接用key作为位置索引不就行了吗？为什么要处理引用？ —遇到哈希冲突，只靠key分辨不出实例，需要通过比较内存地址…</li></ul><h3 id="请对比强引用（Strong-Reference）、软引用（Soft-Reference）、弱引用（Weak-Reference）和虚引用（Phantom-Reference）的特点，并说明它们的垃圾回收行为"><a href="#请对比强引用（Strong-Reference）、软引用（Soft-Reference）、弱引用（Weak-Reference）和虚引用（Phantom-Reference）的特点，并说明它们的垃圾回收行为" class="headerlink" title="请对比强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）的特点，并说明它们的垃圾回收行为"></a>请对比强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）的特点，并说明它们的垃圾回收行为</h3><ul><li>强引用是对象存活的基础，永远不会回收。软引用回收时机是内存不足的时候，比较大的缓存（视频图片缓存）。弱引用的话是下一次GC的时候会被回收，一些临时缓存。虚引用的话主要是用于跟踪对象回收事件，用于堆外内存管理。</li></ul><h3 id="虚引用与堆外内存管理"><a href="#虚引用与堆外内存管理" class="headerlink" title="虚引用与堆外内存管理"></a>虚引用与堆外内存管理</h3><p>堆内创建一个DirectByteBuffer 实例，用于管理（指向）堆外内存同时注册一个Cleaner（也就是虚引用），当缓存实例被回收时，会触发cleaner执行堆外内存的回收</p><h3 id="ThreadLocalMap-如何处理哈希冲突？为什么采用线性探测法而非链表法？在扩容时如何保证效率？"><a href="#ThreadLocalMap-如何处理哈希冲突？为什么采用线性探测法而非链表法？在扩容时如何保证效率？" class="headerlink" title="ThreadLocalMap 如何处理哈希冲突？为什么采用线性探测法而非链表法？在扩容时如何保证效率？"></a>ThreadLocalMap 如何处理哈希冲突？为什么采用线性探测法而非链表法？在扩容时如何保证效率？</h3><ul><li>线性探测在多个条目被映射到相邻位置时，查找效率较低。但在使用ThreadLocal的场景下，每个线程只会用少量的ThreadLocal，负载因子没那么高，拉链法要创建新的结点，开销更大，线性探测效率更高。为了使扩容次数尽量少，在插入新值，更新值或者扩容时都会遍历链表，找到key为null的值，回收value</li><li>set一个值时，key计算位置索引，判断key和当前位置的Entry.get（key）是否一致，若一致则更新值，否则寻找下一个位置</li></ul><h3 id="设计一个-ThreadLocal-的替代方案"><a href="#设计一个-ThreadLocal-的替代方案" class="headerlink" title="设计一个 ThreadLocal 的替代方案"></a><strong>设计一个 ThreadLocal 的替代方案</strong></h3><ul><li>主要要保证线程隔离和线程安全-&gt;使用ConcurrentHashMap，key为ThreadId，value为值。通过锁控制防止线程冲突。</li></ul><h3 id="CAS原理和应用"><a href="#CAS原理和应用" class="headerlink" title="CAS原理和应用"></a>CAS原理和应用</h3><ul><li>使用基于硬件指令实现比较交换的原子操作，实现无锁操作。应用有原子类AtomicInteger自增自减，数据库的乐观锁实现。它通常会结合自旋操作去不断尝试获得锁，在高并发的场景下可能会导致CPU使用率过高，可以考虑采用指数退避算法或升级为互斥锁。</li></ul><h3 id="CopyOnWriteArrayList-如何实现线程安全？在哪些场景下使用它？频繁写入时为什么性能较差？"><a href="#CopyOnWriteArrayList-如何实现线程安全？在哪些场景下使用它？频繁写入时为什么性能较差？" class="headerlink" title="CopyOnWriteArrayList 如何实现线程安全？在哪些场景下使用它？频繁写入时为什么性能较差？"></a>CopyOnWriteArrayList 如何实现线程安全？在哪些场景下使用它？频繁写入时为什么性能较差？</h3><ul><li>适合于读多于写，对于实时性要求不高的场景。读不加锁，意味着它是快照读，读到不一定是最新的数据。写操作，上锁进行写时复制，如果频繁写的话，意味着大量的写时复制，导致性能下降。</li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h3 id="索引失效的情况？为什么会失效？"><a href="#索引失效的情况？为什么会失效？" class="headerlink" title="索引失效的情况？为什么会失效？"></a>索引失效的情况？为什么会失效？</h3><ul><li>首先在使用联合索引时不满足最左匹配原则，最左匹配原则是指在联合索引查询条件中，从联合索引最左列开始匹配。因为联合索引建立时最左列索引全局有序，后续列的有序性要在前列的值确定后才能保证。其次使用联合索引时，若按照最左匹配遇到了非等式，后续的索引失效，索引可以找到范围起始点，之后根据链表组成的叶子结点遍历行，导致后续用不上索引。对索引列运算或者使用函数也会失效，因为索引是基于原始值建立的，如果需要运算则需要全表查询字段后运算，所以可以考虑先在内存把索引的值计算查来作为条件。当然索引的列类型合提供值类型不一致时会发生类型隐式转换，也是对索引的运算会失效。另外，like 关键字的模糊索引也可能会导致索引失效，当占位符在最左侧，跟不满足最左匹配的原理一样，导致字符串前缀没用上。还有使用or的时候，如果有两个条件以上，其中一个条件无索引就会导致全表查找，全表查找包括所有结果，也没必要使用含索引的列。</li></ul><h3 id="如何判断索引失效？"><a href="#如何判断索引失效？" class="headerlink" title="如何判断索引失效？"></a>如何判断索引失效？</h3><ul><li>使用explain关键字，首先看type类型看索引是否命中以及命中的类型，主要有索引没命中全表查找all，index全索引树查找，range查找范围索引，还有非唯一索引，唯一索引。key中可以看命中的索引，extra列主要表示查询过程的一些额外信息，例如Using filesort，指不能通过索引的有序性查找结果集，而是要多次IO完成排序。using index 表示使用了索引。Using tempporary表示在连接或者排序过程中创建临时表，有额外的开销。</li></ul><h3 id="慢查询定位以及如何优化慢查询"><a href="#慢查询定位以及如何优化慢查询" class="headerlink" title="慢查询定位以及如何优化慢查询"></a>慢查询定位以及如何优化慢查询</h3><ul><li>开启慢日志，设置慢日志时间阈值，通过日志定位查询的语句。首先查询查询耗时主要有三个部分，一个是内存计算，第二个是IO次数影响IO总传输时间，第三个是磁盘寻址。优化慢查询就是优化这三个方面，首先是sql语句优化，对于limit分页查找，可以转换成索引分段查询，例如利用索引的有序性，定位到起点，避免深分页性能开销。对于分组排序，尽量在分组前过滤条件，而不只依赖having by。排序的话考虑，索引建立。 第二点就是索引建立和防止失效。 第三个对于单表过大，一是考虑满足三范式，消除冗余信息减小表大小。而是考虑分库分表，减少IO次数，例如按时间分片。</li></ul><h3 id="建立索引要考虑哪些因素？"><a href="#建立索引要考虑哪些因素？" class="headerlink" title="建立索引要考虑哪些因素？"></a>建立索引要考虑哪些因素？</h3><ul><li>首先对于查询条件中经常用到的列，where或者group by的时候建立索引，频繁查询意味着索引使用率高。另外利用索引的有序性可以优化order by语句。其次对数据均匀，或者说区分大的列建立索引，这样一次索引能过滤大多数数据，意味着过滤有效性高。再者就是要避免索引频繁变动的开销，因为底层是B+树，结点变动考虑分裂合并引发开销。第四点就是，建立索引本质上就是用空间换时间，对于一些小的表没必要建立索引，索引空间开销比时间开销更大就得不偿失了。第五点就是根据查询的内容建立联合索引，增加命中率减少回表，也就是减少IO。那在建立联合索引时也要注意顺序，满足最左匹配原则，防止索引失效。</li></ul><h3 id="一条update语句执行过程"><a href="#一条update语句执行过程" class="headerlink" title="一条update语句执行过程"></a>一条update语句执行过程</h3><ul><li>首先客户端和mysql建立连接，命令进入解析器，包括语法检查，进行预处理，检查是否字段是否有错，生成执行计划，执行器提交命令给innodb引擎。innodb开启一个新事务，命令先写入undo log用于回滚保证事务的原子性，先到缓存buffer poor查找数据是否存在，若存在则直接在缓存中修改，否则到磁盘中获取数据，修改后放入缓存。操作完后将物理命令写入redo log，用于保证数据库的持久性，由于日志是顺序写，比修改数据随机写要快，所以先将日志写回磁盘，这个过程叫write ahead logging。当然在事务提交前还要将逻辑命令写入bin log，bin log用于主从结点同步，为了保证主宕机后的主从一致性，redo log和bin log用的是两阶段提交。在bin log commit之后事务提交，磁盘数据在合适的时机落盘，例如在redo log满时，因为redo log是环形结构，会有数据覆盖导致风险。</li></ul><h3 id="MVCC过程及其会有什么性能瓶颈"><a href="#MVCC过程及其会有什么性能瓶颈" class="headerlink" title="MVCC过程及其会有什么性能瓶颈"></a>MVCC过程及其会有什么性能瓶颈</h3><ul><li>MVCC也就是多版本并发控制，它是一种数据库技术，目的是通过维护数据的多个版本去控制读写的并发，在保证一定事务隔离级别情况下提升系统的性能。它利用了两个核心的元素。一个是Undo log日志，在对某行数据进行写操作时，会在undo log日志中生成一个数据行的版本，那么同一数据行各版本通过指针相连形成一个版本链，各数据行会有唯一的事务id标识，以表示该版本对应的事务id。第二个是Read View读快照，它里面维护着活跃事务id集合也就是未提交的事务id，另外还有最小活跃事务id和最大事务id，以及创建快照的事务id。根据事务隔离级别的不同，快照生成的时机也不一样。具体来说，以可重复读为例，事务在首次快照读的时候，会生成一个readview，那么为了保证可重复读，当前事务执行过程的每次快照读都用当前的readview，他对于数据行版本的可见规则是这样的，首先会遍历对应数据行的版本链，查找对应版本的事务id，当事务id小于readview中的最小活跃事务id时，就认为在事务快照读前，数据行版本已经提交。因为事务id的分配是全局递增的。那么另一种情况，就是事务id大于最小活跃事务id小于最大事务id时，判断其是否在活跃事务id列表里，如果不在，则版本对事务可见，这种情况是因为它虽然比最小活跃事务id创建的晚，但是在快照生成时已经提交。通过这种方式，就可以实现在一次事务中，每次都能读到相同的数据行版本。当然对于读已提交来说，它总是读最新提交的数据，那么只要在每次快照读时，都生成一个新的readView，也就是及时更新全局活跃事务id状况即可。</li><li>性能开销首先随着事务增多，读视图和版本链存储开销增大，遍历版本链所用的时间花销也增加，本质上还是用空间去换时间，减少加锁释放锁的开销。</li></ul><h3 id="数据库中的锁机制"><a href="#数据库中的锁机制" class="headerlink" title="数据库中的锁机制"></a>数据库中的锁机制</h3><ul><li>首先每个客户端和数据库建立连接时，数据库都会分配一个工作线程进行处理。随着连接数增多，意味着工程线程增多，每个线程开启一个事务的话，多事务并发执行，意味着多线程并发，也就是说会出现并发安全问题，具体来说根据事务隔离级别的不同，会产生脏读、不可重复读、幻读的问题，一个是通过MVCC来控制隔离级别，另外一个就是通过锁机制，来保证并发安全。</li><li>以互斥性来分，主要有共享锁和互斥锁，共享锁是指允许多个事务同时获得锁，通常用在读操作中，例如在读操作下+lock in share mode，或者在可重复读隔离性级别下，普通读会隐式加上共享锁，也就是mysql其实默认级别就是可重复读。互斥锁的话则是，只允许一个事务获得锁，其他事务在访问已上锁的数据行时会被阻塞。互斥锁按粒度分的话，其实又分别全局锁，用于数据库迁移。表锁包括元数据锁，在修改表结构时会隐式上锁。意向锁，用于在要加表锁的时候判断提前判断表内是否有数据行被上互斥锁。更细粒度的话就是行级锁了，包括行锁，也就是锁上单个行记录。间隙锁，锁住记录间隙，左开右开。可重复读级别下，默认用的是Next-key lock。也就是行锁+间隙锁，也就是左开右闭，innodb其实做了性能优化，在等值查询命中的情况下，唯一索引会退化到行锁，非唯一索引由于可能不指一个结果，所以继续寻找右边界直到值不匹配，也就是退化为间隙锁。在不命中的情况下，已查询的数值为中心，左右边界扩展到离自己最近的边界，也就是退化为间隙锁。而范围查询，对于唯一索引，若命中起点则使用行锁，有边界扩展直到不满足条件，补上一个间隙锁。如果是非唯一索引，因为非唯一，命中起点不会退化成行锁，而是左右边界继续拓展，找到不满足条件的边界。对于没使用索引的时候，扫描全表，会导致对所有主键间隙都加锁，相当于对整个表加锁。在使用innodb时，执行update、delete时本身就会隐式上锁，当然如果要显示加锁的话，可以使用for update。当然，前面所提的互斥锁按锁的思想划分其实又叫悲观锁，与之对应就是乐观锁。</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="Socket-fd文件描述符"><a href="#Socket-fd文件描述符" class="headerlink" title="Socket&#x2F;fd文件描述符"></a>Socket&#x2F;fd文件描述符</h3><ul><li><p>Socket创建时会创建一个数据结构，标识五元组：<strong>：本地IP、本地端口、远程IP、远程端口和协议</strong>，fd是一个索引值，指向一个文件记录表，该表记录内核为每一个进程维护的文件记录信息-Socket结构体。 创建时IP和端口为空，服务端bind()填充本地IP和端口–监听socket，listen建立半连接和全连接队列，客户端connect-开启三次握手，服务端accept接受客户端请求后，生成新的Socket并返回用户。也就是说新创建的Socket填充好客户端的IP&#x2F;端口以能读写。 Socket是操作系统是提供给用户操作IO的接口，fd是操作系统的概念，<strong>操作 Socket 本质上是通过关联的 fd 去操作底层的 I&#x2F;O 资源</strong>。</p></li><li><p>结构体</p><ul><li><p><strong>协议族</strong>（如 AF_INET 表示 IPv4）。</p></li><li><p><strong>协议类型</strong>（如 SOCK_STREAM 表示 TCP，SOCK_DGRAM 表示 UDP）。</p></li><li><p><strong>网络地址和端口</strong>（本地和远端的地址信息）。</p></li><li><p><strong>连接状态</strong>（如监听、已连接、关闭等）。</p></li><li><p><strong>缓冲区</strong>（用于存储待发送或已接收的数据）。</p></li><li><p><strong>其他状态信息</strong>（如超时设置、选项等）。</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础&quot;&gt;&lt;a href=&quot;#Java基础&quot; class=&quot;headerlink&quot; title=&quot;Java基础&quot;&gt;&lt;/a&gt;Java基础&lt;/h1&gt;&lt;h3 id=&quot;面向对象和面向过程的区别？&quot;&gt;&lt;a href=&quot;#面向对象和面向过程的区别？&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>场景题</title>
    <link href="https://senwh.github.io/2025/03/19/%E5%9C%BA%E6%99%AF%E9%A2%98/"/>
    <id>https://senwh.github.io/2025/03/19/%E5%9C%BA%E6%99%AF%E9%A2%98/</id>
    <published>2025-03-19T03:19:16.000Z</published>
    <updated>2025-05-20T13:25:08.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="如何定位-优化慢查询"><a href="#如何定位-优化慢查询" class="headerlink" title="如何定位+优化慢查询"></a>如何定位+优化慢查询</h2><p><strong>定位</strong></p><ul><li>开启慢日志</li><li>Explain（模拟优化器执行）<ul><li>key：使用的索引</li><li>type: system（表中只有一行数据) ，const(只有一行索引匹配)，eq_ref（主键或唯一索引的等值连接），ref（非主键非唯一索引），range（索引范围），index（全表索引），all（全表扫描）</li></ul></li></ul><p><strong>优化角度</strong></p><ul><li>数据量<ul><li>数据量越大IO次数越多</li></ul></li><li>取数据方式<ul><li>磁盘还是缓存</li><li>是否能结合谓词条件命中全局索引</li></ul></li><li>数据加工方式<ul><li>排序、子查询、聚合、关联等取到临时表中，对数据加工</li><li>合适的join方式</li></ul></li></ul><p><strong>优化思路</strong></p><ul><li><p>减少数据扫描</p><ul><li><p>数据分页优化</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">select * from table_demo <span class="type">where</span> <span class="variable">type</span> <span class="operator">=</span> ?  limit A,B; </span><br><span class="line">---limit+offset，每次查询B条数据都要扫描跳过前A-<span class="number">1</span>条数据</span><br><span class="line">    </span><br><span class="line">lastId = <span class="number">0</span> or <span class="title function_">min</span><span class="params">(id)</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">select * from table_demo <span class="type">where</span> <span class="variable">type</span> <span class="operator">=</span> ? and id &gt;&#123;#lastId&#125;  limit ?;</span><br><span class="line">lastId = max(id)</span><br><span class="line">&#125; <span class="keyword">while</span> (isNotEmpty)</span><br><span class="line">---记录偏移ID，新页直接定位到上一次的<span class="type">ID</span></span><br><span class="line">    </span><br><span class="line"><span class="variable">minId</span> <span class="operator">=</span> min(id) maxId = max(id)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> minId; i&lt;= maxId; i+=pageSize)&#123;</span><br><span class="line">select * from table_demo <span class="type">where</span> <span class="variable">type</span> <span class="operator">=</span> ? and id between i and i+ pageSize;</span><br><span class="line">&#125;</span><br><span class="line">--- between and，分段查询 虽然可以减少扫描遍历情况，但是不适用于查询的键分布不均的情况，多了一些不必要的查询</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Groud By分组优化</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select job , avg(sal) from table_demo <span class="type">where</span>  <span class="variable">job</span> <span class="operator">=</span> ‘manager<span class="string">&#x27; group by job</span></span><br><span class="line"><span class="string">先过滤后分组</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>范围查询</p><blockquote><p>单键索引: 查询到主键索引时，先排序后回表Multi Range Read(MRR)），可以减少IO次数（一个页中有多个连续行）</p><p>联合索引：Mysql5.6+，等式放范围查询的右边会通过索引下推过滤回表的主键数，当然：等值最左匹配才是优解</p></blockquote></li><li><p>Order By</p><blockquote><p>索引覆盖排序 ：order前建立索引时已经排好序</p></blockquote></li><li><p>业务划分</p><blockquote><p>date &#x3D; now; minDate &#x3D; now - 10 days<br>while(date &gt; minDate) {<br>select * from order where order_date&#x3D;{<em>#date} and status&#x3D;’S’ and update_time &lt; now-5min limit 500</em>  date &#x3D; data + 1}</p><p>对比: 快在可以对order_date索引（status如果太均匀失效了），避免一次性读太大量的表进内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from order where status=<span class="string">&#x27;S&#x27;</span> and update_time &lt; now-5min  limit <span class="number">500</span></span><br></pre></td></tr></table></figure></blockquote></li></ul></li><li><p>数据库结构优化</p><ul><li>范式优化：消除冗余</li><li>反范式优化：适当加冗余-避免join操作（有时候不满足第三范式也能提升速度）</li><li>按物理结构拆分表，避免全表扫描（例如按日期）</li></ul></li><li><p>SQL语句优化</p><ul><li>区分 in 和 exists（in先执行子查询后逐行判断-适合内表小的情况（子查询返回的结果少），后者遍历外表逐行执行子查询，遇到匹配项停止减少扫描。因为每次子查询需要开销，在少量数据的时候还是用in）</li><li>尽量避免使用子查询-&gt;join&#x2F;反范式优化</li></ul></li><li><p>大表优化</p><ul><li>分库分表</li><li>读写分离（主从复制）</li><li>定期归档（历史数据移除，减少主表大小）</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h1&gt;&lt;h2 id=&quot;如何定位-优化慢查询&quot;&gt;&lt;a href=&quot;#如何定位-优化慢查询&quot; class=&quot;headerlink&quot; title=&quot;如</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>造轮子：RPC框架</title>
    <link href="https://senwh.github.io/2025/03/17/%E9%80%A0%E8%BD%AE%E5%AD%90%EF%BC%9ARPC%E6%A1%86%E6%9E%B6/"/>
    <id>https://senwh.github.io/2025/03/17/%E9%80%A0%E8%BD%AE%E5%AD%90%EF%BC%9ARPC%E6%A1%86%E6%9E%B6/</id>
    <published>2025-03-16T16:22:47.000Z</published>
    <updated>2025-04-10T02:57:34.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="客户端-服务端-v1-0"><a href="#客户端-服务端-v1-0" class="headerlink" title="客户端-服务端 v1.0"></a>客户端-服务端 v1.0</h1><p><img src="/./%E9%80%A0%E8%BD%AE%E5%AD%90%EF%BC%9ARPC%E6%A1%86%E6%9E%B6/rpc_1.png" alt="image-20250317013101392"></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol><li>调用服务接口（客户端无实现类）</li><li>获取接口<strong>Class对象</strong>，使用动态代理<strong>为接口生成代理对象</strong></li></ol><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HelloService</span> <span class="variable">helloService</span> <span class="operator">=</span> rpcClientProxy.getProxy(HelloService.class);</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>重写代理类invoke方法（在调用接口方法时，代理对象拦截请求，调用invoke方法）</li></ol><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke(Object proxy, Method method, Object[] args)</span><br></pre></td></tr></table></figure></blockquote><ol start="4"><li>在Invoke方法中，获取所调用的方法信息（接口名、方法名、参数信息）封装成请求信息</li><li>通过Socket建立连接并通过OutputStream发送</li><li>通过Socket获取InputStream返回响应</li></ol><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><ol><li><p>Socket监听端口，获取请求数据</p></li><li><p>创建线程池，处理Socket监听到的请求</p></li></ol><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(<span class="keyword">new</span> <span class="title class_">Task</span>(socket, helloService));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>解析请求体里的数据，根据注册映射表（通过请求的接口全限定名映射实现类），获取实现类实例</li></ol><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">service</span> <span class="operator">=</span> serviceImplClass.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>获取方法信息，反射调用服务</li></ol><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(service, rpcRequest.getParameters());</span><br></pre></td></tr></table></figure></blockquote><ol start="4"><li>通过Socket返回响应数据</li></ol><h1 id="客户端-服务端-v1-1"><a href="#客户端-服务端-v1-1" class="headerlink" title="客户端-服务端 v1.1"></a>客户端-服务端 v1.1</h1><h2 id="待优化问题"><a href="#待优化问题" class="headerlink" title="待优化问题"></a>待优化问题</h2><ol><li>服务端用信息什么注册？</li></ol><ul><li>现在服务端维护一个注册表，通过HashMap记录（服务全限定名，服务Class对象）。即根据收到的服务全限定名获取服务。使用户只关心接口-&gt;注册接口名作为服务名注册</li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;[] interfaces = serviceImplClass.getInterfaces();</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line"> <span class="comment">// 使用接口的规范名称作为服务名</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> intf.getCanonicalName();</span><br><span class="line"> <span class="keyword">if</span>(serviceMap.containsKey(serviceName))&#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 将服务名称和对应的服务实现类的 Class 对象存入 map</span></span><br><span class="line"> serviceMap.put(serviceName, serviceImplClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>若有多个RPC服务器，服务如何注册？</li></ol><ul><li>现在所有服务使用同一个实例对象，注册方法设置为静态方法，多个RPC服务若注册则都放同一个实例，高耦合。-&gt;取消静态方法，注册表实例化对象作为参数传入RPC服务</li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServiceRegistry</span> <span class="variable">serviceRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceRegistryImpl</span>();</span><br><span class="line">serviceRegistry.register(HelloServiceImpl.class);</span><br><span class="line"><span class="type">RpcServer</span> <span class="variable">rpcServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcServer</span>(serviceRegistry);</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>此时传输采用的是BIO的方式，如何改成性能更好的NIO？</li></ol><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br></pre></td></tr></table></figure></blockquote><hr><ul><li>使用Java nio库+jackson序列化实现NIO<ul><li>如果直接转成字节数组发送，在解析时头昏脑胀-&gt;也就是说要一个字符一个字符读取切割</li></ul></li></ul><blockquote><p>序列化登场: 对象的状态信息转换为可以存储或传输的形式（如字节序列、JSON 字符串等）的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonRequest</span> <span class="operator">=</span> objectMapper.writeValueAsString(rpcRequest);</span><br></pre></td></tr></table></figure></blockquote><p>实际上：在BIO也用了序列化反序列化的过程-如果一个类实现了 <code>Serializable</code> 接口，在使用 <code>ObjectOutputStream</code>（属于 BIO 体系）时，该类的对象就能被自动序列化并且自动转换为字节流。</p><ul><li>使用其序列化的时候遇到问题：RpcRequest中的parameters 是Object[] 类型-&gt; JSON 序列化时，<code>Object</code> 类型的字段会被序列化为一个通用的 JSON 结构，<strong>反序列化时，Jackson 默认会将其解析<code>LinkedHashMap</code></strong>—<strong>即多态类型处理问题</strong></li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解决方案,字段前加入注解：<span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = &quot;@class&quot;)</span> 使用类的全限定名作为类型标识/将类型信息作为 JSON 对象的一个属性存储/指定类型信息的属性名为 <span class="meta">@class</span></span><br></pre></td></tr></table></figure></blockquote><ul><li>收发通过channel-&gt;将通道注册到选择器中-&gt;底层 （fds描述符注册到epoll）</li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开选择器 --创建红黑树实例</span></span><br><span class="line">selector = Selector.open(); </span><br><span class="line"><span class="comment">// 打开服务器套接字通道</span></span><br><span class="line">serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 绑定端口</span></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line"><span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 注册 OP_ACCEPT 事件到选择器 描述符（FD）添加到红黑树</span></span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure></blockquote><ul><li>当监听到请求，遍历事件并执行（当文件描述符（如套接字）的状态发生变化（如数据可读、可写等），内核会检测到这些事件。对于epoll，内核会调用一个回调函数（如<code>ep_poll_callback</code>），将事件通知给epoll实例。这个回调函数会将事件添加到epoll的就绪队列（<code>rdllist</code>）中，用户态程序调用<code>epoll_wait</code>检查就绪队列并取出）</li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selector.select(); </span><br><span class="line"><span class="comment">// 获取所有发生的事件 返回链表集合</span></span><br><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys()</span><br></pre></td></tr></table></figure></blockquote><hr><p>该版本实际上实现了一个单Reactor模型，单线程派发任务，多线程分别处理连接和执行读&#x2F;写操作</p><h1 id="客户端-服务端-v1-2"><a href="#客户端-服务端-v1-2" class="headerlink" title="客户端-服务端 v1.2"></a>客户端-服务端 v1.2</h1><h2 id="待优化问题-1"><a href="#待优化问题-1" class="headerlink" title="待优化问题"></a>待优化问题</h2><ol><li>NIO 有空轮询Bug：事件返回数量为0，但是应该阻塞的selector.select()不断被唤醒，导致CPU100%</li></ol><ul><li>原因：当一个连接被突然中断，epoll会将事件集合置位，由于事件集合发生了变化，<code>Selector</code>被唤醒</li></ul><ol start="2"><li>单Reactor模型在高并发场景有性能瓶颈-&gt;多线程多Reactor模型</li></ol><p>用Netty网络编程框架，封装Select处理细节</p><blockquote><p>责任链模式，数据入站-&gt;找重写了decoder方法-&gt;链顺序移动到下一个Handler（ChannelInboundHandler）专门处理入栈数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bootstrap = <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">bootstrap.group(group) <span class="comment">//group 线程池从中取EventLoop （线程）执行具体任务</span></span><br><span class="line">     .channel(NioSocketChannel.class) <span class="comment">//Channel被注册 Selector 监听事件 </span></span><br><span class="line">     .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">         <span class="meta">@Overrid</span> <span class="comment">//当有就绪事件调用channel read方法读取数据进入责任链</span></span><br><span class="line">         <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">             ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">CustomObjectDecoder</span>());</span><br><span class="line">             ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">CustomObjectEncoder</span>(serializer));</span><br><span class="line">             ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyRpcClientHandler</span>()); <span class="comment">//channelRead0 触发</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">ctx.fireChannelRead(processedMsg); <span class="comment">//传递给下一个入站方向的处理器</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>出站则责任链逆序（ChannelOutboundHandler）-&gt;找重写了encoder方法-&gt;出站</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> ctx.writeAndFlush(RpcResponse.success(result)); <span class="comment">//将处理结果writeAndFlush 写入出站方向-传递给下一个处理器</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>ChannelHandlerContext</code> 提供了 <code>ChannelHandler</code> 与 <code>ChannelPipeline</code> 以及其他组件之间的交互能力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;收到消息:&quot;</span> + response);</span><br><span class="line"> AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line"> ctx.channel().attr(key).set(response); <span class="comment">//设置响应对象名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>自定义序列化器-&gt;封装协议号&#x2F;序列器类型号&#x2F;包类型&#x2F;数据长度+数据</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CustomObjectEncoder <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span> <span class="comment">//实现该接口，当数据离开时自动调用encode方法</span></span><br><span class="line">CustomObjectDecoder <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> <span class="comment">//实现该接口，当数据入站时自动调用decode方法</span></span><br></pre></td></tr></table></figure></blockquote><p>针对前面所提：对Object序列化时的 多态类型处理问题-&gt;除了用注解方式，还可以用强转：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rpcRequest.getParamTypes().length; i ++) &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = rpcRequest.getParamTypes()[i];</span><br><span class="line">    <span class="keyword">if</span>(!clazz.isAssignableFrom(rpcRequest.getParameters()[i].getClass())) &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = objectMapper.writeValueAsBytes(rpcRequest.getParameters()[i]);</span><br><span class="line">        rpcRequest.getParameters()[i] = objectMapper.readValue(bytes, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="客户端-服务中心-服务端-v2-0"><a href="#客户端-服务中心-服务端-v2-0" class="headerlink" title="客户端-服务中心-服务端 v2.0"></a>客户端-服务中心-服务端 v2.0</h1><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li>将服务中心移动到Nacos，客户端从Nacos请求服务地址，为后续实现负载均衡打基础</li></ul><blockquote><p>接口的全限定名作为key分别注册到nacos和本地注册表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">serviceProvider.register(serviceClass); <span class="comment">//本地注册</span></span><br><span class="line">Class&lt;?&gt;[] interfaces = serviceClass.getInterfaces();</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line"> <span class="comment">// 注册服务到注册中心</span></span><br><span class="line"> serviceRegistry.register(intf.getCanonicalName(), <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(host, port));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注册中心</span><br><span class="line">namingService.registerInstance(serviceName, inetSocketAddress.getHostName(), inetSocketAddress.getPort());</span><br><span class="line"></span><br><span class="line">客户端请求</span><br><span class="line">List&lt;Instance&gt; instances = namingService.getAllInstances(serviceName);</span><br></pre></td></tr></table></figure></blockquote><ul><li>负载均衡（在客户端处理）</li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Instance&gt; instances = namingService.getAllInstances(serviceName);</span><br><span class="line"><span class="comment">// 选择负载均衡策略，这里可以根据需要修改</span></span><br><span class="line"><span class="type">Instance</span> <span class="variable">selectedInstance</span> <span class="operator">=</span> randomLoadBalance(instances); <span class="comment">//随机/轮询</span></span><br><span class="line"><span class="comment">//假设注册中心有多个实例，在多线程情况下请求 轮询时原子类当计数器</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">roundRobinIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">private</span> Instance <span class="title function_">roundRobinLoadBalance</span><span class="params">(List&lt;Instance&gt; instances)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> roundRobinIndex.getAndIncrement() % instances.size();</span><br><span class="line">     <span class="keyword">return</span> instances.get(index);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;客户端-服务端-v1-0&quot;&gt;&lt;a href=&quot;#客户端-服务端-v1-0&quot; class=&quot;headerlink&quot; title=&quot;客户端-服务端 v1.0&quot;&gt;&lt;/a&gt;客户端-服务端 v1.0&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/./%E9%80%A0%E8%BD%A</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试篇-JVM</title>
    <link href="https://senwh.github.io/2025/02/27/%E9%9D%A2%E8%AF%95%E7%AF%87-JVM/"/>
    <id>https://senwh.github.io/2025/02/27/%E9%9D%A2%E8%AF%95%E7%AF%87-JVM/</id>
    <published>2025-02-27T13:12:27.000Z</published>
    <updated>2025-02-27T14:07:27.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-（Java-Virtual-Machine）"><a href="#JVM-（Java-Virtual-Machine）" class="headerlink" title="JVM （Java Virtual Machine）"></a>JVM （Java Virtual Machine）</h1><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-JVM/JVM.png" alt="image-20250227211659883"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p><strong>定义：</strong>用于存储当前线程正在执行的字节码指令地址。它是 JVM 中一块较小的内存区域，每个线程都对应一个程序计数器</p><p><strong>用途：</strong></p><ul><li>存下一条需要执行的指令</li><li>线程上下文切换时的恢复</li></ul><h2 id="JAVA堆"><a href="#JAVA堆" class="headerlink" title="JAVA堆"></a>JAVA堆</h2><p><strong>定义：</strong>线程共享区域-存对象实例，数组等，堆满OOM</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-JVM/heap.png" alt="image-20250227212531001"></p><p><strong>内存结构：</strong></p><ul><li>新生代（Eden&#x2F;Survivor（From survivor+ To survivor））<ul><li>存储生命周期较短的对象</li><li>Eden满了出发MinorGC：对象转From survivor或To survivor</li></ul></li><li>老年代<ul><li>存储生命周期较长的对象，新生代回收多次仍然存活则移到老年代</li></ul></li></ul><p><strong>1.7和1.8的对比：</strong></p><ul><li>堆内存中有个永久区：存类信息、静态变量等（1.7）</li><li>移除永久区，将上述数据移到内存里的元空间，避免溢出（1.8）</li></ul><h2 id="什么是虚拟机栈"><a href="#什么是虚拟机栈" class="headerlink" title="什么是虚拟机栈"></a>什么是虚拟机栈</h2><p><strong>定义：</strong>线程运行时需要的内存-存储了线程执行方法时的<strong>局部变量</strong>（基本数据类型、对象引用等）、操作数栈（用于存储方法调用过程中的<strong>操作数和运算结果</strong>）</p><p><strong>结构：</strong>由多个栈帧（局部变量表、操作数栈（中间结果）、动态连接（指向常量池）等）组成，一个栈帧对应一个调用。例：函数调函数时各栈帧LIFO</p><p><strong>生命周期：</strong>一个线程创建，对应生成一个JVM栈。栈帧随着调用周期创建和销毁</p><p><strong>注意点：</strong></p><ul><li><p>垃圾回收回收的是<strong>堆内存</strong>，而栈内存在栈帧弹出后就会释放</p></li><li><p>栈内存过大会导致可用线程数变少（默认1024k）</p></li><li><p>方法内局部变量<strong>线程安全</strong>问题</p><ul><li>对于普通变量：<strong>线程安全</strong>，每个线程在调用方法时，会创建一个新的栈帧，局部变量存储在当前线程的栈中，不会被其他线程访问</li><li>可变对象的引用，并且该对象在多个线程中共享，那么<strong>可能会出现线程安全</strong>问题</li></ul></li><li><p>栈溢出</p><ul><li>栈帧过多（递归）</li><li>栈帧过大</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM-（Java-Virtual-Machine）&quot;&gt;&lt;a href=&quot;#JVM-（Java-Virtual-Machine）&quot; class=&quot;headerlink&quot; title=&quot;JVM （Java Virtual Machine）&quot;&gt;&lt;/a&gt;JVM （Jav</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面经准备</title>
    <link href="https://senwh.github.io/2025/02/26/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/"/>
    <id>https://senwh.github.io/2025/02/26/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/</id>
    <published>2025-02-26T15:30:25.000Z</published>
    <updated>2025-03-23T09:28:57.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目篇"><a href="#项目篇" class="headerlink" title="项目篇"></a>项目篇</h1><h2 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h2><h3 id="锁的续期"><a href="#锁的续期" class="headerlink" title="锁的续期"></a>锁的续期</h3><ul><li><p>你的续期机制和 Redisson 的看门狗有什么区别？–两者的核心思想相似，但 Redisson 的实现更完善</p><ul><li><strong>动态续期间隔</strong>：Redisson 默认按锁超时时间的 1&#x2F;3 续期（如30秒锁每10秒续一次），而我的实现是固定间隔。</li><li><strong>高性能调度</strong>：Redisson 使用 Netty 的 <code>HashedWheelTimer</code> 调度任务，效率更高；我的实现基于 <code>ScheduledExecutorService</code>。</li><li><strong>生产级容错</strong>：Redisson 内置了网络重试、故障转移等机制，而我需要手动处理这些边界情况。<br>我的方案适合学习或定制化场景，而生产环境推荐直接使用 Redisson。”</li></ul></li><li><p>如果续期过程中 Redis 宕机了怎么办？–典型的 <strong>分布式系统脑裂问题</strong></p><ul><li><strong>快速失败</strong>：在续期时捕获异常（如连接超时），立即停止续期任务，避免无效重试。</li><li><strong>锁超时兜底</strong>：依赖 Redis 的过期时间自动释放锁，即使续期失败，锁最终也会超时释放。</li></ul></li><li><p>如何避免守护线程续期他人持有的锁？–关键在于 <strong>锁归属校验</strong></p><ul><li><strong>唯一标识</strong>：每个锁的持有者生成唯一的 <code>requestId</code>（如 UUID）。-</li><li><strong>原子性校验</strong>：通过 Lua 脚本在续期时检查 Redis 中的 <code>requestId</code> 是否与当前线程一致</li></ul></li></ul><h2 id="如何避免用户重复点击？"><a href="#如何避免用户重复点击？" class="headerlink" title="如何避免用户重复点击？"></a>如何避免用户重复点击？</h2><ul><li>幂等性设计<ul><li>客户端生成唯一标识，服务器端通过redis校验</li><li>订单表根据订单号生成唯一索引</li></ul></li><li>token机制<ul><li>生成一次性token，接收到后让其立即失效</li></ul></li></ul><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h4 id="JWT相比Session的优缺点？"><a href="#JWT相比Session的优缺点？" class="headerlink" title="JWT相比Session的优缺点？"></a>JWT相比Session的优缺点？</h4><ul><li><strong>优点</strong>：无状态、适合分布式、跨域支持。</li><li><strong>缺点</strong>：无法主动失效、Payload不宜过大。</li></ul><h4 id="如何防止JWT被盗？"><a href="#如何防止JWT被盗？" class="headerlink" title="如何防止JWT被盗？"></a>如何防止JWT被盗？</h4><ul><li><p><strong>答案</strong>：使用HTTPS、设置合理过期时间（<strong>短有效期 + 刷新令牌机制</strong>）、将使用<strong>HttpOnly Cookie</strong>存储token而非LocalStorage（JavaScript可以通过<code>window.localStorage</code>直接读写数据）、<strong>Token绑定</strong>：在Payload中加入IP或设备指纹。</p></li><li><p><strong>被盗后可冒充用户执行服务器未授权操作（拿你token放我请求头中）</strong></p></li></ul><h4 id="这段代码的线程安全问题-ThreadLocal底层原理？"><a href="#这段代码的线程安全问题-ThreadLocal底层原理？" class="headerlink" title="这段代码的线程安全问题&#x2F;ThreadLocal底层原理？"></a>这段代码的线程安全问题&#x2F;ThreadLocal底层原理？</h4><ul><li><p><strong>答案</strong>：<code>BaseContext</code> 使用 <code>ThreadLocal</code>，天然线程隔离，但需在请求完成后清理（可补充<code>afterCompletion</code>方法）</p></li><li><p>每个线程内部维护一个 <code>ThreadLocalMap</code>–在set时创建一个map（不是HashMap）-数组实现-&gt;数组存着一堆（初始化大小16）Entry</p></li><li><pre><code class="java">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;        super(k); // 调用WeakReference的构造函数，设置弱引用的键        value = v; // 存储线程局部变量的值    &#125;</code></pre></li><li><p>数组索引获取：i &#x3D; firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); （对key hash后取模）</p></li></ul><p><strong>为什么 <code>ThreadLocal</code> 的键要设计成弱引用（WeakReference）？</strong><br><strong>回答</strong>：</p><p><code>ThreadLocal</code> 的键使用弱引用是为了防止内存泄漏。当 <code>ThreadLocal</code> 实例的强引用被释放时（如置为 <code>null</code>），弱引用允许 GC 回收该实例。此时，<code>ThreadLocalMap</code> 中对应的 Entry 的键会被<strong>标记为 <code>null</code><strong>，后续操作（如 <code>set()</code> 或 <code>get()</code>）会</strong>自动清理</strong>这些无效 Entry，释放关联的 <code>value</code>。<strong>但需注意：值的清理仍需显式调用 <code>remove()</code>，因为 Entry 的 <code>value</code> 是强引用</strong></p><p>常见new的对象不需要显示释放是因为，生命周期和作用域有关，执行完就无引用了。而ThreadLocal可能某个线程一直在复用，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目篇&quot;&gt;&lt;a href=&quot;#项目篇&quot; class=&quot;headerlink&quot; title=&quot;项目篇&quot;&gt;&lt;/a&gt;项目篇&lt;/h1&gt;&lt;h2 id=&quot;Redis分布式锁&quot;&gt;&lt;a href=&quot;#Redis分布式锁&quot; class=&quot;headerlink&quot; title=&quot;Red</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试篇-计网</title>
    <link href="https://senwh.github.io/2025/02/26/%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/"/>
    <id>https://senwh.github.io/2025/02/26/%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/</id>
    <published>2025-02-26T13:19:51.000Z</published>
    <updated>2025-05-22T01:05:37.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="键入网址到网页显示，期间发生了什么？"><a href="#键入网址到网页显示，期间发生了什么？" class="headerlink" title="键入网址到网页显示，期间发生了什么？"></a>键入网址到网页显示，期间发生了什么？</h2><ul><li><strong>应用程序：</strong>URL-&gt;Http报文-&gt;DNS解析（递归+缓存）（本地、根、顶级、权威）</li><li><strong>传输层：</strong>应用层用socket调用协议栈（TCP&#x2F;UDP IP ICMP ARP）-&gt;封装（Http）TCP报文(超MSS切割)-其监听浏览器端口 http（80）&#x2F;https(443)-<strong>先三次握手</strong></li><li><strong>网络层：</strong>根据路由表找到下一跳MAC地址，将目标地址写入IP头部</li><li><strong>网络层\数据链路层：</strong>若路由表找不到下一跳MAC地址，ARP协议广播目标IP以获得MAC地址（缓存），取得地址后封装到目的地址以IPv4协议发送</li><li><strong>物理层：</strong>网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列（FCS）</li><li><strong>网卡</strong>会将包转为电信号，通过网线发送出去</li><li><strong>交换机</strong>根据（FCS）校验包，成功则放入缓冲区,查MAC地址表（MAC-端口）-<strong>没有则广播</strong></li><li><strong>路由器</strong>校验包（FCS），查看MAC地址，匹配则放入缓存。根据IP地址查找封装下一跳MAC地址进头部&#x2F;接收</li><li>接收后-&gt;网络层-&gt;传输层-&gt;应用层-四次挥手</li></ul><h2 id="电脑插入网线后涉及哪些协议"><a href="#电脑插入网线后涉及哪些协议" class="headerlink" title="电脑插入网线后涉及哪些协议"></a>电脑插入网线后涉及哪些协议</h2><ul><li>首先电脑插入网线意味着连上网了，假设是动态分配IP，DHCP会给电脑分配IP地址。</li></ul><h2 id="Linux-收发网络包的流程"><a href="#Linux-收发网络包的流程" class="headerlink" title="Linux 收发网络包的流程"></a>Linux 收发网络包的流程</h2><ul><li>应用层发起系统调用（socket）-&gt;数据copy进<strong>sk_buff 内存</strong>-&gt;发送缓存</li><li>TCPcopy了sk_buff（收到ACK之后再清除） -协议栈处理</li><li>IP 层发现 sk_buff 大于 MTU ,申请内存，将原来的 sk_buff 拷贝为多个小的 sk_buff <strong>故发送发生了（2-3次）copy</strong></li><li>网卡<strong>接收到一个网络包后</strong>，会通过 <strong>DMA 技术</strong>，将网络包写入到指定的内存地址，也就是写入到 <strong>Ring Buffer</strong></li><li>使用<strong>NAPI 机制</strong>，它是混合「中断和轮询」的方式来接收网络包。避免每接收到一次就中断，先屏蔽中断（时间片轮询）解除屏蔽中断（软（件）中断），处理</li><li>往上传，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区「拷贝」到应用层的缓冲区，<strong>唤醒用户线程</strong></li><li>Data-&gt;segment-&gt;packet-&gt;frame</li></ul><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><ul><li>1xx <strong>提示信息</strong>，是协议处理中的一种中间状态</li><li><strong>成功</strong>：200（有body)、204（无body）、206（部分body）</li><li><strong>资源变动，需要重定向地址：</strong>301（永久）、302（临时）、304（用缓存的就行，缓存和我这里的一致）</li><li><strong>报文有误</strong>：400 （不知道为啥错）、403（禁止）、404（资源服务器找不到）</li><li><strong>服务器错出</strong>：500（不知道）、501（功能还不支持）、502（网关的问题）、503（服务器繁忙）</li></ul><h2 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h2><h3 id="HTTP-请求字段"><a href="#HTTP-请求字段" class="headerlink" title="HTTP 请求字段"></a>HTTP 请求字段</h3><table><thead><tr><th><strong>请求行字段</strong></th><th>用于标识请求的类型、资源路径和协议版本。</th></tr></thead><tbody><tr><td>方法（如 GET、POST）</td><td>指定请求的类型，例如获取资源（GET）、提交数据（POST）等。</td></tr><tr><td>URI</td><td>请求的资源路径，如 <code>/index.html</code>。</td></tr><tr><td>HTTP 版本</td><td>指定使用的 HTTP 协议版本，例如 <code>HTTP/1.1</code> 或 <code>HTTP/2</code>。</td></tr></tbody></table><table><thead><tr><th><strong>请求头部字段</strong></th><th>提供关于请求的附加信息。</th></tr></thead><tbody><tr><td>Host</td><td>指定请求的主机名和端口号，例如 <code>www.example.com</code>。</td></tr><tr><td>Accept</td><td>客户端可接受的响应内容类型，如 <code>text/html</code>、<code>application/json</code> 等。</td></tr><tr><td>Accept-Encoding</td><td>客户端可接受的编码方式，如 <code>gzip</code>、<code>deflate</code> 等。</td></tr><tr><td>Content-Type</td><td>请求体的媒体类型，如 <code>application/json</code>、<code>application/x-www-form-urlencoded</code> 等。</td></tr><tr><td>Content-Length</td><td>请求体的长度（以字节为单位）。</td></tr><tr><td>Authorization</td><td>用于认证的凭证，如 <code>Basic</code>、<code>Bearer</code> 等。</td></tr><tr><td>Cookie</td><td>客户端存储的 Cookie 信息。</td></tr></tbody></table><h3 id="HTTP-响应字段"><a href="#HTTP-响应字段" class="headerlink" title="HTTP 响应字段"></a>HTTP 响应字段</h3><table><thead><tr><th><strong>状态行字段</strong></th><th>用于标识响应的协议版本、请求结果和简短描述。</th></tr></thead><tbody><tr><td>HTTP 版本</td><td>指定使用的 HTTP 协议版本，例如 <code>HTTP/1.1</code> 或 <code>HTTP/2</code>。</td></tr><tr><td>状态码</td><td>表示请求结果的三位数字代码，如 <code>200 OK</code>、<code>404 Not Found</code> 等。</td></tr><tr><td>状态消息</td><td>对状态码的简短描述，如 <code>OK</code>、<code>Not Found</code> 等。</td></tr><tr><td><strong>响应头部字段</strong></td><td>提供关于响应的附加信息。</td></tr><tr><td>Content-Type</td><td>响应体的媒体类型，如 <code>text/html</code>、<code>application/json</code> 等。</td></tr><tr><td>Content-Length</td><td>响应体的长度（以字节为单位）。</td></tr><tr><td>Location</td><td>重定向的 URL。</td></tr><tr><td>Set-Cookie</td><td>服务器设置的 Cookie 信息。</td></tr><tr><td><strong>响应体</strong></td><td>包含服务器返回的数据，如 HTML 页面、JSON 数据等。</td></tr></tbody></table><h2 id="HTTP-缓存技术"><a href="#HTTP-缓存技术" class="headerlink" title="HTTP 缓存技术"></a>HTTP 缓存技术</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p><strong>定义：</strong>只要<strong>浏览器判断缓存</strong>没有过期，则直接使用浏览器的本地缓存。响应体状态码旁显示（ from disk cache）</p><p><strong>用法：</strong>请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期（Cache-Control 的优先级高于 Expires）</p><ul><li><code>Cache-Control</code>， 是一个相对时间</li><li><code>Expires</code>，是一个绝对时间</li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p><strong>定义：</strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存<strong>（304）</strong></p><p><strong>实现：</strong></p><ul><li><code>If-Modified-Since</code>服务器检查资源的最后修改时间是否晚于<code>Last-Modified</code>-&gt;（304&#x2F;200）</li><li>服务器检查资源<code>If-None-Match</code> 和请求的<code>ETag</code> -&gt;（304&#x2F;200）</li><li>ETag 的优先级更高，其能识别以下情况</li><li>没有修改文件内容情况下文件的最后修改时间可能也会改变</li><li><code>If-Modified-Since</code> 能检查到的粒度是秒级的，ETag比其更精细</li><li><strong>配合Cache-Control 字段来使用（过期），只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong></li></ul><h2 id="HTTP-1-1-特性"><a href="#HTTP-1-1-特性" class="headerlink" title="HTTP&#x2F;1.1 特性"></a>HTTP&#x2F;1.1 特性</h2><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>简单、易于扩展、广泛</li><li>无状态（减轻服务器负担、关联性的操作时麻烦）-&gt;cookie、明文传输、不安全（不验证身份信息、不防篡改）</li></ul><h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><p><strong>Https：</strong></p><ul><li>SSL&#x2F;TLS 安全协议，使得报文能够加密传输</li><li>HTTPS 在 TCP 三次握手之后，还需进行 <strong>SSL&#x2F;TLS 的握手过程</strong></li><li>端口号不同</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li></ul><p><strong>解决哪些问题？</strong></p><ul><li>数据泄漏-混合加密（非对称+对称）<ul><li>在通信<strong>建立前采用非对称加密</strong>的方式交换「会话秘钥」<ul><li>公钥加密，私钥解密、耗性能</li></ul></li><li>在<strong>通信过程中</strong>全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据<ul><li>速度快、需要保证密匙不泄露</li></ul></li></ul></li><li>数据篡改-摘要算法+数字签名<ul><li>哈希函数来计算出内容的哈希值（指纹）（单向）-接收方同样计算后匹配</li><li><strong>不能保证「内容 + 哈希值」不会被中间人替换</strong><ul><li>数字签名：私钥加密（<strong>对内容的哈希值加密</strong>），公钥解密</li></ul></li></ul></li><li>身份冒充-数字证书<ul><li>如果私钥和公钥是伪造的-&gt;<strong>接收方误认为签名是发送方的</strong>（也能解密）</li><li>接收方去找CA注册数字证书（身份信息+公钥），CA拿自己私钥签名（这是个好人），接收方给发送方证书（我是好人），发送方拿CA公钥解密（含接收方的身份信息和公钥），拿接收方的公钥加密+自己证书，接收方验证证书、自己私钥解密</li></ul></li></ul><h2 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h2><p><strong>RSA算法</strong>-密钥交换算法</p><ul><li><p>客户端发送（TLS版本）、自身随机数、支持的加密算法</p></li><li><p>服务器端确认版本，发送自身随机数、选好加密算法、还有自己的证书</p></li><li><p>客户端验证证书、拿服务器公钥加密新随机数、发送握手结束信息</p></li><li><p>客户端和服务器将三个随机数生成密钥、握手结束通知</p></li><li><p><strong>缺陷：</strong>一旦服务器的私钥被盗了就G了</p></li></ul><p><strong>证书验证信任链：</strong></p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/%E8%AF%81%E4%B9%A6%E9%93%BE.png" alt="img"></p><p><strong>确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题</strong></p><h2 id="如何保证完整性？"><a href="#如何保证完整性？" class="headerlink" title="如何保证完整性？"></a>如何保证完整性？</h2><ul><li>原始数据被切割-&gt;原始数据+（哈希函数（原始数据）+密钥）-&gt;消息摘要&#x3D;<strong>消息认证码</strong>MAC)</li><li>接收方对接收数据哈希算法对比MAC，保证完整性。再对原始数据进行哈希获得消息摘要，对比</li></ul><h2 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h2><ul><li><p>HTTP&#x2F;1.1</p><ul><li>短连接</li></ul></li><li><p>HTTP&#x2F;1.1</p><ul><li><p>长连接、支持管道（一直发）</p></li><li><p>纯文本形式的报文</p></li><li><p><strong>缺点：</strong>发送队头阻塞（依赖接收方能力）-请求响应模型&#x2F;头部未压缩</p></li></ul></li><li><p>HTTP&#x2F;1.2</p><ul><li>头部压缩<ul><li><code>HPACK</code> 算法-收发维护头部索引表，有重复头只需要发索引</li></ul></li><li>二进制发送（对计算机友好）</li><li>多个 Stream（封装了1.1的请求-响应报文（含多个frame-二进制压缩）） 复用在一条 TCP 连接-接收端根据StreamId重组</li><li>服务器端可用<strong>主动</strong>发<ul><li>客户端建立的 Stream 必须是<strong>奇数号</strong>，而服务器建立的 Stream 必须是偶数号</li></ul></li><li><strong>缺点：</strong>重组如果丢包，所有其他包需等其重传（阻塞）</li></ul></li><li><p>HTTP&#x2F;1.3</p><ul><li>QUIC 协议（<strong>伪</strong> TCP + TLS + HTTP&#x2F;2 的多路复用）</li><li>无队头阻塞（各stream独立，无需等前面stream接收完整）</li><li>握手过程只需要 1 RTT</li><li><strong>连接迁移</strong>（IP变化时消除连接成本）</li></ul></li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/27-HTTP3.jpeg" alt="HTTP/1 ~ HTTP/3"></p><h2 id="既然有-HTTP-协议，为什么还要有-RPC？"><a href="#既然有-HTTP-协议，为什么还要有-RPC？" class="headerlink" title="既然有 HTTP 协议，为什么还要有 RPC？"></a>既然有 HTTP 协议，为什么还要有 RPC？</h2><p><strong>定义：</strong>RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。-<strong>像调用本地方法一样调用远程方法</strong>，常用于微服务架构</p><p><strong>出现原因：</strong></p><p>TCP基于字节流-&gt;无边界-&gt;黏包，于是就有了各种协议，<strong>HTTP 和各类 RPC 协议</strong>就是在 TCP 之上定义的应用层协议</p><p><strong>特点：</strong></p><ul><li>一般会有专门的<strong>中间服务</strong>去保存服务名和IP信息（类别DNS）</li><li>长连接+连接池（便于连接复用）</li><li>二进制格式</li></ul><h2 id="既然有-HTTP-协议，为什么还要有-WebSocket？"><a href="#既然有-HTTP-协议，为什么还要有-WebSocket？" class="headerlink" title="既然有 HTTP 协议，为什么还要有 WebSocket？"></a>既然有 HTTP 协议，为什么还要有 WebSocket？</h2><p>需求：<strong>服务器主动发消息给客户端的场景</strong></p><p>场景：</p><ul><li>短轮询：扫前端二维码<ul><li>出现卡顿（轮询有间隔）</li></ul></li><li>长轮询：百度网盘二维码、Rabbit消息队列<ul><li>超时间隔增大</li></ul></li></ul><p><strong>出现原因：</strong>HTTP&#x2F;1.1 半双工-以前的需求不考虑网页广告这种（服务器主动）-》**基于TCP的新协议 **WebSocket</p><p><strong>过程：</strong>打开需要双工的页面需要升级协议（http-&gt;WebSocket）</p><ul><li>HTTP 请求里带上一些<strong>特殊的header 头</strong>（升级协议）</li><li><strong>三次TCP握手之后</strong>，跟http就没关系了</li></ul><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/format,png-20230309230534096.png" alt="TCP 头格式"></p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/format,png-20230309230439961.png" alt="UDP 头部格式"></p><p><strong>TCP 和 UDP 可以使用同一个端口吗？</strong></p><p>传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。能找到就行，应用程序分别监听TCP&#x2F;UDP的端口。也就是说尽管端口号范围是重叠的也不会影响收发</p><h2 id="三次握手流程"><a href="#三次握手流程" class="headerlink" title="三次握手流程"></a>三次握手流程</h2><ul><li>客户端随机序号，SYN&#x3D;1  （SYN_SENT）</li><li>服务端随机序号，确认应答+1(下一个可接受的序号为)，SYN&#x3D;1,ACK&#x3D;1  (SYN_RCVD)</li><li>客户端确认应答+1，ACK&#x3D;1 (ESTABILISHED)</li><li>TCP协议允许第三次握手携带数据（连接此时已基本建立）</li></ul><p><strong>为什么是三次握手？不是两次、四次？</strong></p><ul><li><strong>防止「历史连接」初始化了连接</strong>&#x2F;同步双方初始序列号<ul><li>客户端可用判断确认号的序号判断建立是不是最新的连接，而选择是否发送 RST 报文结束连接</li><li><strong>两次连接没有这个过程</strong>，在客户端发送RST之前，服务器端可一直发送数据<strong>，浪费资源</strong></li></ul></li></ul><p><strong>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</strong></p><ul><li>避免历史数据混淆</li><li>防止重放攻击</li><li>序号生成ISN &#x3D; M（时钟递增参数） + F(localhost, localport, remotehost, remoteport)哈希</li><li>序号有可能回绕+时间标识，小于时间标识认为是旧的</li></ul><p><strong>既然 IP 层会分片，为什么 TCP 层还需要 MSS（1460-不带头） 呢？</strong>（1460+20+8+12&#x3D;1500）</p><ul><li>如果靠IP分片，丢失一次，所有分片都要重传；如果TCP用MSS，每次只要重传分片所含的那个报文</li></ul><p><strong>第一次握手丢失了，会发生什么？</strong></p><ul><li>设定最大重传次数（每次重传隔2^n秒） 客户端重传</li></ul><p><strong>第二次握手丢失了，会发生什么？</strong></p><ul><li>设定最大重传次数（每次重传隔2^n秒）-客户端+服务端 都重传</li></ul><p><strong>第三次握手丢失了，会发生什么？</strong></p><ul><li>设定最大重传次数（每次重传隔2^n秒） 服务端重传</li></ul><p><strong>什么是 SYN 攻击？如何避免 SYN 攻击？</strong></p><p>linux维护两个队列：半连接&#x2F;全连接</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/format,png-20230309230622886.png" alt="正常流程"></p><p><strong>被攻击：</strong>一直发SYN，SYN一直等ACK，<strong>半开放连接队列满了，后续再在收到 SYN 报文就会丢弃</strong></p><p><strong>解决方案：</strong></p><ul><li>SYN Cookie技术<ul><li>服务器收到SYN不分配资源，而是生成cookies返回客户端，客户端ack带上cookies验证</li></ul></li><li>增大 TCP 半连接队列</li><li>减少重传次数</li></ul><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p><p><strong>为什么挥手需要四次？</strong></p><p><strong>FIN表示：我不发了，但是我还能收</strong></p><p><strong>ACK：我晓得了</strong></p><p><strong>第一次挥手丢失了，会发生什么？</strong></p><ul><li>重传-超次数后 客户端closed</li></ul><p><strong>第二次挥手丢失了，会发生什么？</strong></p><ul><li>重传-超次数后 客户端closed</li></ul><p><strong>第三次挥手丢失了，会发生什么？</strong></p><ul><li>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数。重传-超次数后 服务端closed—客户端FIN_WAIT2等超时后也closed</li></ul><p><strong>第四次挥手丢失了，会发生什么？</strong></p><ul><li>客户端拿到FIN开始TIME_WAIT （2MSL），服务器拿不到ACK一直重传FIN，客户端每次拿到FIN刷新时间2MSL， 服务端超重传次数closed，客户端超2MSL closed</li></ul><p><strong>为什么需要 TIME_WAIT 状态？</strong></p><ul><li><p>序号循环使用，新连接收到的包可能是旧连接发来的识别不了（2MSL可用保证无论客户端发的包还是服务端发的包都已经GG了）</p></li><li><p>尽量保证最后的ACK能到达服务端（给服务端发现丢失重传FIN的机会）</p></li></ul><p><strong>TIME_WAIT 过多有什么危害？</strong></p><ul><li><p><strong>端口资源耗尽</strong>：每个TCP连接都需要使用一个端口 新连接无法建立</p></li><li><p><strong>系统性能下降：</strong>内存占用、cpu占用</p></li></ul><p><strong>TIME_WAIT 大量的原因</strong></p><ul><li>大量短连接</li><li>长连接超时</li><li>HTTP 长连接的请求数量达到上限</li></ul><p><strong>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</strong>（FIN发不出来，服务端的程序没有调用 close 函数关闭连接）</p><p>TCP服务端各步骤出现问题：</p><ul><li>创建服务端 socket，bind 绑定端口、listen 监听端口</li><li>将服务端 socket 注册到 epoll<ul><li><strong>Epoll</strong> 是 Linux 提供的一种高效的 I&#x2F;O 多路复用机制，用于同时监控多个文件描述符（如套接字、文件等），以确定哪些文件描述符已经准备好进行 I&#x2F;O 操作</li></ul></li><li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket<ul><li><code>epoll_wait</code> 阻塞等待 Epoll 实例中的事件。当有文件描述符准备好进行 I&#x2F;O 操作时，<code>epoll_wait</code> 会返回这些文件描述符及其对应的事件类型</li></ul></li><li>将已连接的 socket 注册到 epoll</li><li>epoll_wait 等待事件发生</li><li>对方连接关闭时，我方调用 close</li></ul><p><strong>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</strong></p><p>内核负责四次挥手</p><p><strong>没有 accept，能建立 TCP 连接吗？</strong></p><p>accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/3.jpg" alt="半连接队列与全连接队列"></p><h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><ul><li>超时重传（计时器）<ul><li>不好确定时间</li></ul></li><li>快速重传（客户端连续接收3个相同的ACK重传）<ul><li>无法判断需要重传的包数量</li></ul></li><li>选择性确认（接收方标识给发送方已收到的包）</li><li>Duplicate SACK 重复选择性确认（标识重复收到的包）<ul><li>对面网络延时，导致ack误会让它重发</li><li>ack丢包</li></ul></li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul><li>窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值</li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>让「发送方」根据「接收方」的实际接收能力控制发送的数据量</p><ul><li>发送方和接收方通过 SYN 和 ACK 消息交换初始窗口大小</li><li>发送方根据 SNDWND 发送数据，接收方接收数据并存储在缓冲区，，接收方通过确认消息（ACK）告知发送方其缓冲区的可用空间</li><li>接收方的缓冲区逐渐填满，接收窗口大小逐渐减小。发送方根据接收窗口大小动态调整发送窗口大小，减少发送速率</li><li>接收方的缓冲区满了，接收窗口大小设置为 0，发送方等待发送</li><li>窗口大小&#x3D;缓存队列大小（OS可变）-未被处理的数据大小</li></ul><p><strong>TCP不允许先减少缓存再收缩窗口-如果先减少，按着旧窗口大小会有溢出的情况</strong></p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p><strong>拥塞窗口控制：</strong></p><ul><li>swnd &#x3D; min(cwnd, rwnd)</li><li>随着拥塞情况（接收ack情况）变化而变化</li></ul><p><strong>控制算法</strong></p><ul><li>慢启动<ul><li><strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1</strong> –&gt;指数增长</li><li>超慢门限启动拥塞避免</li></ul></li><li>拥塞避免<ul><li>+1 线性增长</li></ul></li><li>拥塞发生-重传<ul><li>超时重传<ul><li>ssthresh &#x3D;cwnd&#x2F;2 cwnd重置未为1</li></ul></li><li>快速重传（接收3个ack）–<strong>网络没那么糟糕，不用直接置1</strong><ul><li>cwnd &#x3D; cwnd&#x2F;2+ssthresh&#x3D;cwnd+快速恢复</li></ul></li></ul></li><li>快速恢复<ul><li>拥塞窗口 cwnd &#x3D; ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；（<strong>尽快恢复，能收到ack意味着可能是流量控制那边问题，网络还好</strong>）</li><li>如果收到新数据的 ACK 后，把 <strong>cwnd 设置为第一步中的 ssthresh</strong> 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul></li></ul><p><strong>TCP 是面向字节流的协议，UDP 是面向报文的协议？这里的「面向字节流」和「面向报文」该如何理解。</strong></p><ul><li>TCP不保留报文的边界。发送方将数据分割成多个 TCP 段</li><li>UDP 将数据视为独立的报文，每个报文都携带完整的信息。发送方将数据分割成多个 UDP 报文，并通过网络发送这些报文。</li></ul><p><strong>TCP的黏包问题</strong>–应用层处理</p><ul><li>固定长度</li><li>消息分割符（包内有的话加转义）</li><li>长度标识</li></ul><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/7.jpg" alt="IP 地址分类"></p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/8.jpg" alt="img"></p><p><strong>无分类地址 CIDR</strong>：a.b.c.d&#x2F;x</p><p><strong>子网掩码</strong></p><p><strong>RARP 协议你知道是什么吗？</strong></p><ul><li>已知 MAC 地址求 IP 地址（打印机服务器）</li></ul><p><strong>DHCP：</strong></p><ul><li>客户端首先发起 DHCP 发现报文（DHCP DISCOVER）（广播）-你在哪</li><li>DHCP 提供报文（DHCP OFFER） 向客户端做出响应（广播）-我在着，可分配的IP是</li><li><strong>DHCP 请求报文</strong>，单点-OK我要这个了</li><li>响应 -ok</li></ul><p><strong>NAT：</strong></p><ul><li>两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的<strong>端口号</strong>作为区分</li></ul><p><strong>ICMP：</strong></p><ul><li><p><strong>回送消息</strong>用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，ping 命令就是利用这个消息实现-端主机发送<strong>回送请求</strong>的消息（类型8），端主机发回来的<strong>回送应答</strong>（类型0）</p></li><li><p>一类是用于<strong>诊断</strong>的查询消息，也就是「查询报文类型」</p></li><li><p>另一类是通知出错原因的错误消息，也就是「差错报文类型」</p></li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/9.jpg" alt="目标不可达类型的常见代码号"></p><blockquote><p>重定向消息（ICMP Redirect Message） —— 类型 <code>5</code>（通过它告诉主机有更好的路由）</p><p>超时消息（ICMP Time Exceeded Message） —— 类型 <code>11</code></p></blockquote><h2 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h2><p>基于 ICMP 协议（<strong>ICMP 回送请求消息</strong>-类型8）</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E8%AE%A1%E7%BD%91/13.jpg" alt="主机 A 的 ICMP 回送请求报文"></p><ul><li><p>会自动加 <code>1</code>。为了能够计算往返时间 <code>RTT</code>，加入发送时间</p></li><li><p>主机 <code>B</code> 会构建一个 <strong>ICMP 回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为 <code>0</code></p></li></ul><h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><ul><li><strong>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器</strong>（TTL分别设置1，2，3…）<ul><li>traceroute 在发送 <code>UDP</code> 包时，会填入一个<strong>不可能的端口号</strong>（故意找错找返回的借口），目的主机收到 UDP 包后，会返回 ICMP 差错报文消息类型是「<strong>端口不可达」</strong></li></ul></li><li><strong>路径MTU发现</strong>（找最优MTU）-&gt;故意设置不分片，从而确定路径的 MTU<ul><li>将 <code>IP</code> 包首部的<strong>分片禁止标志位设置为 1</strong></li><li>路由器返回不可达消息的类型为「<strong>需要进行分片但设置了不分片位</strong>」+MTU信息</li><li>发送方收到后减小MTU</li></ul></li></ul><h2 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"><a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="headerlink" title="127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗"></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h2><ul><li>localhost 就不叫 IP，它是一个域名，默认会把它解析为 127.0.0.1</li><li>listen 的是本机的 0.0.0.0 , 那么它表示本机上的所有IPV4地址。服务器 listen 的是 0.0.0.0，那么此时用127.0.0.1和本机地址都可以访问到服务</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;键入网址到网页显示，期间发生了什么？&quot;&gt;&lt;a href=&quot;#键入网址到网页显示，期间发生了什么？&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试篇-并发</title>
    <link href="https://senwh.github.io/2025/02/25/%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/"/>
    <id>https://senwh.github.io/2025/02/25/%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/</id>
    <published>2025-02-25T05:13:41.000Z</published>
    <updated>2025-02-27T13:11:34.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="进程和线程的区别："><a href="#进程和线程的区别：" class="headerlink" title="进程和线程的区别："></a><strong>进程和线程的区别：</strong></h2><p><strong>进程：</strong>当一个程序被运行，从磁盘加载代码至内存，开启一个进程（加载指令，管理内存，IO），系统资源分配的最小单位</p><p><strong>线程：</strong>运算调度的最小单位</p><ul><li>进程是正在运行的实例，包含多个线程，每个线程执行不同任务</li><li>不同进程使用不同内存空间，一个进程内线程共享内存空间</li><li>线程上下文切换成本更低</li></ul><h2 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h2><p>并发：线程一段时间内，轮流使用CPU</p><p>并行：多个线程在不同核心同时工作</p><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><ul><li><p>继承Thread类</p><ul><li><p>t1 &#x3D; new Thread()  t1.start</p></li><li><p>单继承限制</p></li><li><p>Thread底层代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Thread implements Runnable </span><br></pre></td></tr></table></figure></li></ul></li><li><p>实现Runnable类，重写run方法</p><ul><li>new Thread(Runable对象) 对象内容run方法定义了需要执行的任务</li><li>Java 不支持多继承，但一个类可以实现多个接口。通过实现 <code>Runnable</code> 接口，你可以让<strong>一个类同时继承其他类</strong>(假装继承，其实是将方法封装到接口中，实现了不同的接口从而解决不同的任务)：例: public class Worker extends Employee implements Runnable</li><li>多个线程可以<strong>共享同一个 <code>Runnable</code> 实例</strong>，从而实现线程的复用</li></ul></li><li><p>Callable 接口和 Future </p><ul><li><pre><code class="java">        MyCallable myCallable = new MyCallable();        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(myCallable);              new Thread(futureTask).start(); // 启动线程              try &#123;            Integer result = futureTask.get(); // 获取线程返回的结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 线程池</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    ExecutorService pool = Executors.newFixedThreadPool(2); // 创建一个固定大小的线程池</span><br><span class="line">    </span><br><span class="line">            pool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;任务1正在运行，当前线程名称：&quot; + Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><table><thead><tr><th align="left">创建方式</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">继承 <code>Thread</code> 类</td><td align="left">简单直接</td><td align="left">单继承限制</td></tr><tr><td align="left">实现 <code>Runnable</code> 接口</td><td align="left">避免单继承限制，适合多线程复用</td><td align="left">线程逻辑和线程控制分离</td></tr><tr><td align="left">使用 <code>Callable</code> 和 <code>Future</code></td><td align="left">支持返回值和异常处理</td><td align="left">代码复杂度较高</td></tr><tr><td align="left">使用线程池</td><td align="left">性能优化，资源复用</td><td align="left">需要管理线程池的生命周期</td></tr></tbody></table><h2 id="runnable和callable区别？"><a href="#runnable和callable区别？" class="headerlink" title="runnable和callable区别？"></a><strong>runnable和callable区别？</strong></h2><ul><li>Ruannble run方法无返回值</li><li>Callable 接口call方法右返回值和Futue、FutureTask可以获取异步执行结果</li><li>Callable 接口call运行抛出异常；Runnable的run方法异常只能内部消化</li></ul><h2 id="线程的run方法和start方法有什么不同？"><a href="#线程的run方法和start方法有什么不同？" class="headerlink" title="线程的run方法和start方法有什么不同？"></a><strong>线程的run方法和start方法有什么不同？</strong></h2><ul><li>start（）:启动线程，调用run方法，只能调用一次</li><li>run（）: 普通方法，任务执行代码本身，可以调用多次</li></ul><h2 id="线程状态及状态切换"><a href="#线程状态及状态切换" class="headerlink" title="线程状态及状态切换"></a><strong>线程状态及状态切换</strong></h2><p> <img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/status.png" alt="image-20250225135656930"></p><h1 id="保证线程顺序执行"><a href="#保证线程顺序执行" class="headerlink" title="保证线程顺序执行"></a><strong>保证线程顺序执行</strong></h1><p>在B线程执行A.join()-即等待A执行完后B（WAITING）才执行</p><p>notify():随机唤醒一个wait()线程</p><p>notifyall()：唤醒所有wait()线程</p><h2 id="wait和sleep方法的异同"><a href="#wait和sleep方法的异同" class="headerlink" title="wait和sleep方法的异同"></a><strong>wait和sleep方法的异同</strong></h2><ul><li><p>方法归属不同：sleep是Thread的静态方法 ，wait（）是对象的成员方法</p></li><li><p>醒来时机不同：wait()需要被唤醒，wait（long）可以被唤醒也可以等</p></li><li><p>锁特性不同</p><ul><li>wait方法调用先获得wait对象锁，执行后释放对象锁</li><li>sleep如果在synchronized执行，不会主动释放对象锁</li></ul></li></ul><h2 id="如何停止正在运行的线程"><a href="#如何停止正在运行的线程" class="headerlink" title="如何停止正在运行的线程"></a><strong>如何停止正在运行的线程</strong></h2><ul><li>线程定义退出标志，线程内部run方法循环读标志，当外部修改标志后线程停止</li><li>调用stop强行中止</li><li>调用interrupt中的中断线程<ul><li>打断阻塞线程抛异常</li><li>打断正常线程-手动用标志位退出while循环（isinterrupted（）返回标志位）</li></ul></li></ul><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><code>java.lang.Object</code> 是 Java 中所有类的父类，<code>synchronized</code> 是 Java 提供的一种内置锁（Intrinsic Lock），用于实现线程同步。它的实现基于<strong>对象的监视器</strong>（Monitor）和 Java <strong>内存模型</strong>（JMM）</p><p><strong>对象头：</strong>每个对象在内存中都包含一个对象头，对象头是 JVM 用于存储对象相关数据的区域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 对象头结构</span><br><span class="line">Mark Word（对象的哈希码、 GC 分代年龄、锁标志状态） | Klass Pointer（指向对象所属的类） | value（数组的长度）</span><br></pre></td></tr></table></figure><p>![image-20250225193531038](.&#x2F;面试篇-并发&#x2F;mark word.png)</p><p><strong>Monitor</strong>：每个对象都有一个与之关联的 <code>Monitor</code>，当一个线程获取对象的锁时，实际上是获取了该对象的 <code>Monitor</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Monitor 结构</span><br><span class="line">--------------------------------</span><br><span class="line">| Owner Thread（当前持有锁的线程） | Re-entrant Count（锁被持有次数） |</span><br><span class="line">|--------------------------------|</span><br><span class="line">| Entry Set (Threads Waiting for Lock) |</span><br><span class="line">|--------------------------------|</span><br><span class="line">| Wait Set (Threads Waiting via wait()) |</span><br><span class="line">--------------------------------</span><br></pre></td></tr></table></figure><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/lock-1.png" alt="image-20250225193301652"></p><p><strong>锁的升级和优化</strong></p><p><strong>锁的状态</strong>–JVM会根据下述场景，将锁升级，以平衡性能开销</p><ul><li><p>无锁</p></li><li><p>偏向锁：偏向第一个获取锁的线程，记录线程 ID-不用再回核心态&#x2F;如果其他线程尝试获取锁，偏向锁被撤销，升级为轻量级。–JDK1.6</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/lock-3.png" alt="image-20250225195117203"></p></li><li><p>轻量级锁：不偏向 +CAS操作&#x2F;如果多次 CAS 失败(如果在该线程读取变量值之后、执行 CAS 操作之前，其他线程修改了变量的值，那么 CAS 操作会失败)，锁升级为重量级锁 –JDK1.6 <strong>不用到内核态</strong></p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/lock-2.png" alt="image-20250225195000352"></p></li><li><p>重量级锁：存在多个线程竞争&#x2F;互斥锁机制竞争锁–<strong>Monitor</strong>–<strong>涉及用户态&#x2F;内核态切换</strong></p><ul><li><p><strong>获取锁流程：</strong></p><ul><li><strong>检测锁状态（Mark Word）：</strong>是否被其他线程持有。若无则CAS尝试写入线程Id</li><li><strong>锁竞争：</strong>若已被其他线程上锁，则写入Monitor排队</li><li><strong>可重入性：</strong>在已持有锁情况下继续获得锁，Re-entrant Count++，锁释放则继续执行</li></ul><p><strong>释放锁：</strong></p><ul><li>执行完一遍Re-entrant Count– ，计数器到0则释放</li><li>Monitor从等待队列中取线程</li></ul></li></ul></li></ul><h2 id="JMM（java-memory-model）"><a href="#JMM（java-memory-model）" class="headerlink" title="JMM（java memory model）"></a>JMM（java memory model）</h2><p><strong>定义：</strong>定义了共享内存中多线程程序读写操作的行为规范</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/memory.png" alt="image-20250225200701858"></p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>乐观锁思想：乐观的估计，被修改了也没事，重新读共享内存数据，继续重试。</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/CAS.png" alt="image-20250225201444337"></p><ul><li>CAS（compare and Swap）,将两个步骤（检查条件和更新值）合并成一条硬件指令，速度快，避免上下文切换-自旋锁的实现，忙等待（适合执行时间很短的代码-可以很快释放锁）</li><li>CAS用于乐观锁实现-无锁编程-基于原子操作实现</li><li><strong>局限ABA问题：</strong>假设一个线程 A 想要将变量 <code>x</code> 的值从 <code>10</code> 更新为 <code>20</code>，但它在执行 CAS 操作之前，变量 <code>x</code> 的值被其他线程修改为 <code>15</code>，然后又被修改回 <code>10</code>。此时，线程 A 的 CAS 操作会成功，因为它检查到的当前值仍然是 <code>10</code>。然而，实际上变量 <code>x</code> 的值已经发生了变化，这可能导致逻辑错误—-<strong>库存-50 补货+50 逻辑上却认为没出售过和没 补过货</strong></li><li>底层调用的是Unsafe类的方法，由操作系统提供</li></ul><h2 id="谈谈对volatile理解"><a href="#谈谈对volatile理解" class="headerlink" title="谈谈对volatile理解"></a>谈谈对volatile理解</h2><p>用于确保变量的 <strong>可见性</strong> 和 <strong>有序性</strong>。它主要用于多线程环境下，保证一个线程对变量的修改能被其他线程<strong>立即看到</strong></p><p>可见性：线程A修改变量，线程B可能访问的是过期的值</p><ul><li>线程的工作内存存了变量过期的缓存</li><li>JVM虚拟机里的JIT（即时编译器）优化了代码 ！stop&#x3D;&#x3D;true</li></ul><p>重排序：编译器、处理器为了优化程序性能，对指令执行顺序进行调整的一种行为-导致数据不一致</p><p>给变量加volatile可以解决上述问题：底层原理是<strong>基于内存屏障</strong>（确保<strong>屏障之前的指令不会被重排序到屏障之后</strong>，屏障之后的指令也不会被重排序到屏障之前）和对编译器&#x2F;<strong>处理器优化的限制</strong>–针对共享线程变量</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/volatile.png" alt="image-20250225204747837"></p><h2 id="什么是AQS（AbstractQueuedSynchronizer）"><a href="#什么是AQS（AbstractQueuedSynchronizer）" class="headerlink" title="什么是AQS（AbstractQueuedSynchronizer）"></a>什么是AQS（AbstractQueuedSynchronizer）</h2><ul><li>一种锁机制，作为一个基础框架使用（ReentrantLock\Semaphore用其实现），公平锁&#x2F;非公平锁都可以实现</li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/AQS.png" alt="image-20250226125853358"></p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/AQS-2.png" alt="image-20250226125928183"></p><p>公平锁：新来线程乖乖排队 </p><p>非公平锁：新的线程抢占队列头线程资源</p><h2 id="ReentrantLock（可重入锁）原理"><a href="#ReentrantLock（可重入锁）原理" class="headerlink" title="ReentrantLock（可重入锁）原理"></a>ReentrantLock（可重入锁）原理</h2><p>CAS+AQS，支持公平锁&#x2F;非公平锁（默认）</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/ReentrantLock.png" alt="image-20250226130522047"></p><h2 id="synchronized-和Lock-区别"><a href="#synchronized-和Lock-区别" class="headerlink" title="synchronized 和Lock 区别"></a>synchronized 和Lock 区别</h2><p><strong>使用</strong>：C++底层实现 &#x2F; Java-需要显示获得释放锁</p><p><strong>功能</strong>：独占锁&#x2F;提供多种锁类型（ReetrantLock）</p><p><strong>性能：</strong>简单场景锁升级&#x2F;复杂场景比前者重量级性能好</p><h2 id="死锁产生条件"><a href="#死锁产生条件" class="headerlink" title="死锁产生条件"></a>死锁产生条件</h2><p><strong>必要条件及预防：</strong></p><ul><li>互斥<ul><li>资源共享</li><li>资源复制</li></ul></li><li>请求保持<ul><li>一次性分配</li><li>资源剥夺</li></ul></li><li>不剥夺<ul><li>允许剥夺（优先级）</li><li>时间片轮转</li></ul></li><li>循环等待<ul><li>编号有序分配</li><li><strong>银行家算法</strong></li></ul></li></ul><p><strong>死锁检测：</strong></p><ul><li><strong>资源图分配</strong></li><li>jdk自带工具<ul><li>jps命令查看JVM运行进程PID</li><li>jstack -l 进程PID 查看进程内线程信息</li></ul></li></ul><p><strong>解决方案：</strong></p><ul><li><strong>资源剥夺</strong>：选择一个或多个进程，剥夺其持有的资源，分配给其他进程。</li><li><strong>终止进程</strong>：选择一个或多个进程，终止它们的执行，释放其持有的资源。</li><li><strong>重新启动</strong>：在某些情况下，可能需要重新启动系统以清除死锁状态。</li></ul><h2 id="聊一下ConcureentHashMap"><a href="#聊一下ConcureentHashMap" class="headerlink" title="聊一下ConcureentHashMap"></a>聊一下ConcureentHashMap</h2><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/conHP-1.png" alt="image-20250226135637272"></p><p><strong>多个线程hash一个segment的时候，要等待锁，性能下降</strong></p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/conHP-2.png" alt="image-20250226135857142"></p><p>JDK1.8，每个节点（Bucket）用synchronized锁链表&#x2F;二叉树首节点</p><h2 id="并发程序出现问题的根本原因"><a href="#并发程序出现问题的根本原因" class="headerlink" title="并发程序出现问题的根本原因"></a>并发程序出现问题的根本原因</h2><p><strong>java并发三大特征</strong></p><ul><li>原子性<ul><li>synchronized&#x2F;JUC里的lock加锁</li></ul></li><li>可见性<ul><li>volatile&#x2F;锁</li></ul></li><li>有序性<ul><li>volatile</li></ul></li></ul><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="核心参数（执行原理）"><a href="#核心参数（执行原理）" class="headerlink" title="核心参数（执行原理）"></a>核心参数（执行原理）</h2><p>ThreadPoolExecutor(核心线程数量，最大线程数量（核心+救急线程），救急线程生存时间，时间单位，工作队列（无空闲核心线程时加入，满了就开救急线程），线程工厂，拒绝策略（需&gt;求）)</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/pool.png" alt="image-20250226183313081"></p><p>注意救急队列出手的时机：</p><ul><li>核心线程执行完</li><li>阻塞队列满之后再进线程&amp;&amp;线程数&lt;&#x3D;最大线程数–此时执行最新的线程，再去找阻塞队列</li></ul><h2 id="线程池常见的阻塞队列"><a href="#线程池常见的阻塞队列" class="headerlink" title="线程池常见的阻塞队列"></a>线程池常见的阻塞队列</h2><p><strong>ArrayBlockingQueue</strong></p><p><strong>LinkedBlockingQueue</strong></p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E5%B9%B6%E5%8F%91/pool-1.png" alt="image-20250226185125593"></p><p>DelayedWorkQueue:优先队列（短时间优先）</p><p>SynchronousQueue:不存储元素，每次插入必须等一个移出</p><h2 id="如何使用核心线程数"><a href="#如何使用核心线程数" class="headerlink" title="如何使用核心线程数"></a>如何使用核心线程数</h2><p>IO密集任务：2N+1 在大量IO任务时，很多线程会被阻塞，多点线程才能为CPU所用</p><p>CPU密集型：N+1 如果线程数过多，会增加CPU的上下文切换开销（<strong>操作系统频繁切换线程</strong>来分配时间片），影响性能</p><p>N为cpu数量</p><h2 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h2><p><strong>固定线程数</strong> newFixedThreadPool</p><ul><li>无救急线程</li><li>阻塞队列LinkedBlockingQueue 最大容量Integer.MAX_VALUE</li><li>适用于任务量比较平稳，需要限制并发线程数的场景，如服务器端处理客户端请求。</li></ul><p><strong>单线程化的线程池：</strong>SingleThreadExecutor 唯一工作线程（核心）</p><ul><li><p>LinkedBlockingQueue</p></li><li><p>适用顺序执行任务</p></li><li><p>适用于需要保证任务按顺序执行的场景，如串行处理日志记录等</p></li></ul><p><strong>可缓存线程池：</strong>无核心线程（靠急救线程）</p><ul><li>synchronous底层</li><li>线程池中的线程数可以<strong>无限增加</strong>（受系统资源限制），但会复用空闲线程。</li><li>如果线程空闲时间超过60秒，则会被终止并从缓存中移除。</li><li>适合执行大量的耗时较少的任务，特别是对于那些执行时间不确定的短期异步任务。</li></ul><p><strong>提供延迟和周期执行的线程池：</strong></p><ul><li><p>DelayedWorkQueue</p></li><li><p>适用于需要执行周期性任务的场景，如定时清理缓存、定时调度任务等。</p></li></ul><h2 id="为什么不建议用上面的几种Executor创建的线程池？"><a href="#为什么不建议用上面的几种Executor创建的线程池？" class="headerlink" title="为什么不建议用上面的几种Executor创建的线程池？"></a>为什么不建议用上面的几种Executor创建的线程池？</h2><ul><li>前两者阻塞最大长度允许Integer.MAX_VALUE，缓存线程池救急线程最大也到</li></ul><p>Integer.MAX_VALUE，很容易导致内存溢出</p><ul><li><strong>ThreadPoolExecutor根据任务自定义</strong></li></ul><h2 id="谈谈对TheadLocal的理解"><a href="#谈谈对TheadLocal的理解" class="headerlink" title="谈谈对TheadLocal的理解"></a>谈谈对TheadLocal的理解</h2><p><strong>基本概念：</strong>TheadLocal是一个线程局部变量的存储类。它允许每个线程拥有自己的变量副本，这些副本存储在每个线程的TheadLocalMap中</p><p><strong>工作原理：</strong></p><ul><li>内部使用TheadLocalMap存储线程与变量的键值对，键是TheadLocal对象本身，值是传入的value（变量副本）</li><li>set()，get()，remove（）</li></ul><p><strong>应用场景：</strong></p><ul><li>多线程环境下，当某些变量不需要在多个线程之间共享（存储与请求相关的上下文信息，如用户身份信息、请求的开始时间等）</li></ul><p><strong>其内存泄漏问题：</strong></p><ul><li>其key继承了<strong>WeakReference</strong>，为弱引用，内存不够时会自动回收。其值是Object对象，为强引用。如果线程长期存在（例如在使用线程池时，线程会被复用而不是销毁），那么 <code>ThreadLocalMap</code> 中的值就会一直存在，值越来越多导致内存泄漏。</li><li>需显示remove掉值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;h2 id=&quot;进程和线程的区别：&quot;&gt;&lt;a href=&quot;#进程和线程的区别：&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试篇-集合</title>
    <link href="https://senwh.github.io/2025/02/23/%E9%9D%A2%E8%AF%95%E7%AF%87-%E9%9B%86%E5%90%88/"/>
    <id>https://senwh.github.io/2025/02/23/%E9%9D%A2%E8%AF%95%E7%AF%87-%E9%9B%86%E5%90%88/</id>
    <published>2025-02-23T09:48:00.000Z</published>
    <updated>2025-02-24T14:58:29.430Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E9%9B%86%E5%90%88/collection_1.png" alt="{90A2DF6F-BC50-4AB4-9A8C-C1BA96A29902}"></p><p><strong>复杂度</strong>：常幂对指阶</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="栈内存和堆内存的区别"><a href="#栈内存和堆内存的区别" class="headerlink" title="栈内存和堆内存的区别"></a>栈内存和堆内存的区别</h3><ul><li><strong>存储内容</strong>：<ul><li>栈内存存储局部变量、方法调用和方法参数，包括基本数据类型和对象引用。</li><li>堆内存存储所有通过 <code>new</code> 创建的对象和数组。</li></ul></li><li><strong>生命周期</strong>：<ul><li>栈内存的生命周期与线程的生命周期相关，方法执行完毕后栈内存自动释放。</li><li>堆内存的生命周期从程序启动到程序结束，对象被垃圾回收器自动回收。</li></ul></li><li><strong>分配方式</strong>：<ul><li>栈内存的分配和释放是自动且高效的，由 JVM 直接管理。</li><li>堆内存的分配和释放是由垃圾回收器自动管理的。</li></ul></li><li><strong>灵活性</strong>：<ul><li>栈内存的分配和释放是固定大小的，只能存储局部变量和方法调用的信息。</li><li>堆内存可以动态地分配和释放内存，存储大量的对象和数据。</li></ul></li><li><strong>性能</strong>：<ul><li>栈内存的访问速度快，因为它是连续的内存结构。</li><li>堆内存的访问速度相对较慢，因为它是非连续的内存结构，并且需要进行垃圾回收。</li></ul></li></ul><p>int[] array &#x3D; {a,b,c}</p><ul><li>array作为变量，指向数组首地址，放入栈内存</li><li>数组元素存在堆内存中</li></ul><h3 id="为什么数组索引从0开始？"><a href="#为什么数组索引从0开始？" class="headerlink" title="为什么数组索引从0开始？"></a>为什么数组索引从0开始？</h3><ul><li>数组寻址公式 A[i]&#x3D;baseAddress+i*dataTypeSize，如果索引从1开始就是（i-1）,cpu要做减法操作，多做一次指令，性能下降</li></ul><h3 id="源码逻辑"><a href="#源码逻辑" class="headerlink" title="源码逻辑"></a>源码逻辑</h3><ul><li>add<ul><li>扩容：new &#x3D; old + (old&gt;&gt;1)，增加1.5倍</li><li>扩充完，Arrys.copyOf将元素复制到新的数组</li></ul></li></ul><h3 id="底层实现原理"><a href="#底层实现原理" class="headerlink" title="底层实现原理"></a>底层实现原理</h3><ul><li><p>动态数组（Array）</p><ul><li>底层用了Arrays.copyOf</li></ul></li><li><p>初始数组容量为0，空数据时容量为10</p></li><li><p>最大容量Integer.MAX_VALUE - 8</p><ul><li><strong>2^31 - 1</strong></li></ul></li><li><p>每次扩容1.5倍，每次扩容拷贝数组</p></li><li><p>过程</p><ul><li>size+1与当前数组长度比较</li><li>大于-则grow扩容</li><li>copy完后添加新数据</li><li>返回boolean</li></ul></li></ul><p><strong>new ArrayList（10）扩容了几次？</strong></p><p>分析源码后，只是实例了一个ArrayList没扩容</p><h3 id="如何实现数组和List之间转换？"><a href="#如何实现数组和List之间转换？" class="headerlink" title="如何实现数组和List之间转换？"></a>如何实现数组和List之间转换？</h3><ul><li><p>list-&gt;Arrays –list.toArray(new String(list.size())) ,底层是用的copy，值改变不会同时改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(this.a, 0, a, 0, size);</span><br></pre></td></tr></table></figure><p>底层用java调用C++,复制的快</p></li><li><p>Arrays-&gt;list –Arrays.aslist(a)，直接赋值，值改变另外一个值也变化（共享地址）</p></li></ul><h3 id="ArrayList-和-LinkedList-区别"><a href="#ArrayList-和-LinkedList-区别" class="headerlink" title="ArrayList 和 LinkedList 区别"></a>ArrayList 和 LinkedList 区别</h3><ul><li>底层数据结构</li><li>操作效率</li><li>内存</li><li>非线程安全<ul><li>局部变量是安全的：局部变量存储在方法的<strong>栈帧</strong>中。每个线程都有自己的独立栈帧，栈帧是线程私有的，不会被其他线程访问。因此，局部变量是线程安全的</li><li>Collections.synchronizedList封装</li></ul></li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>红黑树（平衡二叉搜索树）：</strong>左根右，根叶黑，不红红，黑路同</p><p><strong>散列冲突：</strong>拉链法（哈希表的每个槽（bucket）存储一个链表头指针）-当冲突增多-&gt;退化为链表-&gt;改造为红黑树（内存换时间）</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>底层用hash表+链表+红黑树<ul><li>当链个数&gt;&#x3D;8，创建红黑树（如果槽数量小于64，则扩容，继续链表。否则建树）</li><li>链个数&lt;6，退化成链表</li></ul></li><li>扩容：一个哈希表本质为数组 ：Node[ ]<ul><li>懒惰加载，初始未加载数组</li><li>若未大于最大容量，容量为当前容量的两倍，新阈值翻倍</li><li>既未设置初始容量也未设置阈值，则使用默认初始容量<code>DEFAULT_INITIAL_CAPACITY</code>（通常是16），并根据默认负载因子<code>DEFAULT_LOAD_FACTOR</code>（通常是0.75）计算新阈值（数组容量*加载因子）</li><li>**扩容时会拆链表:满足<code>(e.hash &amp; oldCap) == 0</code>结点还在原来位置，否则放到下标[j+oldCap]**（有点再分配的意思）<ul><li><strong>e.hash大家不是一样的吗？为什么新表能在不同位置？</strong></li><li>答：不一样！位置一样hash不一定一样，通过(n - 1) &amp; hash找到下标</li></ul></li></ul></li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E9%9B%86%E5%90%88/resize.png" alt="{13D4762B-0723-43B9-A822-2B6FE00763D8}"></p><ul><li>底层的hash(key) <code>return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code><ul><li>函数算完后拿自己高位和地位做异或运算后放地位-减少哈希冲突 (h &gt;&gt;&gt; 16)-高16为移到低16位，高位全0，hash更平均</li><li><strong>找下标：通过(n - 1) &amp; hash找到下标，n是resize的值</strong></li></ul></li><li>jdk1.8之前无红黑树</li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E9%9B%86%E5%90%88/put.png" alt="{B3634F08-C704-497C-B5BF-3C19F5802E62}"></p><h3 id="为什么HashMap数组长度一定要是2的幂"><a href="#为什么HashMap数组长度一定要是2的幂" class="headerlink" title="为什么HashMap数组长度一定要是2的幂"></a>为什么HashMap数组长度一定要是2的幂</h3><ul><li>在找下标时（计算索引），与运算比取模效率高</li><li>在扩容时拆链表时，重新分配时与运算比+效率高（就位置+旧容量）</li></ul><h3 id="HashMap-JDK1-7-多线程死循环的问题"><a href="#HashMap-JDK1-7-多线程死循环的问题" class="headerlink" title="HashMap JDK1.7 多线程死循环的问题"></a>HashMap JDK1.7 多线程死循环的问题</h3><ul><li>迁移到新表时用的是头插法（故结点会逆序）</li><li>JDK1.8 用尾插法解决</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E9%9B%86%E5%90%88/collection_1.png&quot; alt=&quot;{90A2DF6F-BC50-4AB4-9A8C-C1BA96A29902}&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试篇-消息中间件</title>
    <link href="https://senwh.github.io/2025/02/23/%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://senwh.github.io/2025/02/23/%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2025-02-23T08:26:21.000Z</published>
    <updated>2025-02-23T09:47:37.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/mq.png" alt="{021133AB-663B-41DE-9F76-0902095DF914}"></p><h2 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h2><p><strong>问题：</strong></p><ul><li>生产者宕机，消息未达交换机&#x2F;队列</li><li>mq宕机，队列消息队列</li><li>消费者宕机</li></ul><p><strong>解决方案：</strong></p><ul><li>确认机制<ul><li>生产者确认机制：生产者发送消息后，会收到 RabbitMQ 的确认消息，失败重发</li><li>消费者确认机制：mq收到消费者ack才删除消息（手动-自己调api、自动-无异常则ack，none-立刻删除）</li></ul></li><li>消息持久化(mq默认内存存储消息)<ul><li>交换机&#x2F;队列持久化：mq重启保留队列</li><li>消息持久化：写入磁盘</li></ul></li></ul><p><strong>失败如何处理：</strong></p><ul><li>回调方法重发</li><li>记录日志</li><li>记录到数据库后重发，发完后删除</li><li>消费者处理异常则让mq重试，达到最大重试次数后放入异常交换机转人工处理</li></ul><h2 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h2><p><strong>定义：消费者的ack丢失，导致mq重复发消息，消费者重复消费</strong></p><p><strong>解决方案：</strong></p><ul><li>标识消息id（业务唯一标识）</li><li>幂等方案：锁（性能下降）-是指在分布式系统中，同一个操作无论执行多少次，结果都是一致的。</li></ul><h2 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h2><p><strong>延迟队列</strong>：进入队列的消息会被延迟消费，<strong>实现方式</strong>：死信交换机+TTL</p><p><strong>场景：</strong>超时订单（<strong>超时，需要进行取消订单、释放库存等操作</strong>）、限时优惠、定时发布（支付剩余时间…）</p><p><strong>死信（dead letter） 满足以下情况之一</strong></p><ul><li>当消费者使用 <code>basic.reject</code> 或 <code>basic.nack</code> 方法拒绝消息时，如果 <code>requeue</code> 参数设置为 <code>false</code></li><li>消息 TTL 过期（min（队列过期时间，消息过期时间））</li><li>队列满，后进消息成为死信</li></ul><p><strong>死信-&gt;死信交换机-&gt;消费者从死信队列中消费消息，处理超时订单</strong>，如果在延时过程中处理了订单，也要等TTL到期，让消费者处理</p><h2 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h2><p><strong>原因：</strong>消费者消费速度&lt;生产者生产速度</p><p><strong>解决方案：</strong></p><ul><li>增加消费者数量</li><li>消费者内部使用线程池</li><li>扩充队列容积<ul><li>惰性队列：接收消息后存入磁盘、消费时才从磁盘取出、支持数百万消息存储</li></ul></li></ul><h2 id="高可用机制"><a href="#高可用机制" class="headerlink" title="高可用机制"></a>高可用机制</h2><p><strong>集群</strong></p><ul><li>标准集群：多节点，共享相同的元数据，消息在某节点找不到时，会从其他节点传过来</li><li>镜像模式：主从模式，n主，每个主在别的节点中有备份。操作在主节点完成后同步-同步完成前主节点宕机（消息丢失）</li><li>仲裁协议-采用Raft协议，减少丢失，保证强一致性</li></ul><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="如何保证消息不丢失-1"><a href="#如何保证消息不丢失-1" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RabbitMQ&quot;&gt;&lt;a href=&quot;#RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ&quot;&gt;&lt;/a&gt;RabbitMQ&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%B</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="https://senwh.github.io/2025/02/22/%E8%B4%AA%E5%BF%83/"/>
    <id>https://senwh.github.io/2025/02/22/%E8%B4%AA%E5%BF%83/</id>
    <published>2025-02-22T05:32:51.000Z</published>
    <updated>2025-02-22T07:41:16.096Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/wiggle-subsequence/">LC.376. 摆动序列</a></p><ul><li>快慢指针</li><li>curdiff-prediff，峰谷思想</li></ul><p><a href="https://leetcode.cn/problems/maximum-subarray/">LC.53. 最大子数组和</a> ***</p><ul><li>一个数记录历史最大值，另一个数记录累计和，和小于0重置，大于0往下走</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/wiggle-subsequence/&quot;&gt;LC.376. 摆动序列&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快慢指针&lt;/li&gt;
&lt;li&gt;curdiff-prediff，峰谷思想&lt;/li&gt;
&lt;/ul&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>电商项目-演进文档</title>
    <link href="https://senwh.github.io/2025/02/18/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE-%E6%BC%94%E8%BF%9B%E6%96%87%E6%A1%A3/"/>
    <id>https://senwh.github.io/2025/02/18/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE-%E6%BC%94%E8%BF%9B%E6%96%87%E6%A1%A3/</id>
    <published>2025-02-18T14:11:17.000Z</published>
    <updated>2025-03-13T08:52:52.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高并发交易系统架构优化实践演进文档"><a href="#高并发交易系统架构优化实践演进文档" class="headerlink" title="高并发交易系统架构优化实践演进文档"></a>高并发交易系统架构优化实践演进文档</h1><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><table><thead><tr><th>版本号</th><th>发布日期</th><th>主要变更</th><th>负责人</th></tr></thead><tbody><tr><td>v1.0.0</td><td>2025-1-10</td><td>基础功能完成（JWT）</td><td>L同学</td></tr><tr><td>v1.1.0</td><td>2025-02-22</td><td>缓存优化</td><td>L同学</td></tr><tr><td>v1.1.1</td><td>2025-02-26</td><td>分布式锁控制并发（库存扣减）</td><td>L同学</td></tr><tr><td>v1.1.2</td><td>2025-02-27</td><td>缓存、数据库优化（库存）</td><td>L同学</td></tr><tr><td>v1.2.0</td><td>2025-03-01</td><td><strong>缓存预扣库存 + 异步更新数据库</strong></td><td>L同学</td></tr><tr><td>v1.2.1</td><td>2025-02-27</td><td>异步通知和日志（ 低库存预警通过邮件、短信通知商家。）</td><td></td></tr><tr><td>v1.2.2</td><td>2025-02-29</td><td>秒杀流量削峰 订单超时自动取消（延迟队列）</td><td></td></tr><tr><td>v1.3.0</td><td>2025-03-01</td><td>数据一致性保障 <strong>幂等性设计拦截重复请求</strong></td><td></td></tr><tr><td>v1.3.1</td><td>2025-03-03</td><td>监控和压测 <strong>限流与熔断保护数据库</strong></td><td></td></tr></tbody></table><hr><h2 id="版本详情"><a href="#版本详情" class="headerlink" title="版本详情"></a>版本详情</h2><h3 id="v1-0-0-基础功能完善（JWT-ThreadLocal"><a href="#v1-0-0-基础功能完善（JWT-ThreadLocal" class="headerlink" title="v1.0.0 -基础功能完善（JWT+ThreadLocal)"></a>v1.0.0 -基础功能完善（JWT+ThreadLocal)</h3><p><strong>流程：</strong></p><ul><li>登陆成功：claims放ID（标识用户）-定义签名算法（HS256-对称）-过期时间-<strong>生成jwt</strong></li><li>返回token给客户端</li><li>客户端消息请求头Authorization: Bearer <token>请求服务器</li><li>拦截器拦截方法：从请求头获取token-校验jwt（拿本地密匙处理token）</li><li>验证完整性和安全性后，解析出claims（里面含id）</li></ul><h3 id="v1-1-0-缓存优化"><a href="#v1-1-0-缓存优化" class="headerlink" title="v1.1.0 -缓存优化"></a>v1.1.0 -缓存优化</h3><p><strong>测试方案：</strong></p><ul><li><p>测试数据准备 - 有效数据池：预先生成10,0000个合法商品ID，写入BloomFilter和Redis </p></li><li><p>非法请求生成：使用JMeter随机生成20,000个不存在的商品ID（确保不会被BloomFilter命中）</p></li></ul><p><strong>JMeter脚本配置:</strong></p><ul><li><p>线程组配置： </p><ul><li>线程数：1000（模拟高并发） </li><li>循环数：100（10w线程并发）</li></ul></li><li><p>Ramp-Up时间：60秒（逐步加压） </p></li><li><p>HTTP请求设计： </p><ul><li>请求路径：GET &#x2F;product&#x2F;{productId}</li></ul></li></ul><p><strong>遇到问题：</strong></p><p>计算布隆过滤器拦截率时，拦截率超百分百-&gt;并发问题</p><p><strong>解决方案：</strong></p><p>使用原子类：AtomicLong（底层用Unsafe类，里面有CAS操作）</p><p><strong>技术方案：</strong></p><p><strong>热点数据缓存</strong></p><ul><li><p>Redis</p></li><li><p>序列化优化</p><ul><li>默认-&gt;JSON</li></ul></li><li><p>防穿透（空间换时间）</p><ul><li>缓存空数据</li><li><strong>布隆过滤器</strong></li></ul></li><li><p>防雪崩</p><ul><li>设置随机过期时间</li></ul></li></ul><h4 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h4><table><thead><tr><th>指标</th><th>优化前</th><th>优化后</th><th>测试条件</th></tr></thead><tbody><tr><td>布隆过滤器拦截率</td><td>85</td><td>98018&#x2F;100000&#x3D;98%</td><td>100000并发</td></tr><tr><td>商品查询P99</td><td>1200ms</td><td>350ms</td><td>200并发，持续1min</td></tr><tr><td>数据库连接等待</td><td>78%</td><td>12%</td><td>峰值压力期间</td></tr></tbody></table><hr><blockquote><p>通过引入Redis缓存，我们将高频查询的响应时间从200ms降低到5ms，QPS从500提升到3000，数据库CPU负载下降83%。同时设计了空值缓存和随机过期策略，缓存命中率稳定在98%以上，未出现缓存雪崩问题。</p></blockquote><h3 id="v1-1-1-分布式锁控制并发（库存扣减）"><a href="#v1-1-1-分布式锁控制并发（库存扣减）" class="headerlink" title="v1.1.1 - 分布式锁控制并发（库存扣减）"></a>v1.1.1 - 分布式锁控制并发（库存扣减）</h3><p><strong>问题</strong>：</p><p>A、高并发下出现<strong>超卖</strong>问题</p><p>B、行锁解决不了跨多个数据源&#x2F;分库分表（库存水平拆分到多个数据库）超卖&#x2F;高并发场景（如秒杀-访问同一商品）大量访问数据库性能下降，行锁释放增加延迟</p><p>C、Redis 分布式锁–锁的过期时间如何设定？</p><p><strong>技术方案：</strong></p><p>A、利用数据库的原子性（CAS） </p><ul><li><p><code>update inventory set stock = stock - delta where product_id=xxx and product_type=xxx and stock &gt;= delta</code></p></li><li><p>当执行 <code>UPDATE</code> 语句时，数据库会为符合条件的行 <strong>自动加行级排他锁（X Lock）</strong>，where搜索到的行都用排他锁所起来</p></li></ul><p>B、<strong>Redis 分布式锁</strong>–粒度为商品维度</p><ol><li><strong>互斥性</strong>：同一时刻只有一个客户端能持有锁。</li><li><strong>避免死锁</strong>：锁必须有超时机制，防止客户端崩溃后锁无法释放。</li><li><strong>容错性</strong>：即使部分 Redis 节点宕机，锁服务仍可用。</li><li><strong>可重入性</strong>（可选）：同一客户端可多次获取同一锁。</li></ol><p>使用了redis的setnx上锁lua脚本解锁，两者都是原子性的</p><p>redis是基于内存的，速度较快</p><p>C、引入守护线程续期机制（<strong>守护线程续期 + 原子性校验 + 资源管理</strong>）</p><p><strong>测试方案：</strong></p><p><strong>JMeter脚本配置:</strong></p><ul><li><p>线程组配置： </p><ul><li>线程数：2000（模拟高并发） </li><li>循环数：1</li></ul></li><li><p>Ramp-Up时间：1秒（瞬时并发） </p></li><li><p>HTTP请求设计： </p><ul><li>请求路径：Post&#x2F;user&#x2F;stock&#x2F;deduct</li></ul></li></ul><table><thead><tr><th>指标</th><th>优化前</th><th>优化后</th><th>测试条件</th></tr></thead><tbody><tr><td>平均响应时间</td><td>6625ms</td><td>16498ms</td><td>1000并发</td></tr><tr><td>吞吐量</td><td>127</td><td>18.4ms</td><td></td></tr><tr><td>超卖率</td><td>16.2%</td><td>12%</td><td></td></tr><tr><td>布隆过滤器拦截率</td><td></td><td>98018&#x2F;100000&#x3D;98%</td><td></td></tr></tbody></table><h3 id="v1-1-2-缓存优化、数据库优化（库存）"><a href="#v1-1-2-缓存优化、数据库优化（库存）" class="headerlink" title="v1.1.2 -缓存优化、数据库优化（库存）"></a>v1.1.2 -缓存优化、数据库优化（库存）</h3><p><strong>问题：</strong></p><p>A、锁的粒度：为购物车每个商品加锁（锁的粒度过细）（<strong>Redis性能瓶颈</strong>）；若改为用户粒度（可解决业务层重复请求（重复点击）），<strong>对多用户失效</strong>（超卖）</p><p>B、Redis 锁失效时的数据不一致</p><p>C、高频查询商品库存时性能瓶颈（如全表扫描）</p><p><strong>技术方案：</strong></p><p>A、库存分库分布，锁粒度为库存分片</p><p>B、作为兜底机制，防止 Redis 锁失效时的数据不一致</p><p>C、通过覆盖索引避免回表，其次将库存校验和扣减合并为一条原子 SQL</p><p>D、数据库优化：唯一索引(product_id, product_type) 防止重复商品录入，加速商品维度查询<br>覆盖索引(stock, version) 让扣减操作直接通过索引完成，避免回表</p><h3 id="面试讲述技巧："><a href="#面试讲述技巧：" class="headerlink" title="面试讲述技巧："></a>面试讲述技巧：</h3><ol><li>按「问题→方案→结果」三段式描述每个优化点 2. 准备1-2个详细的技术决策案例：     <strong>案例：缓存选型决策</strong>   - 候选方案：     1. Redis单缓存（成本低，但网络延迟影响性能）     </li><li>Caffeine本地缓存（速度快，但集群一致性难保证）     </li><li>多级缓存方案（本地缓存+Redis）   - 决策依据：     - 业务特点：商品信息变更频率低（每天&lt;10次）     - 最终选择：Caffeine本地缓存 + 广播刷新   - 实现效果：商品查询RT降低82%</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;高并发交易系统架构优化实践演进文档&quot;&gt;&lt;a href=&quot;#高并发交易系统架构优化实践演进文档&quot; class=&quot;headerlink&quot; title=&quot;高并发交易系统架构优化实践演进文档&quot;&gt;&lt;/a&gt;高并发交易系统架构优化实践演进文档&lt;/h1&gt;&lt;h2 id=&quot;版本管理&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试篇-框架</title>
    <link href="https://senwh.github.io/2025/02/17/%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/"/>
    <id>https://senwh.github.io/2025/02/17/%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/</id>
    <published>2025-02-17T12:13:04.000Z</published>
    <updated>2025-02-23T08:24:42.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="Bean线程安全问题"><a href="#Bean线程安全问题" class="headerlink" title="Bean线程安全问题"></a><strong>Bean线程安全问题</strong></h3><p>Spring框架中单例Bean是线程安全吗？</p><ul><li><strong>成员方法内状态可修改变量需考虑线程安全</strong>（DAO Service层变量通常不变）</li><li>单例模式，各线程共享该bean</li></ul><p>解决方案</p><ul><li>加锁</li><li>@Scope 设置为prototype 多例，每个新的线程会新建变量</li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><strong>面向切面编程</strong> ：对某个类方法源代码不进行修改的情况下实现增强</p><p><strong>关键元素</strong>：通过<strong>切面</strong>描述<strong>通知（存放共性（增强）操作的方法，被存在通知类中）</strong>和<strong>切入点（从连接点中选取）</strong>的关系</p><p><strong>步骤</strong></p><ol><li>导入坐标</li><li>制作连接点（DAO层通常是增删改查）</li><li>制作通知（类）</li><li>定义切入点-&gt;切入点的定义依托一个无实际意义的方法 <ul><li>为了更细粒度的控制，可以增加自定义注解，在需要增强方法前做好标识</li></ul></li><li>绑定切入点和通知关系（切面）-定义增强时机(before，around….)</li></ol><ul><li>4.5的操作实际上都在通知类</li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/AOP_1.png" alt="AOP_1"></p><p><strong>AOP底层实现</strong>：如果目标类使用了增强，则生成目标对象的代理对象执行方法（原因是不能乱动原来的对象）</p><p><strong>使用场景：</strong></p><ul><li>记录操作日志</li><li>缓存处理</li><li>Spring内置的事务处理<ul><li>声明式事务管理（AOP）<ul><li>检查到@Transactional时，：Spring 使用 <code>TransactionInterceptor</code> 作为事务的切面（Aspect）。它定义了事务的前置增强（开始事务）和后置增强（提交或回滚事务）。</li><li>通过 <code>DataSourceTransactionManager</code>（或类似的事务管理器）与数据库交互</li></ul></li><li>编程式事务管理（侵入）</li></ul></li></ul><h2 id="Spring中事务失效场景"><a href="#Spring中事务失效场景" class="headerlink" title="Spring中事务失效场景"></a><strong>Spring中事务失效场景</strong></h2><ul><li>异常捕获处理<ul><li>遇到异常时只有自己主动抛出异常事务才会回滚</li><li>throw new RuntimeException(e)</li></ul></li><li>抛出检查异常<ul><li>Spring默认只回滚非检查异常（运行时异常，RuntimeExcption）</li><li>@Transactional配置（rollbackFor&#x3D;Exception.class）</li></ul></li><li>非public方法<ul><li>只有pulic方法才有事务管理</li></ul></li></ul><h2 id="Spring-bean的生命周期"><a href="#Spring-bean的生命周期" class="headerlink" title="Spring bean的生命周期"></a><strong>Spring bean的生命周期</strong></h2><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/bean.png" alt="bean"></p><ul><li><p>实例化：Spring 容器（如 <code>AnnotationConfigApplicationContext</code> 或 XML 配置的容器）根据 Bean 的定义（如 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 或通过 XML 配置的 <code>&lt;bean&gt;</code>）创建一个对象实例</p></li><li><pre><code class="java">@Autowired</code></pre></li><li><p><code>Aware</code> 接口是一系列接口的统称，它们允许 Spring 容器中的 Bean 获取运行时上下文信息，如 Spring 的上下文（<code>ApplicationContext</code>）、Bean 工厂（<code>BeanFactory</code>）、资源加载器（<code>ResourceLoader</code>）（<strong>安全和权限管理等</strong>）</p></li><li><p>BeanPostProcessor用对对象进行增强（前&#x2F;后）</p><ul><li>AOP 的实现需要在 Bean 初始化之后创建代理对象，因此会使用到 BeanPostProcessor（动态代理：JDK 动态代理需要实现接口，而 CGLIB 代理是基于字节码生成的）</li></ul></li><li><p>实例化包括：@PostConstruct 和 <code>InitializingBean</code> 的 <code>afterPropertiesSet</code> 方法</p></li></ul><h2 id="Spring中的循环依赖问题"><a href="#Spring中的循环依赖问题" class="headerlink" title="Spring中的循环依赖问题"></a>Spring中的循环依赖问题</h2><p><strong>定义：</strong>两个或多个 Bean 互相依赖对方，导致 Spring 容器在初始化这些 Bean 时陷入死锁或无法正常注入的情况</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-1.png" alt="{spring-1.png}"></p><p><strong>如何解决？</strong></p><p><strong>三级缓存</strong></p><ul><li>一级缓存：存放完整的单例-完成初始化后</li><li>二级缓存：可存放早期的bean对象-依赖注入阶段</li><li>三级缓存：缓存的是ObjectFactory-实例化时</li></ul><p><strong>本质：</strong>根据Bean的创建周期，提前暴露（二级在初始化前暴露，缓存的是非代理对象），当注入的是代理对象时，需要ObjectFactory（可生成普通对象和代理对象）生成。初始化后，只留一级缓存，剩下两个被清空</p><p><strong>如果在构造函数时产生循环引用-此时三级缓存不行了，因为这是在初始化的过程中</strong></p><p>解决：@Lazy，延迟实例化另一个对象</p><h2 id="SpringMvc的执行流程"><a href="#SpringMvc的执行流程" class="headerlink" title="SpringMvc的执行流程"></a>SpringMvc的执行流程</h2><h3 id="JSP阶段"><a href="#JSP阶段" class="headerlink" title="JSP阶段"></a>JSP阶段</h3><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-2.png" alt="spring-2"></p><ul><li>映射器返回的是<code>HandlerExecutionChain</code>：带有 <code>@Controller</code> 注解的类中某个带有 <code>@RequestMapping</code> 注解的方法+拦截器列表</li></ul><h3 id="前后端分离阶段"><a href="#前后端分离阶段" class="headerlink" title="前后端分离阶段"></a>前后端分离阶段</h3><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-3.png" alt="spring-3"></p><ul><li>前后端分离了，所以不用在后端生成页面，只需要返回JSON数据让前端自己处理</li></ul><h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><p><strong>配置流程</strong></p><ul><li><strong>启动类注解</strong>：Spring Boot 的启动类使用 <code>@SpringBootApplication</code> 注解，该注解是一个组合注解，包含 <code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 和 <code>@Configuration</code>。</li><li><strong>自动配置触发</strong>：<code>@EnableAutoConfiguration</code> 注解会触发自动配置机制，Spring Boot 会扫描 <code>META-INF/spring.factories</code> 文件，加载其中定义的自动配置类。</li><li><strong>条件注解过滤</strong>：Spring Boot 会根据条件注解（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>）判断是否需要加载某个配置类或 Bean。</li><li><strong>Bean 注册</strong>：符合条件的配置类会被加载，其中定义的 Bean 会被注册到 Spring 容器中，供其他组件使用。</li><li><strong>依赖注入</strong>：其他组件可以通过 <code>@Autowired</code> 或构造函数注入的方式使用这些自动装配的 Bean。</li></ul><p> <code>@EnableAutoConfiguration：</code>包含了两个元注解：</p><ul><li><p><code>@AutoConfigurationPackage 和 @Import(EnableAutoConfigurationImportSelector.class)</code></p></li><li><p><code>@AutoConfigurationPackage</code> 注解的作用是将<strong>当前应用的包路径注册到 Spring 容器</strong>中，以便 Spring Boot 能够在后续的自动配置过程中正确地扫描和加载相关的组件</p></li><li><p><code>@Import(EnableAutoConfigurationImportSelector.class)</code>从 <code>META-INF/spring.factories</code> 文件中加载配置类</p></li><li><p><code>spring.factories</code> 文件是 Spring Boot 自动配置的核心，包含了一系列的配置类，这些配置类通过<strong>条件注解</strong>（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnProperty</code> 等）来决定是否被加载</p></li></ul><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><p><strong>Spring</strong></p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-4.png" alt="{spring-4}"></p><p><strong>SpringMvc</strong></p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-5.png" alt="{spring-5}"></p><p><strong>SpringBoot</strong></p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-6.png" alt="{spring-6}"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h3 id=&quot;Bean线程安全问题&quot;&gt;&lt;a href=&quot;#Bean线程安全问题&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试篇-数据库</title>
    <link href="https://senwh.github.io/2025/02/14/%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://senwh.github.io/2025/02/14/%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2025-02-14T09:14:09.000Z</published>
    <updated>2025-02-17T12:11:23.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="定位慢查询"><a href="#定位慢查询" class="headerlink" title="定位慢查询"></a>定位慢查询</h2><p><strong>慢查询定义：</strong>执行时间超过一定阈值（可配置）的 SQL 查询</p><p><strong>如何定位？</strong></p><ul><li>开源工具<ul><li>调式工具 Arthas</li><li>运维工具：Prometheus、Skywalking</li></ul></li><li>Mysql自带慢日志<ul><li>开始开关&#x2F;设置时间阈值（超过该阈值判定为慢日志）</li></ul></li></ul><h2 id="SQL执行计划"><a href="#SQL执行计划" class="headerlink" title="SQL执行计划"></a>SQL执行计划</h2><p><strong>如何优化慢查询？</strong></p><ul><li>EXPLAIN&#x2F;DESC命令获取查询命令执行信息<ul><li>key判断是否命中索引</li><li>Extra给出是否回表查询</li><li>type<img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/msql-1.png" alt="msql-1"></li></ul></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>定义：一种排好序的<strong>数据结构</strong>-&gt;可以帮mysql高效获取数据（类似一张表，不是一个值）</p><p><strong>为什么需要？</strong></p><ul><li>查询磁盘慢在寻址，索引绑定磁盘地址后，检索索引即可省去寻址过程</li></ul><p>其数据结构：k-V，k为值，V为磁盘地址</p><ul><li><p>二叉树：最差情况O（n）</p></li><li><p>红黑树</p><ul><li>比AVL平衡条件更宽松（适合频繁的插入删除，需要的旋转次数较少）</li><li>百万级数目-&gt;树的高度会很高</li></ul></li><li><p>Hash表</p><ul><li>索引key做Hash计算，得到对应data的磁盘地址（速度快）</li><li>仅满足”&#x3D;“，<strong>不支持范围查询</strong></li><li>hash冲突</li></ul></li><li><p>B Tree</p><ul><li>叶节点具有相同深度，指针为空，数据索引递增（磁盘文件地址和索引保存在一起）</li></ul></li><li><p>B+Tree（mysql底层存储数据结构）</p><ul><li>非叶子节点不存data（磁盘地址）</li><li>叶子节点包含所有索引，节点间用指针连接</li><li>便于<strong>区间查询</strong>（叶子双向链表）</li></ul></li></ul><p>Mysql默认一个节点（16KB），有多个组构成（8B-索引+6B-下一级指针）&#x3D;约1170组</p><p><strong>叶子节点（8B+约1KB（data））：key-value的形式</strong></p><p><strong>查询过程</strong>：将结点加载进内存（相比磁盘可以忽略不计）-折半查找，寻找下一层</p><p><strong>存储引擎</strong></p><p><strong>MyISAM</strong></p><ul><li>磁盘含三个文件，分别存：文件结构、data、索引</li><li>匹配索引到data中查找</li><li>非聚集索引（data，索引放不同文件）</li><li>第一次IO访问索引（叶子的data部分放的是主键值）（二级索引-例：用name去查主键），第二次IO访问data（<strong>回表</strong>），速度慢</li></ul><p><strong>InnoDB</strong></p><ul><li>磁盘含两个文件，分别存：文件结构、data+索引</li><li>聚集索引（data+索引放一个文件）</li><li>速度快，牺牲空间</li></ul><p><strong>为什么建议InnoDB必须建主键？</strong>&#x2F;为什么用自增整型</p><ul><li><p><strong>如果没有主键，mysql会找一不含重复元素的列作为主键&#x2F;自己生成主键（牺牲数据库资源），ROWID</strong></p></li><li><p>整型比大小更快（查找效率更高）</p></li><li><p>如果不用自增， 新节点插入中间节点容易产生分裂，重建B+树较麻烦</p></li></ul><p><strong>联合索引</strong>（索引主键是几个key的组合(a,b,c)）</p><ul><li>最左前缀原则<ul><li>底层存储结构（如果条件没name，需要全表查找age，age只在固定name时节点才有序）<img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/msql-2.png" alt="msql-2"></li></ul></li></ul><p><strong>覆盖索引</strong></p><p><strong>定义：查询使用了索引，并且需要返回的列，在索引中能全部找到</strong></p><p><strong>主键索引</strong>：如果字段 <code>A</code> 是主键，那么 <code>A</code> 的 B+ 树索引是主键索引，主键索引的叶子节点存储的是主键值和数据行的聚集地址（数据行的实际存储位置）。主键索引是存储数据行的唯一标识</p><p><strong>二级索引</strong>：二级索引的叶子节点存储的是索引字段的值和主键值的组合。如果查的值刚好是索引字段的值，就不用回表了-&gt;所谓覆盖索引</p><p>例：如果查找只需要返回Arm和id，则该二级索引已经够了，不需要回表</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/msql-3.png" alt="msql-3"></p><ul><li>避免使用select* ,因为除了条件是id时是聚集索引，其他都要回表（非覆盖）</li><li>解决MYSQL超大分页（limit分页越往后效率越低，数据库不能知道第n行的位置，需要一行行扫描）<ul><li>B+树会从第一个叶节点一个个往下找</li><li>如果没有覆盖索引，每一个节点需要回表一次</li><li>SELECT *<br>FROM tb_sku t,<br> (SELECT id FROM tb_sku ORDER BY id LIMIT 9000000, 10) a<br>WHERE t.id &#x3D; a.id; 该覆盖查询-&gt;获得的id不需要回表+子查询只需回表10条，相比较前者性能得到优化</li></ul></li></ul><p><strong>索引创建原则</strong></p><ul><li>数据量大，查询频繁的表建立索引（单表超10w数据）</li><li>针对常做为where,order by, group by操作的字段建立索引</li><li>使用区分度高的列做索引</li><li>针对字符串字段做索引时，由于其很长，可只用其前缀</li><li>尽量使用联合索引，很多时候可以覆盖索引（避免回表）</li></ul><p><strong>什么时候索引失效？</strong></p><ul><li>违反最左前缀法则</li><li><strong>查询范围右边的列不能使用索引</strong></li><li>在索引列上运算</li><li>字符串不加单引号</li><li>%开头的模糊索引</li></ul><p><strong>谈谈对sql的优化经验</strong></p><ul><li>表设计</li><li>索引优化</li><li>sql语句设计</li><li>主从复制、读写分离</li><li>分库分表</li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>定义：一组操作的集合，把所有操作一起提交&#x2F;撤销，同时成功&#x2F;失败</p><h2 id="特性：ACID"><a href="#特性：ACID" class="headerlink" title="特性：ACID"></a>特性：ACID</h2><ul><li><p>原子性（Atomicity）最小操作单位</p><ul><li>实现方式<ul><li>日志记录：记录事物操作，用于回滚</li><li>事务回滚：两个阶段-回滚未完成事物，前滚已完成事物</li></ul></li></ul></li><li><p>一致性（Consistency）事物完成时<strong>数据一致</strong></p><ul><li>数据完整性约束<ul><li><strong>实体完整性</strong>：主键约束要求表中的每行记录都有一个唯一的标识符，确保数据的唯一性和可识别性。</li><li><strong>参照完整性</strong>：外键约束确保两个表之间的关系是有效的，例如，子表中的外键值必须存在于主表的主键值中。</li><li><strong>域完整性</strong>：数据类型和取值范围约束确保数据的格式和内容符合预定的规则，例如，年龄字段必须是正整数且小于某个上限。</li></ul></li><li>事务逻辑验证：人为规则：每个部门只能有一个经理</li><li>并发控制（隔离性级别）</li><li>事物回滚&#x2F;恢复</li></ul></li><li><p>隔离性（Isolation）事物不受外部并发操作影响</p><ul><li><p>实现方式</p><ul><li><p>锁机制：共享锁（读锁）和排他锁（写锁）</p></li><li><p>事务隔离级别（隔离性 低-&gt;高）：</p><ul><li>读未提交（Read Uncommitted）（脏读、不可重复读和幻读）</li><li>读已提交（Read Committed）（不可重复读和幻读）</li><li>可重复读（Repeatable Read）（保证对<strong>同一数据</strong>的多次读取结果是一致的，但没有防止其他事务插入新的数据）（幻读）<strong>（mysql默认模式）</strong> <strong>标准SQL中RR允许幻读，但MySQL的InnoDB通过MVCC+间隙锁在RR级别避免了幻读（这是MySQL的特性，非SQL标准要求）</strong></li><li>串行化（Serializable）（性能下降）</li></ul></li><li><p><strong>多版本控制（MVCC）</strong></p></li></ul></li><li><p>事务并发执行时的隔离性问题（下述的前提是<strong>在同一事务内</strong>）</p><ul><li>脏读：一个事务读取了另一个未提交事务写入的数据</li><li>不可重复读：读取到已提交的数据，但数据已被修改</li><li>幻读：读取到已提交的数据，但数据集的行数发生了变化（新增或删除）</li></ul></li></ul></li><li><p>持久性（Durability）提交&#x2F;回滚，对数据改变是永久的</p><ul><li>实现方式<ul><li>存储子系统（磁盘）</li><li>日志</li></ul></li></ul></li></ul><h2 id="undo（回滚）-log-和redo（恢复）-log"><a href="#undo（回滚）-log-和redo（恢复）-log" class="headerlink" title="undo（回滚） log 和redo（恢复） log"></a>undo（回滚） log 和redo（恢复） log</h2><p>缓冲池：主存区域，以一定频率刷新到磁盘</p><p>数据页：InnoDB磁盘管理最小单位，默认16KB（行数据）</p><p><strong>redo</strong>：<strong>记录物理页的变化</strong>，<strong>实现持久性</strong> 包括 redo log buffer(缓存) -&gt;redo log file（磁盘）-&gt;定期刷新</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/redo.png" alt="redo"></p><p><strong>作用：数据同步到磁盘出现问题时，根据该日志可以恢复</strong></p><p><strong>undo log：逻辑日志（delete记录为insert）（关注未提交事物的回滚），实现事务一致性和原子性</strong></p><p><strong>事物处理过程：</strong></p><ul><li><strong>事务开始</strong>：当一个事务开始时，数据库系统会为其分配一个唯一的事务标识符，并开始记录该事务的 Redo Log 和 Undo Log。</li><li><strong>数据修改</strong>：在事务执行过程中，每当对数据库进行修改操作时，数据库系统会首先将相应的 Redo Log 写入缓冲区，然后记录 Undo Log。</li><li><strong>事务提交</strong>：在事务提交之前，数据库系统会确保所有的 Redo Log <strong>都已被写入磁盘</strong>，然后更<strong>新事务的状态为已提交</strong>。此时，数据修改的结果才会被永久保存。</li><li><strong>事务回滚</strong>：如果事务需要回滚，数据库系统会根据 Undo Log 中的记录，撤销该事务对数据库所做的所有修改</li></ul><p><strong>恢复过程：</strong></p><ul><li><strong>检查点</strong>：数据库系统<strong>定期创建检查点</strong>，记录当前数据库的状态和已提交事务的信息。</li><li><strong>数据库崩溃</strong>：当数据库系统崩溃时，所有未完成的事务都会被挂起，而 Redo Log 和 Undo Log 仍然保存在磁盘上。</li><li><strong>恢复</strong>：<ul><li><strong>重做阶段</strong>：数据库系统首先重放 Redo Log 中的所有记录，将数据库<strong>恢复到检查点时的状态</strong>，并应用所有已提交事务的修改。</li><li><strong>回滚阶段</strong>：然后，数据库系统根据 Undo Log，<strong>撤销所有未提交事务的修改</strong>，确保数据库的一致性。</li></ul></li></ul><h2 id="MVCC-multi-verison-concurrence-control"><a href="#MVCC-multi-verison-concurrence-control" class="headerlink" title="MVCC (multi-verison concurrence control)"></a>MVCC (multi-verison concurrence control)</h2><p>定义：一种数据库并发控制机制，通过为<strong>每行数据维护多个版本</strong>来实现读写操作的并行执行。它允许读操作不被写操作阻塞，写操作也不被读操作阻塞，从而提高了数据库的并发性能</p><p><strong>实现方式</strong></p><ul><li>隐藏字段：每行数据包含隐藏的元数据（创建该版本的事务ID，指向该版本的Undo Log的指针，行ID用于唯一标识一行数据）</li><li>Undo Log版本链：每次修改对应一个版本 追加存储在Undo Log<img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/mvcc-1.png" alt="mvcc-1"></li><li><strong>Read View</strong>：包含（当前<strong>活跃</strong>(未提交)事务的ID集合，当前活跃事务的最大ID&#x2F;最小ID，创建该Read View的事务ID）<img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/mvcc-2.png" alt="mvcc-2"></li></ul><p>即定义了一组规则（随着隔离级别改动-RC-RR），控制事务出现避免并发问题。根据该规则，以RC为例，第一个RV读的是事务2的结果（它已提交），第二个读的是（事务3）</p><p><strong>RC在每一次执行快照生成读视图</strong></p><p><strong>RR在只在事务第一次执行生成都视图</strong></p><p><strong>快照读：</strong>并不直接读取数据库中的最新数据，而是读取数据的一个快照版本。这个快照版本是事务开始时数据库的状态。<strong>允许读操作不被写操作阻塞</strong></p><p><strong>总结：</strong></p><ul><li>事务按照<strong>现实业务根据自身需求选择适合的隔离级别</strong>，之所以需要有隔离级别是为了提升数据库的性能(不然所有事务都用串行化就好了),，另外越高的隔离级别会导致更多锁竞争和回滚。</li><li>不同的隔离级别方式有其实现方法，其中MVCC支持RC和RR。因为不同的隔离级别又对应不同的并发问题，开发者只要考虑该业务是否接收这样的并发问题即可确定设置的隔离级别。例：在RR中用户读的不是最新的版本信息，但用户的需求并不是要最新的，而是要解决脏读和不可重复读的问题，此时用RR没问题。快照隔离</li><li>在RR级别下：<strong>读操作</strong>：看到的是事务开始时的快照版本。<strong>写操作</strong>：仍然会看到最新提交的数据（通过当前读）</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h2><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/syn.png" alt="syn"></p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p><strong>时机：</strong></p><ul><li>单表数据量超1000w</li><li>上述优化解决不了性能问题</li><li>IO瓶颈&#x2F;CPU瓶颈</li></ul><p><strong>拆分类型：</strong></p><ul><li>垂直分库：根据业务将不同表拆分到不同库</li><li>垂直分表：根据字段属性将不同字段拆分到不同表</li><li>水平分库：一个库数据拆分到多个库（物理地拆分）<ul><li>寻库需路由</li></ul></li><li>水平分表：一个表数据拆分到多个表</li></ul><p><strong>产生问题</strong></p><ul><li>分布式事务一致性</li><li>跨节点关联查询</li><li>跨节点分页、排序函数</li><li>主键避重</li></ul><p><strong>解决方案</strong>-&gt;中间键</p><ul><li>sharding-sphere</li><li>mycat</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;优化&quot;&gt;&lt;a href=&quot;#优化&quot; class=&quot;headerlink&quot; title=&quot;优化&quot;&gt;&lt;/a&gt;优化&lt;/h1&gt;&lt;h2 id=&quot;定位慢查询&quot;&gt;&lt;a href=&quot;#定位慢查询&quot; class=&quot;headerlink&quot; title=&quot;定位慢查询&quot;&gt;&lt;/a&gt;定位慢查</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>项目进阶-《mall项目》</title>
    <link href="https://senwh.github.io/2025/02/12/%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6-%E3%80%8Amall%E9%A1%B9%E7%9B%AE%E3%80%8B/"/>
    <id>https://senwh.github.io/2025/02/12/%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6-%E3%80%8Amall%E9%A1%B9%E7%9B%AE%E3%80%8B/</id>
    <published>2025-02-12T09:32:28.000Z</published>
    <updated>2025-02-12T09:32:28.745Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>回溯</title>
    <link href="https://senwh.github.io/2025/02/11/%E5%9B%9E%E6%BA%AF/"/>
    <id>https://senwh.github.io/2025/02/11/%E5%9B%9E%E6%BA%AF/</id>
    <published>2025-02-11T07:13:27.000Z</published>
    <updated>2025-02-20T12:16:12.044Z</updated>
    
    <content type="html"><![CDATA[<p><strong>递归和回溯的关系</strong>：递归是实现回溯的手段</p><p><strong>回溯题目思路：</strong></p><ul><li>构建树<img src="/./%E5%9B%9E%E6%BA%AF/tree.png" alt="tree"></li><li>for(横向)</li><li>递归纵向</li></ul><p><strong>模板</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><a href="https://leetcode.cn/problems/combinations/">LC77. 组合</a></p><ul><li>将问题构建为一颗n叉树，递归遍历-回溯模板</li><li>ArrayList适用查找替换，LinkedList适用增删</li></ul><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">LC17. 电话号码的字母组合</a></p><p><a href="https://leetcode.cn/problems/combination-sum/">LC39. 组合总和</a></p><ul><li><pre><code class="java">path.remove(path.size() - 1);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  Arrays.sort(candidates);</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><a href="https://leetcode.cn/problems/combination-sum-ii/">LC40. 组合总和 II</a></p><ul><li>去重剪枝</li><li>思考树的横纵向与递归的关系</li></ul><h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">LC131. 分割回文串</a>***</p><ul><li>横向为切割位置</li><li>纵向为剩余字符串</li><li>StringBuilder</li></ul><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">LC93. 复原 IP 地址</a></p><ul><li>横向切割位置</li><li>判别有效字符<ul><li>sb-&gt;string</li><li><strong>Integer.parseInt() String转Int</strong></li><li>0开头长度&gt;1</li><li>255</li></ul></li><li>分隔符连接：String.join(“.”, path)</li></ul><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/subsets-ii/">LC90. 子集 II</a></p><ul><li>去重，同组合II方法一致</li><li>数组有序后，对树叶去重</li></ul><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">LC491. 非递减子序列</a></p><ul><li><strong>数组在无序时，用HashSet去重</strong></li></ul><p><a href="https://leetcode.cn/problems/permutations-ii/">LC47. 全排列 II</a>***</p><ul><li>used数组去重横向（false） 纵向（true）</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://leetcode.cn/problems/reconstruct-itinerary/">LC332. 重新安排行程</a>（超时）</p><ul><li>字符串的排序    Collections.sort(tickets,(a,b)-&gt;a.get(1).compareTo(b.get(1)));</li><li>字符串比较 tickets.get(i).get(0).equals(path.getLast())</li></ul><p><a href="https://leetcode.cn/problems/n-queens/">LC51. N 皇后</a>***</p><ul><li>三数组 列、45[row+col]、135[row-col+n-1]</li></ul><p><a href="https://leetcode.cn/problems/sudoku-solver/">LC37. 解数独</a></p><ul><li>树枝为数度数字，树枝为位置</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;递归和回溯的关系&lt;/strong&gt;：递归是实现回溯的手段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回溯题目思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建树&lt;img src=&quot;/./%E5%9B%9E%E6%BA%AF/tree.png&quot; alt=&quot;tree&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试篇-Redis</title>
    <link href="https://senwh.github.io/2025/01/07/%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/"/>
    <id>https://senwh.github.io/2025/01/07/%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/</id>
    <published>2025-01-07T12:56:00.000Z</published>
    <updated>2025-02-25T14:01:09.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>定义：（恶意）查询一个DB中没有的数据，无返回结果存入Redis，导致每次到需要访问内存</p><p>解决方案：</p><ul><li>缓存空数据<ul><li>缺点：随着空数据增多，内存消耗大</li></ul></li><li>布隆过滤器（在内存中）：放在查询和Redis之间，将所有的key预先加载到过滤器中,每次先查询输入的key是否存在，再查询内存（此时一定存在value）。用一个bit数组（只有0，1），定义多个Hash函数，每次将输入哈希映射到bit位图中，若各位置都为（1）即判断数据存在。<ul><li>缺点：有误判风险，bit越大，Hash函数越多，可减小风险。</li><li>实现方案：Redission&#x2F;Guava</li></ul></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>定义：（Redis）key设置了过期时间，过期后收到大量并发请求，在缓存重建前，DB被压垮；无缓存的大并发不属于这种情况</p><p>解决方案：</p><ul><li>互斥锁：第一个线程若没查到缓存，上锁直到重建完后再允许其他线程查询<ul><li>保持数据一致性，但性能差（其他线程一直等待解锁）</li></ul></li><li>逻辑过期：等待时间过期到先不清除数据，等待逻辑过期时间。这段时间若有并发数据，开启新线程上锁更新过期时间，旧线程或其他线程不需等待新线程解锁，返回旧数据。直到解锁才用新数据。<ul><li>新旧数据容易产生不一致，但性能高</li><li>缓存中含逻辑过期时间和实际过期时间，前后比后者大。</li></ul></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>定义：缓存采用了相同的设置时间，导致缓存在某一时间同时失效&#x2F;Redis宕机（GG），大量并发请求到DB，导致DB压力过重。</p><p>解决方案：</p><ul><li>过期时间+随机值</li><li>集群服务：哨兵模式、集群模式？</li><li>缓存业务添加降级限流策略？ ngxin&#x2F;spring cloud gateway</li><li>业务添加多级缓存</li></ul><h2 id="双写一致性-mysql如何与redis同步"><a href="#双写一致性-mysql如何与redis同步" class="headerlink" title="双写一致性(mysql如何与redis同步)"></a>双写一致性(mysql如何与redis同步)</h2><p>场景一：一致性要求高</p><ul><li>写操作：先删缓存（数据库还没更新）&#x2F;先修改数据库（缓存过期，数据还没更新就读）&#x2F;延时双删（数据库修改前后都删一次缓存，等数据库修改完毕再删，延时多久不能把控）都可能出现<strong>脏数据</strong></li><li>绝对保证一致：读写操作加锁。读操作用共享锁（允许读），写操作用排他锁（不允许其他操作）-redission </li><li>性能差</li></ul><p>场景二：运行延迟一致</p><ul><li>异步通知</li><li>MQ中间件</li><li>canal中间件</li></ul><h2 id="持久化（防止数据redis丢失）"><a href="#持久化（防止数据redis丢失）" class="headerlink" title="持久化（防止数据redis丢失）"></a>持久化（防止数据redis丢失）</h2><p><strong>RDB（Redis Database Backup file）</strong>：防止redis故障数据丢失，将数据备份到磁盘</p><ul><li>执行原理：bgsave fork（克隆）主进程得到子进程，子进程共享主进程内存数据。完成fork后读取内存数据并写入RDB文件。（子进程把页表（虚拟地址和物理地址的映射关系）copy过来慢慢读内存数据，不阻塞主进程）</li><li>在读内存数据过程中，若主进行对内存数据有写操作，将那块内存copy一个副本专用于写（此时似乎和当前子进程数据不一致了），更新页表，重新开bgsave备份</li><li>两次备份会丢失</li><li>二进制压缩，体积较小</li></ul><p><strong>AOF（Append Only File）</strong>：将redis写操作命令记录在AOF文件中</p><ul><li><p>设定频率（执行写操作命令）</p></li><li><p>记录命令比RDB文件要大</p></li></ul><h2 id="数据过期策略-内存过期数据如何处理）"><a href="#数据过期策略-内存过期数据如何处理）" class="headerlink" title="数据过期策略(内存过期数据如何处理）"></a>数据过期策略(内存过期数据如何处理）</h2><ul><li><p>惰性删除：数据过期后，访问了才会删（节省查询过期时间的操作时间，但浪费内存）</p></li><li><p>定期删除：每隔一段时间，从数据库里随机抽出一定数量key检查，过期即删除</p><ul><li>slow模式 扫描频率10hz 每次不超过25ms</li><li>fast模式 两次间隔不超过2ms 每次不超过1ms</li></ul></li><li><p>两者配合使用</p></li></ul><h2 id="数据淘汰策略（为已满的redis添加新key，如何替换）"><a href="#数据淘汰策略（为已满的redis添加新key，如何替换）" class="headerlink" title="数据淘汰策略（为已满的redis添加新key，如何替换）"></a>数据淘汰策略（为已满的redis添加新key，如何替换）</h2><ul><li>noeviction：不淘汰，满了不给进</li><li>volatile-ttl：TTL值被淘汰</li><li>allkeys-random：random<ul><li>无太大频率，冷热区分</li></ul></li><li>volatile-random：对设置TTL的key random</li><li>allkeys-lru：基于LRU算法淘汰（Least Recently Used）<ul><li>有冷、热点数据区分</li><li>保证留下的是高频数据</li></ul></li><li>allkeys-lfu：基于LFU算法淘汰（Least Frequently Used）<ul><li>短时高频数据</li><li>促销商品，短时间内可能高频访问，但它不是热点数据</li></ul></li><li>volatile-lfu<ul><li>有需要置顶的数据（不设置TTL，永远不会被淘汰）</li></ul></li></ul><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>在服务集群部署（nginx反向代理）的情况下，互斥锁解决不了多个JVM线程并发访问数据不同步问题</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/%E4%BA%92%E6%96%A5%E9%94%81.png" alt="互斥锁"></p><p>引入外部锁（分布式锁）</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" alt="互斥锁"></p><h2 id="redisson"><a href="#redisson" class="headerlink" title="redisson"></a>redisson</h2><ul><li>底层原理：setnx（set if not exist） + lua脚本（保证原子性）</li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/setnx.png" alt="setnx"></p><p><strong>如何设置超时时间？</strong></p><ul><li>时间预估+给锁续期（watch-dog。每隔releaseTime&#x2F;3时间续期）</li></ul><p><strong>可重入?</strong> (一个线程内多次加锁)</p><ul><li>用hash结构存储线程信息和重入次数</li><li>防止死锁（一个线程多次进入一个锁的保护块，可能会被阻塞）</li></ul><p><strong>可以解决主从一致性问题？</strong>（主节点负责写修改同步。子节点负责读操作）</p><ul><li>用redisson提供的红锁解决（在超过一半结点都获得锁才认为成功上锁、避免有些结点宕机上锁失败）（性能低），可以用zookeeper来实现</li></ul><h1 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><ul><li>主从全量同步（将主节点（Master）上的所有数据完整地复制到从节点（Slave）。这种方式不考虑数据是否已经存在于从节点，而是重新传输所有数据）</li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.png" alt="主从同步"></p><p><strong>判断第一次请求</strong>：replication id 标识两个为同一个数据集，若不一致，证明为第一次同步，为子节点更新id值</p><p><strong>保证只同步差异部分</strong>：每次主节点更新数据同时更新offset值，同步更新offset的部分给子节点</p><ul><li><p>增量同步（只将主节点上自上次同步以来发生变化的数据同步到从节点。这种方式通过记录数据的变化来减少不必要的数据传输）</p><p>主节点会记录二进制日志（binlog），从节点通过I&#x2F;O线程读取这些日志，并通过SQL线程应用这些日志来保持数据一致性</p></li></ul><p><strong>主从的方式保证不了redis高可用，主节点宕机</strong></p><h2 id="哨兵模式（Sentinel）"><a href="#哨兵模式（Sentinel）" class="headerlink" title="哨兵模式（Sentinel）"></a>哨兵模式（Sentinel）</h2><p><strong>实现主从集群自动故障恢复，保证高可用</strong></p><ul><li><strong>监控</strong> ping</li><li><strong>自动故障恢复</strong> 选主</li><li><strong>通知</strong>  哨兵会向订阅了相关事件的客户端发送通知，告知它们集群状态的变化</li></ul><p>每秒ping每个实例，某节点发现实例未响应（主观下线），超半数都发现其未响应（客观下线）</p><p><strong>哨兵选主规则：</strong></p><ul><li>优先级+offset值</li><li>主从断联时间长短</li><li>运行id越小优先级高</li></ul><p><strong>脑裂问题</strong>-两个主节点（哨兵选完主节点后，原本主节点可能还在被客户端写入，原主节点回复与哨兵联系后降级未从节点，但此时新版数据在其身上，导致数据出错）</p><p><strong>解决办法：保证宕机时不写入</strong></p><ul><li>设置主节点至少有一个从节点才允许写入</li><li>数据同步延时不能超5s</li></ul><h2 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h2><p><strong>解决海量数据存储&#x2F;高并发写问题</strong></p><ul><li><p>多个master，每个master不同数据，存放在不同服务器</p></li><li><p>每个master多个slave</p></li><li><p>master之间ping检测状态</p></li><li><p>客户端访问任意结点可路由到需要的结点</p></li></ul><p><strong>数据如何存储和读取？</strong></p><ul><li>引入哈希槽（16384个）</li><li>每个插槽分配到不同的实例</li><li>key的有效部分（大括号里内容&#x2F;本身）计算哈希值，对16384取余找到插槽，在里面找对应实例</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>Redis单线程为什么这么快？</p><ul><li><p>内存操作</p></li><li><p>单线程避免不必要上下文切换</p></li><li><p>I&#x2F;O多路复用，非阻塞IO</p></li><li><p>性能瓶颈是<strong>网络延迟</strong>而不是执行速度</p></li></ul><p>什么是I&#x2F;O多路复用模型？</p><ul><li><strong>用户空间和内核空间</strong></li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/%E5%86%85%E6%A0%B8.png" alt="内核"></p><ul><li>阻塞IO</li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/%E9%98%BB%E5%A1%9EIO.png" alt="阻塞IO"></p><ul><li>非阻塞IO<ul><li>需要轮询检查 I&#x2F;O 操作是否完成，线程可以利用等待 I&#x2F;O 的时间执行其他任</li></ul></li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png" alt="非阻塞IO"></p><ul><li><p>IO多路复用（单线程监听多个socket，哪个socket好了先进行哪个）</p></li><li><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="IO多路复用"></p><ul><li>监听socket的方式：select和poll提醒用户进程就绪，但序需遍历找到该socket。epoll会将就绪的Socket直接写入用户空间</li></ul></li><li><p>Redis网络模型</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" alt="网络模型"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h1&gt;&lt;h2 id=&quot;缓存穿透&quot;&gt;&lt;a href=&quot;#缓存穿透&quot; class=&quot;headerlink&quot; title=&quot;缓存穿透&quot;&gt;&lt;/a&gt;缓存穿透&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://senwh.github.io/2025/01/06/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://senwh.github.io/2025/01/06/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2025-01-06T13:05:22.000Z</published>
    <updated>2025-02-11T07:12:05.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>前中后序</strong></p><p><strong>层序</strong>：deep作参，此方法似乎操作只能是最终输出一个层序的列表， 实际上并没有按层序访问</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p><strong>前序</strong> 中左右</p><ul><li>栈：中右左入栈 ，其中：（中）是某种操作（<strong>元素放进数组</strong>）之类。其实只有右左子节点在入栈</li></ul><p><strong>中序</strong> 左中右</p><ul><li>如果是按前序的方法，右中左入栈，不能对左进行操作，因为左可能还有其子树需要先访问</li><li>1、中先入栈，直到无左节点  2、弹出-&gt;操作-&gt;右节点入栈（又重复1）</li></ul><p><strong>后序</strong> 左右中</p><ul><li>修改前序（中左右入栈），得到数组后反序</li></ul><p><strong>层序</strong></p><ul><li>队列：记录每层数量，每层对应数量入队</li></ul><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">LC104.二叉树的最大深度</a></p><ul><li>层序迭代或递归&#x2F;递归最简洁</li></ul><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">LC111. 二叉树的最小深度</a></p><ul><li>层序迭代</li></ul><p><a href="https://leetcode.cn/problems/symmetric-tree/">LC101. 对称二叉树</a></p><ul><li>递归，外侧内侧</li><li>迭代，双端队列 队列分别首尾进队 offerFirst&#x2F;offerLast</li><li>迭代，普通队列</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><ul><li>ArrayList 头插 addFirst</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;树的遍历&quot;&gt;&lt;a href=&quot;#树的遍历&quot; class=&quot;headerlink&quot; title=&quot;树的遍历&quot;&gt;&lt;/a&gt;树的遍历&lt;/h1&gt;&lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>栈与队列</title>
    <link href="https://senwh.github.io/2025/01/04/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://senwh.github.io/2025/01/04/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2025-01-04T13:48:17.000Z</published>
    <updated>2025-01-06T13:04:04.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p><strong>Stack常用：</strong>push()\pop()\empty()\peek()</p><p><strong>Queue常用：</strong></p><ul><li>LinkList offer()\poll()\isEmpty()</li></ul><p><strong>ArrayDeque</strong> 既可用做栈也可用做队列</p><h2 id="栈应用"><a href="#栈应用" class="headerlink" title="栈应用"></a>栈应用</h2><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">LC.150. 逆波兰表达式求值</a></p><ul><li><p>String转数字Integer.valueOf(s) </p></li><li><p>数字匹配str.matches(“-?\d+”)  </p></li><li><p>字符转数字 Character.getNumericValue()</p></li></ul><h2 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h2><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">LC.239. 滑动窗口最大值*</a></p><ul><li><strong>单调队列</strong>：使用双端队列组装单调队列，每次加入比较队列尾部元素</li></ul><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">LC.347. 前 K 个高频元素</a></p><ul><li><strong>优先队列</strong><ul><li>底层是堆的原理</li><li>常用法：       <ul><li>PriorityQueue&lt;int[]&gt; pq &#x3D; new PriorityQueue&lt;&gt;((pair1, pair2) -&gt; pair2[1] - pair1[1]); 该表示为小顶堆反之大顶堆</li></ul></li><li>哈希表常用<ul><li>遍历：Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()</li><li>获取key和值getKey(),getValue()</li></ul></li></ul></li></ul><p><strong>Tips</strong></p><ul><li><p>堆</p><ul><li><p>完全二叉树+任意父节点大于（小于）等于 左右孩子</p></li><li><p>实际存储：顺序存储（数组）</p></li><li><p>建堆：自底向上：先建子堆 -》再自上至底   O（n）</p></li><li><p>排序：堆顶与最后元素交换，向下调整新元素 O（n*logn）n-1交换 * logn调整</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Stack常用：&lt;/strong&gt;push()&#92;pop()&#92;empty()&#92;peek()&lt;/p&gt;
&lt;p&gt;&lt;s</summary>
      
    
    
    
    
  </entry>
  
</feed>
