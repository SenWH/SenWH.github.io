<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>部落格</title>
  
  
  <link href="https://senwh.github.io/atom.xml" rel="self"/>
  
  <link href="https://senwh.github.io/"/>
  <updated>2025-02-24T14:58:29.430Z</updated>
  <id>https://senwh.github.io/</id>
  
  <author>
    <name>Sen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试篇-集合</title>
    <link href="https://senwh.github.io/2025/02/23/%E9%9D%A2%E8%AF%95%E7%AF%87-%E9%9B%86%E5%90%88/"/>
    <id>https://senwh.github.io/2025/02/23/%E9%9D%A2%E8%AF%95%E7%AF%87-%E9%9B%86%E5%90%88/</id>
    <published>2025-02-23T09:48:00.000Z</published>
    <updated>2025-02-24T14:58:29.430Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E9%9B%86%E5%90%88/collection_1.png" alt="{90A2DF6F-BC50-4AB4-9A8C-C1BA96A29902}"></p><p><strong>复杂度</strong>：常幂对指阶</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="栈内存和堆内存的区别"><a href="#栈内存和堆内存的区别" class="headerlink" title="栈内存和堆内存的区别"></a>栈内存和堆内存的区别</h3><ul><li><strong>存储内容</strong>：<ul><li>栈内存存储局部变量、方法调用和方法参数，包括基本数据类型和对象引用。</li><li>堆内存存储所有通过 <code>new</code> 创建的对象和数组。</li></ul></li><li><strong>生命周期</strong>：<ul><li>栈内存的生命周期与线程的生命周期相关，方法执行完毕后栈内存自动释放。</li><li>堆内存的生命周期从程序启动到程序结束，对象被垃圾回收器自动回收。</li></ul></li><li><strong>分配方式</strong>：<ul><li>栈内存的分配和释放是自动且高效的，由 JVM 直接管理。</li><li>堆内存的分配和释放是由垃圾回收器自动管理的。</li></ul></li><li><strong>灵活性</strong>：<ul><li>栈内存的分配和释放是固定大小的，只能存储局部变量和方法调用的信息。</li><li>堆内存可以动态地分配和释放内存，存储大量的对象和数据。</li></ul></li><li><strong>性能</strong>：<ul><li>栈内存的访问速度快，因为它是连续的内存结构。</li><li>堆内存的访问速度相对较慢，因为它是非连续的内存结构，并且需要进行垃圾回收。</li></ul></li></ul><p>int[] array &#x3D; {a,b,c}</p><ul><li>array作为变量，指向数组首地址，放入栈内存</li><li>数组元素存在堆内存中</li></ul><h3 id="为什么数组索引从0开始？"><a href="#为什么数组索引从0开始？" class="headerlink" title="为什么数组索引从0开始？"></a>为什么数组索引从0开始？</h3><ul><li>数组寻址公式 A[i]&#x3D;baseAddress+i*dataTypeSize，如果索引从1开始就是（i-1）,cpu要做减法操作，多做一次指令，性能下降</li></ul><h3 id="源码逻辑"><a href="#源码逻辑" class="headerlink" title="源码逻辑"></a>源码逻辑</h3><ul><li>add<ul><li>扩容：new &#x3D; old + (old&gt;&gt;1)，增加1.5倍</li><li>扩充完，Arrys.copyOf将元素复制到新的数组</li></ul></li></ul><h3 id="底层实现原理"><a href="#底层实现原理" class="headerlink" title="底层实现原理"></a>底层实现原理</h3><ul><li><p>动态数组（Array）</p><ul><li>底层用了Arrays.copyOf</li></ul></li><li><p>初始数组容量为0，空数据时容量为10</p></li><li><p>最大容量Integer.MAX_VALUE - 8</p><ul><li><strong>2^31 - 1</strong></li></ul></li><li><p>每次扩容1.5倍，每次扩容拷贝数组</p></li><li><p>过程</p><ul><li>size+1与当前数组长度比较</li><li>大于-则grow扩容</li><li>copy完后添加新数据</li><li>返回boolean</li></ul></li></ul><p><strong>new ArrayList（10）扩容了几次？</strong></p><p>分析源码后，只是实例了一个ArrayList没扩容</p><h3 id="如何实现数组和List之间转换？"><a href="#如何实现数组和List之间转换？" class="headerlink" title="如何实现数组和List之间转换？"></a>如何实现数组和List之间转换？</h3><ul><li><p>list-&gt;Arrays –list.toArray(new String(list.size())) ,底层是用的copy，值改变不会同时改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(this.a, 0, a, 0, size);</span><br></pre></td></tr></table></figure><p>底层用java调用C++,复制的快</p></li><li><p>Arrays-&gt;list –Arrays.aslist(a)，直接赋值，值改变另外一个值也变化（共享地址）</p></li></ul><h3 id="ArrayList-和-LinkedList-区别"><a href="#ArrayList-和-LinkedList-区别" class="headerlink" title="ArrayList 和 LinkedList 区别"></a>ArrayList 和 LinkedList 区别</h3><ul><li>底层数据结构</li><li>操作效率</li><li>内存</li><li>非线程安全<ul><li>局部变量是安全的：局部变量存储在方法的<strong>栈帧</strong>中。每个线程都有自己的独立栈帧，栈帧是线程私有的，不会被其他线程访问。因此，局部变量是线程安全的</li><li>Collections.synchronizedList封装</li></ul></li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>红黑树（平衡二叉搜索树）：</strong>左根右，根叶黑，不红红，黑路同</p><p><strong>散列冲突：</strong>拉链法（哈希表的每个槽（bucket）存储一个链表头指针）-当冲突增多-&gt;退化为链表-&gt;改造为红黑树（内存换时间）</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>底层用hash表+链表+红黑树<ul><li>当链个数&gt;&#x3D;8，创建红黑树（如果槽数量小于64，则扩容，继续链表。否则建树）</li><li>链个数&lt;6，退化成链表</li></ul></li><li>扩容：一个哈希表本质为数组 ：Node[ ]<ul><li>懒惰加载，初始未加载数组</li><li>若未大于最大容量，容量为当前容量的两倍，新阈值翻倍</li><li>既未设置初始容量也未设置阈值，则使用默认初始容量<code>DEFAULT_INITIAL_CAPACITY</code>（通常是16），并根据默认负载因子<code>DEFAULT_LOAD_FACTOR</code>（通常是0.75）计算新阈值（数组容量*加载因子）</li><li>**扩容时会拆链表:满足<code>(e.hash &amp; oldCap) == 0</code>结点还在原来位置，否则放到下标[j+oldCap]**（有点再分配的意思）<ul><li><strong>e.hash大家不是一样的吗？为什么新表能在不同位置？</strong></li><li>答：不一样！位置一样hash不一定一样，通过(n - 1) &amp; hash找到下标</li></ul></li></ul></li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E9%9B%86%E5%90%88/resize.png" alt="{13D4762B-0723-43B9-A822-2B6FE00763D8}"></p><ul><li>底层的hash(key) <code>return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code><ul><li>函数算完后拿自己高位和地位做异或运算后放地位-减少哈希冲突 (h &gt;&gt;&gt; 16)-高16为移到低16位，高位全0，hash更平均</li><li><strong>找下标：通过(n - 1) &amp; hash找到下标，n是resize的值</strong></li></ul></li><li>jdk1.8之前无红黑树</li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E9%9B%86%E5%90%88/put.png" alt="{B3634F08-C704-497C-B5BF-3C19F5802E62}"></p><h3 id="为什么HashMap数组长度一定要是2的幂"><a href="#为什么HashMap数组长度一定要是2的幂" class="headerlink" title="为什么HashMap数组长度一定要是2的幂"></a>为什么HashMap数组长度一定要是2的幂</h3><ul><li>在找下标时（计算索引），与运算比取模效率高</li><li>在扩容时拆链表时，重新分配时与运算比+效率高（就位置+旧容量）</li></ul><h3 id="HashMap-JDK1-7-多线程死循环的问题"><a href="#HashMap-JDK1-7-多线程死循环的问题" class="headerlink" title="HashMap JDK1.7 多线程死循环的问题"></a>HashMap JDK1.7 多线程死循环的问题</h3><ul><li>迁移到新表时用的是头插法（故结点会逆序）</li><li>JDK1.8 用尾插法解决</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E9%9B%86%E5%90%88/collection_1.png&quot; alt=&quot;{90A2DF6F-BC50-4AB4-9A8C-C1BA96A29902}&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试篇-消息中间件</title>
    <link href="https://senwh.github.io/2025/02/23/%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://senwh.github.io/2025/02/23/%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2025-02-23T08:26:21.000Z</published>
    <updated>2025-02-23T09:47:37.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/mq.png" alt="{021133AB-663B-41DE-9F76-0902095DF914}"></p><h2 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h2><p><strong>问题：</strong></p><ul><li>生产者宕机，消息未达交换机&#x2F;队列</li><li>mq宕机，队列消息队列</li><li>消费者宕机</li></ul><p><strong>解决方案：</strong></p><ul><li>确认机制<ul><li>生产者确认机制：生产者发送消息后，会收到 RabbitMQ 的确认消息，失败重发</li><li>消费者确认机制：mq收到消费者ack才删除消息（手动-自己调api、自动-无异常则ack，none-立刻删除）</li></ul></li><li>消息持久化(mq默认内存存储消息)<ul><li>交换机&#x2F;队列持久化：mq重启保留队列</li><li>消息持久化：写入磁盘</li></ul></li></ul><p><strong>失败如何处理：</strong></p><ul><li>回调方法重发</li><li>记录日志</li><li>记录到数据库后重发，发完后删除</li><li>消费者处理异常则让mq重试，达到最大重试次数后放入异常交换机转人工处理</li></ul><h2 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h2><p><strong>定义：消费者的ack丢失，导致mq重复发消息，消费者重复消费</strong></p><p><strong>解决方案：</strong></p><ul><li>标识消息id（业务唯一标识）</li><li>幂等方案：锁（性能下降）-是指在分布式系统中，同一个操作无论执行多少次，结果都是一致的。</li></ul><h2 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h2><p><strong>延迟队列</strong>：进入队列的消息会被延迟消费，<strong>实现方式</strong>：死信交换机+TTL</p><p><strong>场景：</strong>超时订单（<strong>超时，需要进行取消订单、释放库存等操作</strong>）、限时优惠、定时发布（支付剩余时间…）</p><p><strong>死信（dead letter） 满足以下情况之一</strong></p><ul><li>当消费者使用 <code>basic.reject</code> 或 <code>basic.nack</code> 方法拒绝消息时，如果 <code>requeue</code> 参数设置为 <code>false</code></li><li>消息 TTL 过期（min（队列过期时间，消息过期时间））</li><li>队列满，后进消息成为死信</li></ul><p><strong>死信-&gt;死信交换机-&gt;消费者从死信队列中消费消息，处理超时订单</strong>，如果在延时过程中处理了订单，也要等TTL到期，让消费者处理</p><h2 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h2><p><strong>原因：</strong>消费者消费速度&lt;生产者生产速度</p><p><strong>解决方案：</strong></p><ul><li>增加消费者数量</li><li>消费者内部使用线程池</li><li>扩充队列容积<ul><li>惰性队列：接收消息后存入磁盘、消费时才从磁盘取出、支持数百万消息存储</li></ul></li></ul><h2 id="高可用机制"><a href="#高可用机制" class="headerlink" title="高可用机制"></a>高可用机制</h2><p><strong>集群</strong></p><ul><li>标准集群：多节点，共享相同的元数据，消息在某节点找不到时，会从其他节点传过来</li><li>镜像模式：主从模式，n主，每个主在别的节点中有备份。操作在主节点完成后同步-同步完成前主节点宕机（消息丢失）</li><li>仲裁协议-采用Raft协议，减少丢失，保证强一致性</li></ul><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="如何保证消息不丢失-1"><a href="#如何保证消息不丢失-1" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RabbitMQ&quot;&gt;&lt;a href=&quot;#RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ&quot;&gt;&lt;/a&gt;RabbitMQ&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%B</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="https://senwh.github.io/2025/02/22/%E8%B4%AA%E5%BF%83/"/>
    <id>https://senwh.github.io/2025/02/22/%E8%B4%AA%E5%BF%83/</id>
    <published>2025-02-22T05:32:51.000Z</published>
    <updated>2025-02-22T07:41:16.096Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/wiggle-subsequence/">LC.376. 摆动序列</a></p><ul><li>快慢指针</li><li>curdiff-prediff，峰谷思想</li></ul><p><a href="https://leetcode.cn/problems/maximum-subarray/">LC.53. 最大子数组和</a> ***</p><ul><li>一个数记录历史最大值，另一个数记录累计和，和小于0重置，大于0往下走</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/wiggle-subsequence/&quot;&gt;LC.376. 摆动序列&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快慢指针&lt;/li&gt;
&lt;li&gt;curdiff-prediff，峰谷思想&lt;/li&gt;
&lt;/ul&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>电商项目-演进文档</title>
    <link href="https://senwh.github.io/2025/02/18/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE-%E6%BC%94%E8%BF%9B%E6%96%87%E6%A1%A3/"/>
    <id>https://senwh.github.io/2025/02/18/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE-%E6%BC%94%E8%BF%9B%E6%96%87%E6%A1%A3/</id>
    <published>2025-02-18T14:11:17.000Z</published>
    <updated>2025-02-24T10:42:28.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高并发交易系统架构优化实践演进文档"><a href="#高并发交易系统架构优化实践演进文档" class="headerlink" title="高并发交易系统架构优化实践演进文档"></a>高并发交易系统架构优化实践演进文档</h1><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><table><thead><tr><th>版本号</th><th>发布日期</th><th>主要变更</th><th>负责人</th></tr></thead><tbody><tr><td>v1.0.0</td><td>2025-1-10</td><td>基础功能完成（JWT）</td><td>L同学</td></tr><tr><td>v1.1.0</td><td>2025-02-22</td><td>缓存优化</td><td>L同学</td></tr><tr><td>v1.1.1</td><td>2025-02-24</td><td>分布式锁控制并发（库存扣减）</td><td>L同学</td></tr><tr><td>v1.1.2</td><td>2025-02-24</td><td>高频计数器</td><td></td></tr><tr><td>v1.2.0</td><td>2025-02-26</td><td>订单超时自动取消（延迟队列）</td><td></td></tr><tr><td>v1.2.1</td><td>2025-02-27</td><td>异步通知和日志（MQ，           低库存预警通过邮件、短信通知商家。）</td><td></td></tr><tr><td>v1.2.2</td><td>2025-02-29</td><td>秒杀流量削峰</td><td></td></tr><tr><td>v1.3.0</td><td>2025-03-01</td><td>数据一致性保障</td><td></td></tr><tr><td>v1.3.1</td><td>2025-03-03</td><td>监控和压测</td><td></td></tr></tbody></table><hr><h2 id="版本详情"><a href="#版本详情" class="headerlink" title="版本详情"></a>版本详情</h2><h3 id="v1-1-0-性能优化专项"><a href="#v1-1-0-性能优化专项" class="headerlink" title="v1.1.0 - 性能优化专项"></a>v1.1.0 - 性能优化专项</h3><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><strong>测试目标</strong>：</p><ul><li><p>登录接口（模拟高并发用户）</p></li><li><p>订单创建接口（核心业务）</p></li><li><p>商品查询接口（高频读操作）</p></li><li><p>问题发现：JMeter压测订单创建接口，100并发下TPS仅85，错误率12%</p></li><li><p>核心痛点：</p><ol><li><p>数据库连接池频繁耗尽</p></li><li><p>商品查询接口响应时间波动大（300ms~1200ms）</p></li></ol></li></ul><h4 id="主要改动"><a href="#主要改动" class="headerlink" title="主要改动"></a>主要改动</h4><p><strong>1. 数据库优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 新增联合索引（原无索引）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> order_detail </span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_order_product (order_id, product_id);</span><br></pre></td></tr></table></figure><p><strong>2. 连接池调优</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">20</span> <span class="string">→</span> <span class="number">50</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">3000</span> <span class="string">→</span> <span class="number">10000</span></span><br><span class="line">      <span class="attr">idle-timeout:</span> <span class="number">600000</span> <span class="string">→</span> <span class="number">300000</span></span><br></pre></td></tr></table></figure><p><strong>3. 热点数据缓存</strong></p><ul><li><p>Redis</p></li><li><p>序列化优化</p><ul><li>默认-&gt;JSON</li></ul></li><li><p>防穿透（空间换时间）</p><ul><li>缓存空数据</li><li><strong>布隆过滤器</strong></li></ul></li><li><p>防雪崩</p><ul><li>设置随机过期时间</li></ul></li></ul><h4 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h4><table><thead><tr><th>指标</th><th>优化前</th><th>优化后</th><th>测试条件</th></tr></thead><tbody><tr><td>订单创建TPS</td><td>85</td><td>220</td><td>100并发，持续30s</td></tr><tr><td>商品查询P99</td><td>1200ms</td><td>350ms</td><td>200并发，持续1min</td></tr><tr><td>数据库连接等待</td><td>78%</td><td>12%</td><td>峰值压力期间</td></tr></tbody></table><hr><blockquote><p>通过引入Redis缓存，我们将高频查询的响应时间从200ms降低到5ms，QPS从500提升到3000，数据库CPU负载下降83%。同时设计了空值缓存和随机过期策略，缓存命中率稳定在98%以上，未出现缓存雪崩问题。</p></blockquote><h3 id="v1-2-0-高可用改造"><a href="#v1-2-0-高可用改造" class="headerlink" title="v1.2.0 - 高可用改造"></a>v1.2.0 - 高可用改造</h3><h4 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h4><ul><li>线上问题：促销活动期间出现订单重复创建</li><li>监控发现：优惠券核销接口CPU使用率持续&gt;90%</li></ul><h4 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h4><p><strong>1. 幂等性保障</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="comment">// 使用Redis原子操作</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.opsForValue()</span><br><span class="line">    .setIfAbsent(<span class="string">&quot;order:unique:&quot;</span> + orderNo, <span class="string">&quot;1&quot;</span>, <span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line"><span class="keyword">if</span> (!Boolean.TRUE.equals(result)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;重复订单&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 本地限流器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="comment">// 基于Guava的RateLimiter</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">500.0</span>); <span class="comment">// 500请求/秒</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/coupon/use&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">useCoupon</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!rateLimiter.tryAcquire()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;系统繁忙，请稍后重试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果验证"><a href="#效果验证" class="headerlink" title="效果验证"></a>效果验证</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plantuml复制代码@startuml</span><br><span class="line">left to right direction</span><br><span class="line">| 压测阶段 |</span><br><span class="line">:50并发;</span><br><span class="line">|#AntiqueWhite| 优化前 |</span><br><span class="line">:错误率: 15%;</span><br><span class="line">|#LightGreen| 优化后 |</span><br><span class="line">:错误率: 0.3%;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><hr><h2 id="技术债务与规划"><a href="#技术债务与规划" class="headerlink" title="技术债务与规划"></a>技术债务与规划</h2><h3 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h3><ol><li>订单历史数据查询缓慢（当前方案：直接查MySQL）</li><li>短信服务偶发超时（超时率0.7%）</li></ol><h3 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h3><ul><li>v1.3.0（2024-03-20）：接入Elasticsearch优化查询</li><li>v1.4.0（2024-04-01）：消息队列解耦短信服务</li></ul><hr><h2 id="附录：性能测试报告"><a href="#附录：性能测试报告" class="headerlink" title="附录：性能测试报告"></a>附录：性能测试报告</h2><h3 id="订单创建接口压测对比"><a href="#订单创建接口压测对比" class="headerlink" title="订单创建接口压测对比"></a>订单创建接口压测对比</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">csv复制代码并发数, 优化前TPS, 优化后TPS, 错误率变化</span><br><span class="line">50, 120, 280, 8% → 0%</span><br><span class="line">100, 85, 220, 12% → 0.5%</span><br><span class="line">200, 32, 180, 28% → 2.1%</span><br></pre></td></tr></table></figure><h3 id="内存分析截图"><a href="#内存分析截图" class="headerlink" title="内存分析截图"></a>内存分析截图</h3><p><img src="https://cloud.siliconflow.cn/playground/jvm_heap.png" alt="JVM内存优化对比"></p><h3 id="文档使用建议："><a href="#文档使用建议：" class="headerlink" title="文档使用建议："></a>文档使用建议：</h3><ol><li><strong>版本粒度</strong>：每个版本聚焦一个主题（如性能优化&#x2F;高可用改造） </li><li><strong>问题驱动</strong>：先描述发现的问题，再给出解决方案 </li><li><strong>数据佐证</strong>：关键优化点必须附带压测数据对比 </li><li><strong>可视化呈现</strong>：适当使用：   - 表格对比（优化前后数据）   - PlantUML流程图（技术方案示意图）   - 架构图（使用draw.io或Excalidraw绘制）</li></ol><h3 id="面试讲述技巧："><a href="#面试讲述技巧：" class="headerlink" title="面试讲述技巧："></a>面试讲述技巧：</h3><ol><li>按「问题→方案→结果」三段式描述每个优化点 2. 准备1-2个详细的技术决策案例：     <strong>案例：缓存选型决策</strong>   - 候选方案：     1. Redis单缓存（成本低，但网络延迟影响性能）     </li><li>Caffeine本地缓存（速度快，但集群一致性难保证）     </li><li>多级缓存方案（本地缓存+Redis）   - 决策依据：     - 业务特点：商品信息变更频率低（每天&lt;10次）     - 最终选择：Caffeine本地缓存 + 广播刷新   - 实现效果：商品查询RT降低82%</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;高并发交易系统架构优化实践演进文档&quot;&gt;&lt;a href=&quot;#高并发交易系统架构优化实践演进文档&quot; class=&quot;headerlink&quot; title=&quot;高并发交易系统架构优化实践演进文档&quot;&gt;&lt;/a&gt;高并发交易系统架构优化实践演进文档&lt;/h1&gt;&lt;h2 id=&quot;版本管理&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试篇-框架</title>
    <link href="https://senwh.github.io/2025/02/17/%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/"/>
    <id>https://senwh.github.io/2025/02/17/%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/</id>
    <published>2025-02-17T12:13:04.000Z</published>
    <updated>2025-02-23T08:24:42.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="Bean线程安全问题"><a href="#Bean线程安全问题" class="headerlink" title="Bean线程安全问题"></a><strong>Bean线程安全问题</strong></h3><p>Spring框架中单例Bean是线程安全吗？</p><ul><li><strong>成员方法内状态可修改变量需考虑线程安全</strong>（DAO Service层变量通常不变）</li><li>单例模式，各线程共享该bean</li></ul><p>解决方案</p><ul><li>加锁</li><li>@Scope 设置为prototype 多例，每个新的线程会新建变量</li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><strong>面向切面编程</strong> ：对某个类方法源代码不进行修改的情况下实现增强</p><p><strong>关键元素</strong>：通过<strong>切面</strong>描述<strong>通知（存放共性（增强）操作的方法，被存在通知类中）</strong>和<strong>切入点（从连接点中选取）</strong>的关系</p><p><strong>步骤</strong></p><ol><li>导入坐标</li><li>制作连接点（DAO层通常是增删改查）</li><li>制作通知（类）</li><li>定义切入点-&gt;切入点的定义依托一个无实际意义的方法 <ul><li>为了更细粒度的控制，可以增加自定义注解，在需要增强方法前做好标识</li></ul></li><li>绑定切入点和通知关系（切面）-定义增强时机(before，around….)</li></ol><ul><li>4.5的操作实际上都在通知类</li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/AOP_1.png" alt="AOP_1"></p><p><strong>AOP底层实现</strong>：如果目标类使用了增强，则生成目标对象的代理对象执行方法（原因是不能乱动原来的对象）</p><p><strong>使用场景：</strong></p><ul><li>记录操作日志</li><li>缓存处理</li><li>Spring内置的事务处理<ul><li>声明式事务管理（AOP）<ul><li>检查到@Transactional时，：Spring 使用 <code>TransactionInterceptor</code> 作为事务的切面（Aspect）。它定义了事务的前置增强（开始事务）和后置增强（提交或回滚事务）。</li><li>通过 <code>DataSourceTransactionManager</code>（或类似的事务管理器）与数据库交互</li></ul></li><li>编程式事务管理（侵入）</li></ul></li></ul><h2 id="Spring中事务失效场景"><a href="#Spring中事务失效场景" class="headerlink" title="Spring中事务失效场景"></a><strong>Spring中事务失效场景</strong></h2><ul><li>异常捕获处理<ul><li>遇到异常时只有自己主动抛出异常事务才会回滚</li><li>throw new RuntimeException(e)</li></ul></li><li>抛出检查异常<ul><li>Spring默认只回滚非检查异常（运行时异常，RuntimeExcption）</li><li>@Transactional配置（rollbackFor&#x3D;Exception.class）</li></ul></li><li>非public方法<ul><li>只有pulic方法才有事务管理</li></ul></li></ul><h2 id="Spring-bean的生命周期"><a href="#Spring-bean的生命周期" class="headerlink" title="Spring bean的生命周期"></a><strong>Spring bean的生命周期</strong></h2><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/bean.png" alt="bean"></p><ul><li><p>实例化：Spring 容器（如 <code>AnnotationConfigApplicationContext</code> 或 XML 配置的容器）根据 Bean 的定义（如 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 或通过 XML 配置的 <code>&lt;bean&gt;</code>）创建一个对象实例</p></li><li><pre><code class="java">@Autowired</code></pre></li><li><p><code>Aware</code> 接口是一系列接口的统称，它们允许 Spring 容器中的 Bean 获取运行时上下文信息，如 Spring 的上下文（<code>ApplicationContext</code>）、Bean 工厂（<code>BeanFactory</code>）、资源加载器（<code>ResourceLoader</code>）（<strong>安全和权限管理等</strong>）</p></li><li><p>BeanPostProcessor用对对象进行增强（前&#x2F;后）</p><ul><li>AOP 的实现需要在 Bean 初始化之后创建代理对象，因此会使用到 BeanPostProcessor（动态代理：JDK 动态代理需要实现接口，而 CGLIB 代理是基于字节码生成的）</li></ul></li><li><p>实例化包括：@PostConstruct 和 <code>InitializingBean</code> 的 <code>afterPropertiesSet</code> 方法</p></li></ul><h2 id="Spring中的循环依赖问题"><a href="#Spring中的循环依赖问题" class="headerlink" title="Spring中的循环依赖问题"></a>Spring中的循环依赖问题</h2><p><strong>定义：</strong>两个或多个 Bean 互相依赖对方，导致 Spring 容器在初始化这些 Bean 时陷入死锁或无法正常注入的情况</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-1.png" alt="{spring-1.png}"></p><p><strong>如何解决？</strong></p><p><strong>三级缓存</strong></p><ul><li>一级缓存：存放完整的单例-完成初始化后</li><li>二级缓存：可存放早期的bean对象-依赖注入阶段</li><li>三级缓存：缓存的是ObjectFactory-实例化时</li></ul><p><strong>本质：</strong>根据Bean的创建周期，提前暴露（二级在初始化前暴露，缓存的是非代理对象），当注入的是代理对象时，需要ObjectFactory（可生成普通对象和代理对象）生成。初始化后，只留一级缓存，剩下两个被清空</p><p><strong>如果在构造函数时产生循环引用-此时三级缓存不行了，因为这是在初始化的过程中</strong></p><p>解决：@Lazy，延迟实例化另一个对象</p><h2 id="SpringMvc的执行流程"><a href="#SpringMvc的执行流程" class="headerlink" title="SpringMvc的执行流程"></a>SpringMvc的执行流程</h2><h3 id="JSP阶段"><a href="#JSP阶段" class="headerlink" title="JSP阶段"></a>JSP阶段</h3><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-2.png" alt="spring-2"></p><ul><li>映射器返回的是<code>HandlerExecutionChain</code>：带有 <code>@Controller</code> 注解的类中某个带有 <code>@RequestMapping</code> 注解的方法+拦截器列表</li></ul><h3 id="前后端分离阶段"><a href="#前后端分离阶段" class="headerlink" title="前后端分离阶段"></a>前后端分离阶段</h3><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-3.png" alt="spring-3"></p><ul><li>前后端分离了，所以不用在后端生成页面，只需要返回JSON数据让前端自己处理</li></ul><h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><p><strong>配置流程</strong></p><ul><li><strong>启动类注解</strong>：Spring Boot 的启动类使用 <code>@SpringBootApplication</code> 注解，该注解是一个组合注解，包含 <code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 和 <code>@Configuration</code>。</li><li><strong>自动配置触发</strong>：<code>@EnableAutoConfiguration</code> 注解会触发自动配置机制，Spring Boot 会扫描 <code>META-INF/spring.factories</code> 文件，加载其中定义的自动配置类。</li><li><strong>条件注解过滤</strong>：Spring Boot 会根据条件注解（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>）判断是否需要加载某个配置类或 Bean。</li><li><strong>Bean 注册</strong>：符合条件的配置类会被加载，其中定义的 Bean 会被注册到 Spring 容器中，供其他组件使用。</li><li><strong>依赖注入</strong>：其他组件可以通过 <code>@Autowired</code> 或构造函数注入的方式使用这些自动装配的 Bean。</li></ul><p> <code>@EnableAutoConfiguration：</code>包含了两个元注解：</p><ul><li><p><code>@AutoConfigurationPackage 和 @Import(EnableAutoConfigurationImportSelector.class)</code></p></li><li><p><code>@AutoConfigurationPackage</code> 注解的作用是将<strong>当前应用的包路径注册到 Spring 容器</strong>中，以便 Spring Boot 能够在后续的自动配置过程中正确地扫描和加载相关的组件</p></li><li><p><code>@Import(EnableAutoConfigurationImportSelector.class)</code>从 <code>META-INF/spring.factories</code> 文件中加载配置类</p></li><li><p><code>spring.factories</code> 文件是 Spring Boot 自动配置的核心，包含了一系列的配置类，这些配置类通过<strong>条件注解</strong>（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnProperty</code> 等）来决定是否被加载</p></li></ul><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><p><strong>Spring</strong></p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-4.png" alt="{spring-4}"></p><p><strong>SpringMvc</strong></p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-5.png" alt="{spring-5}"></p><p><strong>SpringBoot</strong></p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%A1%86%E6%9E%B6/spring-6.png" alt="{spring-6}"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h3 id=&quot;Bean线程安全问题&quot;&gt;&lt;a href=&quot;#Bean线程安全问题&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试篇-数据库</title>
    <link href="https://senwh.github.io/2025/02/14/%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://senwh.github.io/2025/02/14/%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2025-02-14T09:14:09.000Z</published>
    <updated>2025-02-17T12:11:23.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="定位慢查询"><a href="#定位慢查询" class="headerlink" title="定位慢查询"></a>定位慢查询</h2><p><strong>慢查询定义：</strong>执行时间超过一定阈值（可配置）的 SQL 查询</p><p><strong>如何定位？</strong></p><ul><li>开源工具<ul><li>调式工具 Arthas</li><li>运维工具：Prometheus、Skywalking</li></ul></li><li>Mysql自带慢日志<ul><li>开始开关&#x2F;设置时间阈值（超过该阈值判定为慢日志）</li></ul></li></ul><h2 id="SQL执行计划"><a href="#SQL执行计划" class="headerlink" title="SQL执行计划"></a>SQL执行计划</h2><p><strong>如何优化慢查询？</strong></p><ul><li>EXPLAIN&#x2F;DESC命令获取查询命令执行信息<ul><li>key判断是否命中索引</li><li>Extra给出是否回表查询</li><li>type<img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/msql-1.png" alt="msql-1"></li></ul></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>定义：一种排好序的<strong>数据结构</strong>-&gt;可以帮mysql高效获取数据（类似一张表，不是一个值）</p><p><strong>为什么需要？</strong></p><ul><li>查询磁盘慢在寻址，索引绑定磁盘地址后，检索索引即可省去寻址过程</li></ul><p>其数据结构：k-V，k为值，V为磁盘地址</p><ul><li><p>二叉树：最差情况O（n）</p></li><li><p>红黑树</p><ul><li>比AVL平衡条件更宽松（适合频繁的插入删除，需要的旋转次数较少）</li><li>百万级数目-&gt;树的高度会很高</li></ul></li><li><p>Hash表</p><ul><li>索引key做Hash计算，得到对应data的磁盘地址（速度快）</li><li>仅满足”&#x3D;“，<strong>不支持范围查询</strong></li><li>hash冲突</li></ul></li><li><p>B Tree</p><ul><li>叶节点具有相同深度，指针为空，数据索引递增（磁盘文件地址和索引保存在一起）</li></ul></li><li><p>B+Tree（mysql底层存储数据结构）</p><ul><li>非叶子节点不存data（磁盘地址）</li><li>叶子节点包含所有索引，节点间用指针连接</li><li>便于<strong>区间查询</strong>（叶子双向链表）</li></ul></li></ul><p>Mysql默认一个节点（16KB），有多个组构成（8B-索引+6B-下一级指针）&#x3D;约1170组</p><p><strong>叶子节点（8B+约1KB（data））：key-value的形式</strong></p><p><strong>查询过程</strong>：将结点加载进内存（相比磁盘可以忽略不计）-折半查找，寻找下一层</p><p><strong>存储引擎</strong></p><p><strong>MyISAM</strong></p><ul><li>磁盘含三个文件，分别存：文件结构、data、索引</li><li>匹配索引到data中查找</li><li>非聚集索引（data，索引放不同文件）</li><li>第一次IO访问索引（叶子的data部分放的是主键值）（二级索引-例：用name去查主键），第二次IO访问data（<strong>回表</strong>），速度慢</li></ul><p><strong>InnoDB</strong></p><ul><li>磁盘含两个文件，分别存：文件结构、data+索引</li><li>聚集索引（data+索引放一个文件）</li><li>速度快，牺牲空间</li></ul><p><strong>为什么建议InnoDB必须建主键？</strong>&#x2F;为什么用自增整型</p><ul><li><p><strong>如果没有主键，mysql会找一不含重复元素的列作为主键&#x2F;自己生成主键（牺牲数据库资源），ROWID</strong></p></li><li><p>整型比大小更快（查找效率更高）</p></li><li><p>如果不用自增， 新节点插入中间节点容易产生分裂，重建B+树较麻烦</p></li></ul><p><strong>联合索引</strong>（索引主键是几个key的组合(a,b,c)）</p><ul><li>最左前缀原则<ul><li>底层存储结构（如果条件没name，需要全表查找age，age只在固定name时节点才有序）<img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/msql-2.png" alt="msql-2"></li></ul></li></ul><p><strong>覆盖索引</strong></p><p><strong>定义：查询使用了索引，并且需要返回的列，在索引中能全部找到</strong></p><p><strong>主键索引</strong>：如果字段 <code>A</code> 是主键，那么 <code>A</code> 的 B+ 树索引是主键索引，主键索引的叶子节点存储的是主键值和数据行的聚集地址（数据行的实际存储位置）。主键索引是存储数据行的唯一标识</p><p><strong>二级索引</strong>：二级索引的叶子节点存储的是索引字段的值和主键值的组合。如果查的值刚好是索引字段的值，就不用回表了-&gt;所谓覆盖索引</p><p>例：如果查找只需要返回Arm和id，则该二级索引已经够了，不需要回表</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/msql-3.png" alt="msql-3"></p><ul><li>避免使用select* ,因为除了条件是id时是聚集索引，其他都要回表（非覆盖）</li><li>解决MYSQL超大分页（limit分页越往后效率越低，数据库不能知道第n行的位置，需要一行行扫描）<ul><li>B+树会从第一个叶节点一个个往下找</li><li>如果没有覆盖索引，每一个节点需要回表一次</li><li>SELECT *<br>FROM tb_sku t,<br> (SELECT id FROM tb_sku ORDER BY id LIMIT 9000000, 10) a<br>WHERE t.id &#x3D; a.id; 该覆盖查询-&gt;获得的id不需要回表+子查询只需回表10条，相比较前者性能得到优化</li></ul></li></ul><p><strong>索引创建原则</strong></p><ul><li>数据量大，查询频繁的表建立索引（单表超10w数据）</li><li>针对常做为where,order by, group by操作的字段建立索引</li><li>使用区分度高的列做索引</li><li>针对字符串字段做索引时，由于其很长，可只用其前缀</li><li>尽量使用联合索引，很多时候可以覆盖索引（避免回表）</li></ul><p><strong>什么时候索引失效？</strong></p><ul><li>违反最左前缀法则</li><li><strong>查询范围右边的列不能使用索引</strong></li><li>在索引列上运算</li><li>字符串不加单引号</li><li>%开头的模糊索引</li></ul><p><strong>谈谈对sql的优化经验</strong></p><ul><li>表设计</li><li>索引优化</li><li>sql语句设计</li><li>主从复制、读写分离</li><li>分库分表</li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>定义：一组操作的集合，把所有操作一起提交&#x2F;撤销，同时成功&#x2F;失败</p><h2 id="特性：ACID"><a href="#特性：ACID" class="headerlink" title="特性：ACID"></a>特性：ACID</h2><ul><li><p>原子性（Atomicity）最小操作单位</p><ul><li>实现方式<ul><li>日志记录：记录事物操作，用于回滚</li><li>事务回滚：两个阶段-回滚未完成事物，前滚已完成事物</li></ul></li></ul></li><li><p>一致性（Consistency）事物完成时<strong>数据一致</strong></p><ul><li>数据完整性约束<ul><li><strong>实体完整性</strong>：主键约束要求表中的每行记录都有一个唯一的标识符，确保数据的唯一性和可识别性。</li><li><strong>参照完整性</strong>：外键约束确保两个表之间的关系是有效的，例如，子表中的外键值必须存在于主表的主键值中。</li><li><strong>域完整性</strong>：数据类型和取值范围约束确保数据的格式和内容符合预定的规则，例如，年龄字段必须是正整数且小于某个上限。</li></ul></li><li>事务逻辑验证：人为规则：每个部门只能有一个经理</li><li>并发控制（隔离性级别）</li><li>事物回滚&#x2F;恢复</li></ul></li><li><p>隔离性（Isolation）事物不受外部并发操作影响</p><ul><li><p>实现方式</p><ul><li><p>锁机制：共享锁（读锁）和排他锁（写锁）</p></li><li><p>事务隔离级别（隔离性 低-&gt;高）：</p><ul><li>读未提交（Read Uncommitted）（脏读、不可重复读和幻读）</li><li>读已提交（Read Committed）（不可重复读和幻读）</li><li>可重复读（Repeatable Read）（保证对<strong>同一数据</strong>的多次读取结果是一致的，但没有防止其他事务插入新的数据）（幻读）<strong>（mysql默认模式）</strong> <strong>标准SQL中RR允许幻读，但MySQL的InnoDB通过MVCC+间隙锁在RR级别避免了幻读（这是MySQL的特性，非SQL标准要求）</strong></li><li>串行化（Serializable）（性能下降）</li></ul></li><li><p><strong>多版本控制（MVCC）</strong></p></li></ul></li><li><p>事务并发执行时的隔离性问题（下述的前提是<strong>在同一事务内</strong>）</p><ul><li>脏读：一个事务读取了另一个未提交事务写入的数据</li><li>不可重复读：读取到已提交的数据，但数据已被修改</li><li>幻读：读取到已提交的数据，但数据集的行数发生了变化（新增或删除）</li></ul></li></ul></li><li><p>持久性（Durability）提交&#x2F;回滚，对数据改变是永久的</p><ul><li>实现方式<ul><li>存储子系统（磁盘）</li><li>日志</li></ul></li></ul></li></ul><h2 id="undo（回滚）-log-和redo（恢复）-log"><a href="#undo（回滚）-log-和redo（恢复）-log" class="headerlink" title="undo（回滚） log 和redo（恢复） log"></a>undo（回滚） log 和redo（恢复） log</h2><p>缓冲池：主存区域，以一定频率刷新到磁盘</p><p>数据页：InnoDB磁盘管理最小单位，默认16KB（行数据）</p><p><strong>redo</strong>：<strong>记录物理页的变化</strong>，<strong>实现持久性</strong> 包括 redo log buffer(缓存) -&gt;redo log file（磁盘）-&gt;定期刷新</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/redo.png" alt="redo"></p><p><strong>作用：数据同步到磁盘出现问题时，根据该日志可以恢复</strong></p><p><strong>undo log：逻辑日志（delete记录为insert）（关注未提交事物的回滚），实现事务一致性和原子性</strong></p><p><strong>事物处理过程：</strong></p><ul><li><strong>事务开始</strong>：当一个事务开始时，数据库系统会为其分配一个唯一的事务标识符，并开始记录该事务的 Redo Log 和 Undo Log。</li><li><strong>数据修改</strong>：在事务执行过程中，每当对数据库进行修改操作时，数据库系统会首先将相应的 Redo Log 写入缓冲区，然后记录 Undo Log。</li><li><strong>事务提交</strong>：在事务提交之前，数据库系统会确保所有的 Redo Log <strong>都已被写入磁盘</strong>，然后更<strong>新事务的状态为已提交</strong>。此时，数据修改的结果才会被永久保存。</li><li><strong>事务回滚</strong>：如果事务需要回滚，数据库系统会根据 Undo Log 中的记录，撤销该事务对数据库所做的所有修改</li></ul><p><strong>恢复过程：</strong></p><ul><li><strong>检查点</strong>：数据库系统<strong>定期创建检查点</strong>，记录当前数据库的状态和已提交事务的信息。</li><li><strong>数据库崩溃</strong>：当数据库系统崩溃时，所有未完成的事务都会被挂起，而 Redo Log 和 Undo Log 仍然保存在磁盘上。</li><li><strong>恢复</strong>：<ul><li><strong>重做阶段</strong>：数据库系统首先重放 Redo Log 中的所有记录，将数据库<strong>恢复到检查点时的状态</strong>，并应用所有已提交事务的修改。</li><li><strong>回滚阶段</strong>：然后，数据库系统根据 Undo Log，<strong>撤销所有未提交事务的修改</strong>，确保数据库的一致性。</li></ul></li></ul><h2 id="MVCC-multi-verison-concurrence-control"><a href="#MVCC-multi-verison-concurrence-control" class="headerlink" title="MVCC (multi-verison concurrence control)"></a>MVCC (multi-verison concurrence control)</h2><p>定义：一种数据库并发控制机制，通过为<strong>每行数据维护多个版本</strong>来实现读写操作的并行执行。它允许读操作不被写操作阻塞，写操作也不被读操作阻塞，从而提高了数据库的并发性能</p><p><strong>实现方式</strong></p><ul><li>隐藏字段：每行数据包含隐藏的元数据（创建该版本的事务ID，指向该版本的Undo Log的指针，行ID用于唯一标识一行数据）</li><li>Undo Log版本链：每次修改对应一个版本 追加存储在Undo Log<img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/mvcc-1.png" alt="mvcc-1"></li><li><strong>Read View</strong>：包含（当前<strong>活跃</strong>(未提交)事务的ID集合，当前活跃事务的最大ID&#x2F;最小ID，创建该Read View的事务ID）<img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/mvcc-2.png" alt="mvcc-2"></li></ul><p>即定义了一组规则（随着隔离级别改动-RC-RR），控制事务出现避免并发问题。根据该规则，以RC为例，第一个RV读的是事务2的结果（它已提交），第二个读的是（事务3）</p><p><strong>RC在每一次执行快照生成读视图</strong></p><p><strong>RR在只在事务第一次执行生成都视图</strong></p><p><strong>快照读：</strong>并不直接读取数据库中的最新数据，而是读取数据的一个快照版本。这个快照版本是事务开始时数据库的状态。<strong>允许读操作不被写操作阻塞</strong></p><p><strong>总结：</strong></p><ul><li>事务按照<strong>现实业务根据自身需求选择适合的隔离级别</strong>，之所以需要有隔离级别是为了提升数据库的性能(不然所有事务都用串行化就好了),，另外越高的隔离级别会导致更多锁竞争和回滚。</li><li>不同的隔离级别方式有其实现方法，其中MVCC支持RC和RR。因为不同的隔离级别又对应不同的并发问题，开发者只要考虑该业务是否接收这样的并发问题即可确定设置的隔离级别。例：在RR中用户读的不是最新的版本信息，但用户的需求并不是要最新的，而是要解决脏读和不可重复读的问题，此时用RR没问题。快照隔离</li><li>在RR级别下：<strong>读操作</strong>：看到的是事务开始时的快照版本。<strong>写操作</strong>：仍然会看到最新提交的数据（通过当前读）</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h2><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93/syn.png" alt="syn"></p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p><strong>时机：</strong></p><ul><li>单表数据量超1000w</li><li>上述优化解决不了性能问题</li><li>IO瓶颈&#x2F;CPU瓶颈</li></ul><p><strong>拆分类型：</strong></p><ul><li>垂直分库：根据业务将不同表拆分到不同库</li><li>垂直分表：根据字段属性将不同字段拆分到不同表</li><li>水平分库：一个库数据拆分到多个库（物理地拆分）<ul><li>寻库需路由</li></ul></li><li>水平分表：一个表数据拆分到多个表</li></ul><p><strong>产生问题</strong></p><ul><li>分布式事务一致性</li><li>跨节点关联查询</li><li>跨节点分页、排序函数</li><li>主键避重</li></ul><p><strong>解决方案</strong>-&gt;中间键</p><ul><li>sharding-sphere</li><li>mycat</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;优化&quot;&gt;&lt;a href=&quot;#优化&quot; class=&quot;headerlink&quot; title=&quot;优化&quot;&gt;&lt;/a&gt;优化&lt;/h1&gt;&lt;h2 id=&quot;定位慢查询&quot;&gt;&lt;a href=&quot;#定位慢查询&quot; class=&quot;headerlink&quot; title=&quot;定位慢查询&quot;&gt;&lt;/a&gt;定位慢查</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>项目进阶-《mall项目》</title>
    <link href="https://senwh.github.io/2025/02/12/%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6-%E3%80%8Amall%E9%A1%B9%E7%9B%AE%E3%80%8B/"/>
    <id>https://senwh.github.io/2025/02/12/%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6-%E3%80%8Amall%E9%A1%B9%E7%9B%AE%E3%80%8B/</id>
    <published>2025-02-12T09:32:28.000Z</published>
    <updated>2025-02-12T09:32:28.745Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>回溯</title>
    <link href="https://senwh.github.io/2025/02/11/%E5%9B%9E%E6%BA%AF/"/>
    <id>https://senwh.github.io/2025/02/11/%E5%9B%9E%E6%BA%AF/</id>
    <published>2025-02-11T07:13:27.000Z</published>
    <updated>2025-02-20T12:16:12.044Z</updated>
    
    <content type="html"><![CDATA[<p><strong>递归和回溯的关系</strong>：递归是实现回溯的手段</p><p><strong>回溯题目思路：</strong></p><ul><li>构建树<img src="/./%E5%9B%9E%E6%BA%AF/tree.png" alt="tree"></li><li>for(横向)</li><li>递归纵向</li></ul><p><strong>模板</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><a href="https://leetcode.cn/problems/combinations/">LC77. 组合</a></p><ul><li>将问题构建为一颗n叉树，递归遍历-回溯模板</li><li>ArrayList适用查找替换，LinkedList适用增删</li></ul><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">LC17. 电话号码的字母组合</a></p><p><a href="https://leetcode.cn/problems/combination-sum/">LC39. 组合总和</a></p><ul><li><pre><code class="java">path.remove(path.size() - 1);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  Arrays.sort(candidates);</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><a href="https://leetcode.cn/problems/combination-sum-ii/">LC40. 组合总和 II</a></p><ul><li>去重剪枝</li><li>思考树的横纵向与递归的关系</li></ul><h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">LC131. 分割回文串</a>***</p><ul><li>横向为切割位置</li><li>纵向为剩余字符串</li><li>StringBuilder</li></ul><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">LC93. 复原 IP 地址</a></p><ul><li>横向切割位置</li><li>判别有效字符<ul><li>sb-&gt;string</li><li><strong>Integer.parseInt() String转Int</strong></li><li>0开头长度&gt;1</li><li>255</li></ul></li><li>分隔符连接：String.join(“.”, path)</li></ul><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/subsets-ii/">LC90. 子集 II</a></p><ul><li>去重，同组合II方法一致</li><li>数组有序后，对树叶去重</li></ul><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">LC491. 非递减子序列</a></p><ul><li><strong>数组在无序时，用HashSet去重</strong></li></ul><p><a href="https://leetcode.cn/problems/permutations-ii/">LC47. 全排列 II</a>***</p><ul><li>used数组去重横向（false） 纵向（true）</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://leetcode.cn/problems/reconstruct-itinerary/">LC332. 重新安排行程</a>（超时）</p><ul><li>字符串的排序    Collections.sort(tickets,(a,b)-&gt;a.get(1).compareTo(b.get(1)));</li><li>字符串比较 tickets.get(i).get(0).equals(path.getLast())</li></ul><p><a href="https://leetcode.cn/problems/n-queens/">LC51. N 皇后</a>***</p><ul><li>三数组 列、45[row+col]、135[row-col+n-1]</li></ul><p><a href="https://leetcode.cn/problems/sudoku-solver/">LC37. 解数独</a></p><ul><li>树枝为数度数字，树枝为位置</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;递归和回溯的关系&lt;/strong&gt;：递归是实现回溯的手段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回溯题目思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建树&lt;img src=&quot;/./%E5%9B%9E%E6%BA%AF/tree.png&quot; alt=&quot;tree&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试篇-Redis</title>
    <link href="https://senwh.github.io/2025/01/07/%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/"/>
    <id>https://senwh.github.io/2025/01/07/%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/</id>
    <published>2025-01-07T12:56:00.000Z</published>
    <updated>2025-02-12T08:33:44.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>定义：（恶意）查询一个DB中没有的数据，无返回结果存入Redis，导致每次到需要访问内存</p><p>解决方案：</p><ul><li>缓存空数据<ul><li>缺点：随着空数据增多，内存消耗大</li></ul></li><li>布隆过滤器（在内存中）：放在查询和Redis之间，将所有的key预先加载到过滤器中,每次先查询输入的key是否存在，再查询内存（此时一定存在value）。用一个bit数组（只有0，1），定义多个Hash函数，每次将输入哈希映射到bit位图中，若各位置都为（1）即判断数据存在。<ul><li>缺点：有误判风险，bit越大，Hash函数越多，可减小风险。</li><li>实现方案：Redission&#x2F;Guava</li></ul></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>定义：（Redis）key设置了过期时间，过期后收到大量并发请求，在缓存重建前，DB被压垮；无缓存的大并发不属于这种情况</p><p>解决方案：</p><ul><li>互斥锁：第一个线程若没查到缓存，上锁直到重建完后再允许其他线程查询<ul><li>保持数据一致性，但性能差（其他线程一直等待解锁）</li></ul></li><li>逻辑过期：等待时间过期到先不清除数据，等待逻辑过期时间。这段时间若有并发数据，开启新线程上锁更新过期时间，旧线程或其他线程不需等待新线程解锁，返回旧数据。直到解锁才用新数据。<ul><li>新旧数据容易产生不一致，但性能高</li><li>缓存中含逻辑过期时间和实际过期时间，前后比后者大。</li></ul></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>定义：缓存采用了相同的设置时间，导致缓存在某一时间同时失效&#x2F;Redis宕机（GG），大量并发请求到DB，导致DB压力过重。</p><p>解决方案：</p><ul><li>过期时间+随机值</li><li>集群服务：哨兵模式、集群模式？</li><li>缓存业务添加降级限流策略？ ngxin&#x2F;spring cloud gateway</li><li>业务添加多级缓存</li></ul><h2 id="双写一致性-mysql如何与redis同步"><a href="#双写一致性-mysql如何与redis同步" class="headerlink" title="双写一致性(mysql如何与redis同步)"></a>双写一致性(mysql如何与redis同步)</h2><p>场景一：一致性要求高</p><ul><li>写操作：先删缓存（数据库还没更新）&#x2F;先修改数据库（缓存过期，数据还没更新就读）&#x2F;延时双删（数据库修改前后都删一次缓存，等数据库修改完毕再删，延时多久不能把控）都可能出现<strong>脏数据</strong></li><li>绝对保证一致：读写操作加锁。读操作用共享锁（允许读），写操作用排他锁（不允许其他操作）-redission </li><li>性能差</li></ul><p>场景二：运行延迟一致</p><ul><li>异步通知</li><li>MQ中间件</li><li>canal中间件</li></ul><h2 id="持久化（防止数据redis丢失）"><a href="#持久化（防止数据redis丢失）" class="headerlink" title="持久化（防止数据redis丢失）"></a>持久化（防止数据redis丢失）</h2><p><strong>RDB（Redis Database Backup file）</strong>：防止redis故障数据丢失，将数据备份到磁盘</p><ul><li>执行原理：bgsave fork（克隆）主进程得到子进程，子进程共享主进程内存数据。完成fork后读取内存数据并写入RDB文件。（子进程把页表（虚拟地址和物理地址的映射关系）copy过来慢慢读内存数据，不阻塞主进程）</li><li>在读内存数据过程中，若主进行对内存数据有写操作，将那块内存copy一个副本专用于写（此时似乎和紫当前子进程数据不一致了），更新页表，重新开bgsave本分</li><li>两次备份会丢失</li><li>二进制压缩，体积较小</li></ul><p><strong>AOF（Append Only File）</strong>：将redis写操作命令记录在AOF文件中</p><ul><li><p>设定频率（执行写操作命令）</p></li><li><p>记录命令比RDB文件要大</p></li></ul><h2 id="数据过期策略-内存过期数据如何处理）"><a href="#数据过期策略-内存过期数据如何处理）" class="headerlink" title="数据过期策略(内存过期数据如何处理）"></a>数据过期策略(内存过期数据如何处理）</h2><ul><li><p>惰性删除：数据过期后，访问了才会删（节省查询过期时间的操作时间，但浪费内存）</p></li><li><p>定期删除：每隔一段时间，从数据库里随机抽出一定数量key检查，过期即删除</p><ul><li>slow模式 扫描频率10hz 每次不超过25ms</li><li>fast模式 两次间隔不超过2ms 每次不超过1ms</li></ul></li><li><p>两者配合使用</p></li></ul><h2 id="数据淘汰策略（为已满的redis添加新key，如何替换）"><a href="#数据淘汰策略（为已满的redis添加新key，如何替换）" class="headerlink" title="数据淘汰策略（为已满的redis添加新key，如何替换）"></a>数据淘汰策略（为已满的redis添加新key，如何替换）</h2><ul><li>noeviction：不淘汰，满了不给进</li><li>volatile-ttl：TTL值被淘汰</li><li>allkeys-random：random<ul><li>无太大频率，冷热区分</li></ul></li><li>volatile-random：对设置TTL的key random</li><li>allkeys-lru：基于LRU算法淘汰（Least Recently Used）<ul><li>有冷、热点数据区分</li><li>保证留下的是高频数据</li></ul></li><li>allkeys-lfu：基于LFU算法淘汰（Least Frequently Used）<ul><li>短时高频数据</li><li>促销商品，短时间内可能高频访问，但它不是热点数据</li></ul></li><li>volatile-lfu<ul><li>有需要置顶的数据（不设置TTL，永远不会被淘汰）</li></ul></li></ul><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>在服务集群部署（nginx反向代理）的情况下，互斥锁解决不了多个JVM线程并发访问数据不同步问题</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/%E4%BA%92%E6%96%A5%E9%94%81.png" alt="互斥锁"></p><p>引入外部锁（分布式锁）</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" alt="互斥锁"></p><h2 id="redisson"><a href="#redisson" class="headerlink" title="redisson"></a>redisson</h2><ul><li>底层原理：setnx（set if not exist） + lua脚本（保证原子性）</li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/setnx.png" alt="setnx"></p><p><strong>如何设置超时时间？</strong></p><ul><li>时间预估+给锁续期（watch-dog。每隔releaseTime&#x2F;3时间续期）</li></ul><p><strong>可重入?</strong> (一个线程内多次加锁)</p><ul><li>用hash结构存储线程信息和重入次数</li><li>防止死锁（一个线程多次进入一个锁的保护块，可能会被阻塞）</li></ul><p><strong>可以解决主从一致性问题？</strong>（主节点负责写修改同步。子节点负责读操作）</p><ul><li>用redisson提供的红锁解决（在超过一半结点都获得锁才认为成功上锁、避免有些结点宕机上锁失败）（性能低），可以用zookeeper来实现</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><ul><li>主从全量同步（将主节点（Master）上的所有数据完整地复制到从节点（Slave）。这种方式不考虑数据是否已经存在于从节点，而是重新传输所有数据）</li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.png" alt="主从同步"></p><p><strong>判断第一次请求</strong>：replication id 标识两个为同一个数据集，若不一致，证明为第一次同步，为子节点更新id值</p><p><strong>保证只同步差异部分</strong>：每次主节点更新数据同时更新offset值，同步更新offset的部分给子节点</p><ul><li><p>增量同步（只将主节点上自上次同步以来发生变化的数据同步到从节点。这种方式通过记录数据的变化来减少不必要的数据传输）</p><p>主节点会记录二进制日志（binlog），从节点通过I&#x2F;O线程读取这些日志，并通过SQL线程应用这些日志来保持数据一致性</p></li></ul><p><strong>主从的方式保证不了redis高可用，主节点宕机</strong></p><h2 id="哨兵模式（Sentinel）"><a href="#哨兵模式（Sentinel）" class="headerlink" title="哨兵模式（Sentinel）"></a>哨兵模式（Sentinel）</h2><p><strong>实现主从集群自动故障恢复，保证高可用</strong></p><ul><li><strong>监控</strong> ping</li><li><strong>自动故障恢复</strong> 选主</li><li><strong>通知</strong>  哨兵会向订阅了相关事件的客户端发送通知，告知它们集群状态的变化</li></ul><p>每秒ping每个实例，某节点发现实例未响应（主观下线），超半数都发现其未响应（客观下线）</p><p><strong>哨兵选主规则：</strong></p><ul><li>优先级+offset值</li><li>主从断联时间长短</li><li>运行id越小优先级高</li></ul><p><strong>脑裂问题</strong>-两个主节点（哨兵选完主节点后，原本主节点可能还在被客户端写入，原主节点回复与哨兵联系后降级未从节点，但此时新版数据在其身上，导致数据出错）</p><p><strong>解决办法：保证宕机时不写入</strong></p><ul><li>设置主节点至少有一个从节点才允许写入</li><li>数据同步延时不能超5s</li></ul><h2 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h2><p><strong>解决海量数据存储&#x2F;高并发写问题</strong></p><ul><li><p>多个master，每个master不同数据，存放在不同服务器</p></li><li><p>每个master多个slave</p></li><li><p>master之间ping检测状态</p></li><li><p>客户端访问任意结点可路由到需要的结点</p></li></ul><p><strong>数据如何存储和读取？</strong></p><ul><li>引入哈希槽（16384个）</li><li>每个插槽分配到不同的实例</li><li>key的有效部分（大括号里内容&#x2F;本身）计算哈希值，对16384取余找到插槽，在里面找对应实例</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>Redis单线程为什么这么快？</p><ul><li><p>内存操作</p></li><li><p>单线程避免不必要上下文切换</p></li><li><p>I&#x2F;O多路复用，非阻塞IO</p></li><li><p>性能瓶颈是<strong>网络延迟</strong>而不是执行速度</p></li></ul><p>什么是I&#x2F;O多路复用模型？</p><ul><li><strong>用户空间和内核空间</strong></li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/%E5%86%85%E6%A0%B8.png" alt="内核"></p><ul><li>阻塞IO</li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/%E9%98%BB%E5%A1%9EIO.png" alt="阻塞IO"></p><ul><li>非阻塞IO<ul><li>需要轮询检查 I&#x2F;O 操作是否完成，线程可以利用等待 I&#x2F;O 的时间执行其他任</li></ul></li></ul><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png" alt="非阻塞IO"></p><ul><li><p>IO多路复用（单线程监听多个socket，哪个socket好了先进行哪个）</p></li><li><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="IO多路复用"></p><ul><li>监听socket的方式：select和poll提醒用户进程就绪，但序需遍历找到该socket。epoll会将就绪的Socket直接写入用户空间</li></ul></li><li><p>Redis网络模型</p><p><img src="/./%E9%9D%A2%E8%AF%95%E7%AF%87-Redis/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" alt="网络模型"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h1&gt;&lt;h2 id=&quot;缓存穿透&quot;&gt;&lt;a href=&quot;#缓存穿透&quot; class=&quot;headerlink&quot; title=&quot;缓存穿透&quot;&gt;&lt;/a&gt;缓存穿透&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://senwh.github.io/2025/01/06/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://senwh.github.io/2025/01/06/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2025-01-06T13:05:22.000Z</published>
    <updated>2025-02-11T07:12:05.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>前中后序</strong></p><p><strong>层序</strong>：deep作参，此方法似乎操作只能是最终输出一个层序的列表， 实际上并没有按层序访问</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p><strong>前序</strong> 中左右</p><ul><li>栈：中右左入栈 ，其中：（中）是某种操作（<strong>元素放进数组</strong>）之类。其实只有右左子节点在入栈</li></ul><p><strong>中序</strong> 左中右</p><ul><li>如果是按前序的方法，右中左入栈，不能对左进行操作，因为左可能还有其子树需要先访问</li><li>1、中先入栈，直到无左节点  2、弹出-&gt;操作-&gt;右节点入栈（又重复1）</li></ul><p><strong>后序</strong> 左右中</p><ul><li>修改前序（中左右入栈），得到数组后反序</li></ul><p><strong>层序</strong></p><ul><li>队列：记录每层数量，每层对应数量入队</li></ul><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">LC104.二叉树的最大深度</a></p><ul><li>层序迭代或递归&#x2F;递归最简洁</li></ul><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">LC111. 二叉树的最小深度</a></p><ul><li>层序迭代</li></ul><p><a href="https://leetcode.cn/problems/symmetric-tree/">LC101. 对称二叉树</a></p><ul><li>递归，外侧内侧</li><li>迭代，双端队列 队列分别首尾进队 offerFirst&#x2F;offerLast</li><li>迭代，普通队列</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><ul><li>ArrayList 头插 addFirst</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;树的遍历&quot;&gt;&lt;a href=&quot;#树的遍历&quot; class=&quot;headerlink&quot; title=&quot;树的遍历&quot;&gt;&lt;/a&gt;树的遍历&lt;/h1&gt;&lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>栈与队列</title>
    <link href="https://senwh.github.io/2025/01/04/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://senwh.github.io/2025/01/04/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2025-01-04T13:48:17.000Z</published>
    <updated>2025-01-06T13:04:04.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p><strong>Stack常用：</strong>push()\pop()\empty()\peek()</p><p><strong>Queue常用：</strong></p><ul><li>LinkList offer()\poll()\isEmpty()</li></ul><p><strong>ArrayDeque</strong> 既可用做栈也可用做队列</p><h2 id="栈应用"><a href="#栈应用" class="headerlink" title="栈应用"></a>栈应用</h2><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">LC.150. 逆波兰表达式求值</a></p><ul><li><p>String转数字Integer.valueOf(s) </p></li><li><p>数字匹配str.matches(“-?\d+”)  </p></li><li><p>字符转数字 Character.getNumericValue()</p></li></ul><h2 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h2><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">LC.239. 滑动窗口最大值*</a></p><ul><li><strong>单调队列</strong>：使用双端队列组装单调队列，每次加入比较队列尾部元素</li></ul><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">LC.347. 前 K 个高频元素</a></p><ul><li><strong>优先队列</strong><ul><li>底层是堆的原理</li><li>常用法：       <ul><li>PriorityQueue&lt;int[]&gt; pq &#x3D; new PriorityQueue&lt;&gt;((pair1, pair2) -&gt; pair2[1] - pair1[1]); 该表示为小顶堆反之大顶堆</li></ul></li><li>哈希表常用<ul><li>遍历：Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()</li><li>获取key和值getKey(),getValue()</li></ul></li></ul></li></ul><p><strong>Tips</strong></p><ul><li><p>堆</p><ul><li><p>完全二叉树+任意父节点大于（小于）等于 左右孩子</p></li><li><p>实际存储：顺序存储（数组）</p></li><li><p>建堆：自底向上：先建子堆 -》再自上至底   O（n）</p></li><li><p>排序：堆顶与最后元素交换，向下调整新元素 O（n*logn）n-1交换 * logn调整</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Stack常用：&lt;/strong&gt;push()&#92;pop()&#92;empty()&#92;peek()&lt;/p&gt;
&lt;p&gt;&lt;s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="https://senwh.github.io/2024/12/24/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://senwh.github.io/2024/12/24/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2024-12-24T13:34:41.000Z</published>
    <updated>2025-01-02T10:45:48.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h1><ul><li>常用库函数：<ul><li>字符串转数组 s.toCharArray() &#x2F; 数组转字符串new String(s_char)</li><li>s.concat(str)连接字符串</li><li>StringBuilder ()-&gt;可用append追加字符串，toString()用于输出字符串，insert(index ,str), setCharAt(index,char),charAt</li></ul></li><li>字符串不可变，不能修改某一位置的值，只能创建新的空间</li></ul><h2 id="反转单词"><a href="#反转单词" class="headerlink" title="反转单词"></a>反转单词</h2><ul><li>法1：先反转整个字符串，再反转单词</li><li>法2：取word后，头插法-&gt;StringBuilder </li><li>去多余空格，String.trim()可以去前后，或直接判断</li></ul><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">LC151. 反转字符串中的单词</a></p><h2 id="字串匹配"><a href="#字串匹配" class="headerlink" title="字串匹配"></a>字串匹配</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本特征&quot;&gt;&lt;a href=&quot;#基本特征&quot; class=&quot;headerlink&quot; title=&quot;基本特征&quot;&gt;&lt;/a&gt;基本特征&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;常用库函数：&lt;ul&gt;
&lt;li&gt;字符串转数组 s.toCharArray() &amp;#x2F; 数组转字符串new S</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://senwh.github.io/2024/12/07/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://senwh.github.io/2024/12/07/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2024-12-07T13:03:35.000Z</published>
    <updated>2025-01-01T13:59:24.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ul><li>常见结构：数组&#x2F;set&#x2F;map</li><li>常用于判断某元素是否出现过</li></ul><h2 id="字母异位词"><a href="#字母异位词" class="headerlink" title="字母异位词"></a>字母异位词</h2><p><strong>字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。</strong></p><ul><li>两种解法：Map-HashMap&#x2F;用ascii数组-&gt;records[word-‘a’]-适用于’a’-‘z’的情况</li></ul><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/valid-anagram/">LC242. 有效的字母异位词</a></p><ul><li>相同字母的个数通过循环+-判断是否用完</li><li>异位词相关题目的母体</li></ul><p><a href="https://leetcode.cn/problems/group-anagrams/">LC49. 字母异位词分组</a></p><ul><li>注意分List和String方法的使用</li></ul><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">LC438. 找到字符串中所有字母异位词</a></p><ul><li>滑动窗口(否则超时)</li></ul><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ul><li><p>去除重复元素</p></li><li><p>Set&lt;&gt; &#x3D; new HashSet&lt;&gt;()</p></li><li><p>常用：contains&#x2F;add&#x2F;clear&#x2F;size&#x2F;for(i:set)</p></li></ul><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">LC349. 两个数组的交集</a></p><h2 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h2><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/4sum-ii/">LC454. 四数相加 II</a></p><ul><li>两数和四数和都一样，使用HashMap存n遍历&#x2F;n^2遍历，用空间换另外一半的时间</li></ul><h2 id="N数之和"><a href="#N数之和" class="headerlink" title="N数之和"></a>N数之和</h2><ul><li>难点在于保证三元组不重复-&gt;如何执行去重操作</li></ul><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/3sum/">LC15. 三数之和</a></p><ul><li>返回数值而不是索引，联想-&gt;排序</li><li>双指针</li><li>排完序后的去重方便很多-&gt;第一位和前一位比，left和right都与下一位比，一样的跳过即可</li></ul><p><a href="https://leetcode.cn/problems/4sum/">LC18. 四数之和</a></p><ul><li>参照三数之和思路，注意思考四元组第二个数的去重方式</li><li>考虑int相加后越界问题，用long来转换结果</li></ul><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ul><li><p>size()是列表方法 length()是数组方法</p></li><li><p>List操作</p><ul><li>size()&#x2F;add()&#x2F;get()</li></ul></li><li><p>Arrays操作</p><ul><li>sort</li><li>asList()</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本特征&quot;&gt;&lt;a href=&quot;#基本特征&quot; class=&quot;headerlink&quot; title=&quot;基本特征&quot;&gt;&lt;/a&gt;基本特征&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;常见结构：数组&amp;#x2F;set&amp;#x2F;map&lt;/li&gt;
&lt;li&gt;常用于判断某元素是否出现过&lt;/li&gt;
&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://senwh.github.io/2024/11/29/%E9%93%BE%E8%A1%A8/"/>
    <id>https://senwh.github.io/2024/11/29/%E9%93%BE%E8%A1%A8/</id>
    <published>2024-11-29T03:25:48.000Z</published>
    <updated>2024-12-01T07:35:02.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手撕链表"><a href="#手撕链表" class="headerlink" title="手撕链表"></a>手撕链表</h1><h2 id="单链表-双链表"><a href="#单链表-双链表" class="headerlink" title="单链表&#x2F;双链表"></a>单链表&#x2F;双链表</h2><p><strong>解题思路</strong></p><ul><li>注意空节点没有指针域</li><li>添加虚拟节点dummyHead，可减少对头节点的判别</li></ul><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/design-linked-list/">LC.707. 设计链表</a></p><p><a href="https://leetcode.cn/problems/reverse-linked-list/">LC206. 反转链表</a></p><p><strong>解题思路</strong></p><ul><li>两种解法：迭代&#x2F;递归</li><li>除了pre和cur指针，还要定义temp存cur.next</li></ul><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">LC24. 两两交换链表中的节点</a></p><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">LC面试题 02.07. 链表相交</a></p><ul><li>注意是找两个指针地址一致</li></ul><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">LC19. 删除链表的倒数第 N 个结点</a></p><ul><li>遍历两次&#x2F;快慢指针</li></ul><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">LC142. 环形链表 II</a></p><ul><li>访问标志数组&#x2F;快慢指针</li><li>判断入口位置：头指针位置和相遇位置同时同速出发相遇的位置（画图可知）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;手撕链表&quot;&gt;&lt;a href=&quot;#手撕链表&quot; class=&quot;headerlink&quot; title=&quot;手撕链表&quot;&gt;&lt;/a&gt;手撕链表&lt;/h1&gt;&lt;h2 id=&quot;单链表-双链表&quot;&gt;&lt;a href=&quot;#单链表-双链表&quot; class=&quot;headerlink&quot; title=&quot;单链表</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>树莓派5配置</title>
    <link href="https://senwh.github.io/2024/11/26/%E6%A0%91%E8%8E%93%E6%B4%BE5%E9%85%8D%E7%BD%AE/"/>
    <id>https://senwh.github.io/2024/11/26/%E6%A0%91%E8%8E%93%E6%B4%BE5%E9%85%8D%E7%BD%AE/</id>
    <published>2024-11-26T08:15:18.000Z</published>
    <updated>2024-11-26T17:47:16.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在线配置（荐）"><a href="#在线配置（荐）" class="headerlink" title="在线配置（荐）"></a>在线配置（荐）</h1><h2 id="命令行连接wifi"><a href="#命令行连接wifi" class="headerlink" title="命令行连接wifi"></a>命令行连接wifi</h2><p><code>nmcli dev wifi connect &quot;你的WiFi名称&quot; password &quot;你的WiFi密码&quot; ifname wlan0</code></p><p>执行完后自动生成后面离线配置</p><h1 id="离线配置"><a href="#离线配置" class="headerlink" title="离线配置"></a>离线配置</h1><h2 id="1-检查-NetworkManager-是否已安装-检查-NetworkManager-服务状态"><a href="#1-检查-NetworkManager-是否已安装-检查-NetworkManager-服务状态" class="headerlink" title="1. 检查 NetworkManager 是否已安装 &amp; 检查 NetworkManager 服务状态"></a>1. 检查 NetworkManager 是否已安装 &amp; 检查 NetworkManager 服务状态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep network-manager</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status NetworkManager</span><br></pre></td></tr></table></figure><h2 id="2-创建uuid"><a href="#2-创建uuid" class="headerlink" title="2.  创建uuid"></a>2.  创建uuid</h2><p>在 NetworkManager 的配置文件中，uuid 字段是用来标识一个连接的唯一标识符。这个 UUID（通用唯一标识符）确保每个连接在系统中都是唯一的，避免出现连接冲突。</p><p>执行 uuidgen</p><h2 id="3-创建配置文件-sudo-nano-etc-NetworkManager-system-connections-SSID-nmconnect"><a href="#3-创建配置文件-sudo-nano-etc-NetworkManager-system-connections-SSID-nmconnect" class="headerlink" title="3. 创建配置文件 sudo nano &#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F;(SSID).nmconnect"></a>3. 创建配置文件 sudo nano &#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F;(SSID).nmconnect</h2><p><code>(ssid).nmconnect</code> 文件的内容通常包括网络连接的所有必要信息，如 SSID、加密方式、密码、IP 配置等。其格式可能类似于 <code>.nmconnection</code> 文件，但具体格式和内容依赖于使用此文件的工具或系统。</p><p>例如，一个 <code>nmconnect</code> 文件可能包含以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[connection]</span><br><span class="line">id=MyWiFi</span><br><span class="line">uuid=abcd1234-5678-9101-2345-6789abcdef01</span><br><span class="line">type=wifi</span><br><span class="line">autoconnect=true</span><br><span class="line">interface-name=wlan0</span><br><span class="line"></span><br><span class="line">[wifi]</span><br><span class="line">ssid=MyWiFi</span><br><span class="line">mode=infrastructure</span><br><span class="line">security=wifi-security</span><br><span class="line"></span><br><span class="line">[wifi-security]</span><br><span class="line">key-mgmt=wpa-psk</span><br><span class="line">psk=MyPassword</span><br><span class="line"></span><br><span class="line">[ipv4]</span><br><span class="line">method=auto #默认DHCP</span><br><span class="line"></span><br><span class="line">#method=manual 静态IP</span><br><span class="line">#addresses=192.168.1.100/24</span><br><span class="line">#gateway=192.168.1.1</span><br><span class="line">#dns=8.8.8.8;8.8.4.4</span><br><span class="line"></span><br><span class="line">[ipv6]</span><br><span class="line">method=ignore</span><br></pre></td></tr></table></figure><h2 id="4-重启-NetworkManager"><a href="#4-重启-NetworkManager" class="headerlink" title="4. 重启 NetworkManager"></a>4. 重启 NetworkManager</h2><p><code>sudo systemctl restart NetworkManager</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在线配置（荐）&quot;&gt;&lt;a href=&quot;#在线配置（荐）&quot; class=&quot;headerlink&quot; title=&quot;在线配置（荐）&quot;&gt;&lt;/a&gt;在线配置（荐）&lt;/h1&gt;&lt;h2 id=&quot;命令行连接wifi&quot;&gt;&lt;a href=&quot;#命令行连接wifi&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>项目入门-《苍穹外卖》</title>
    <link href="https://senwh.github.io/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/"/>
    <id>https://senwh.github.io/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/</id>
    <published>2024-11-20T15:03:52.000Z</published>
    <updated>2025-02-18T11:01:42.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84.png" alt="知识结构"></p><ul><li><strong>SpringBoot启动流程</strong></li></ul><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="SpringBoot启动流程"></p><ul><li><strong>用户一次请求流程</strong></li></ul><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/request.png" alt="request"></p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><h2 id="如何将前端数据转发至后端处理？"><a href="#如何将前端数据转发至后端处理？" class="headerlink" title="如何将前端数据转发至后端处理？"></a>如何将前端数据转发至后端处理？</h2><h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h3><p>前端生成数据-&gt; nginx监听主机及端口（在conf配置 http默认端口80）-&gt; nginx识别传入路径forward到指定后端地址（Tomcat-默认8080端口）</p><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/nginx_1.png" alt="nginx_1"></p><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/nginx_2.png" alt="nginx_2"></p><ul><li>如果只有本机一台服务器，webservers为localhost</li><li>可为多台server分配不同权重以达到分流作用</li></ul><h2 id="接口设计与测试"><a href="#接口设计与测试" class="headerlink" title="接口设计与测试"></a>接口设计与测试</h2><ul><li><p>Yapi提供界面管理和维护接口</p></li><li><p>Swagger 为后端接口提供测试界面（取代postman）</p></li></ul><h3 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a>Swagger常用注解</h3><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/swagger_1.png" alt="swagger_1"></p><h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><h2 id="需求分析和设计"><a href="#需求分析和设计" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h2><ol><li>产品原型</li><li>接口设计（Yapi）</li><li>数据库设计</li></ol><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p>用户请求-&gt;拦截器（校验JWT令牌）-&gt;Controller-&gt;service-&gt;mapper-&gt;database</p><h3 id="如何理解JWT？"><a href="#如何理解JWT？" class="headerlink" title="如何理解JWT？"></a>如何理解JWT？</h3><p>JWT（JSON Web Token）是一种数据形式，通常放在http头部被校验。</p><p>包括：</p><ul><li>Header：令牌类型（JWT） + 签名所使用算法</li><li>Payload：一些claims，可以理解为该JWT的设置参数</li><li>Signature：用于验证其在传输过程中未被篡改</li></ul><p>工作流程：</p><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/swagger_2.png" alt="swagger_2"></p><ol><li><strong>用户登录</strong>：用户使用用户名和密码登录。</li><li><strong>生成 JWT</strong>：服务器验证用户凭据后，创建一个包含用户信息和其他必要声明的 JWT，并使用一个密钥对其进行签名。</li><li><strong>发送 JWT</strong>：服务器将 JWT 发送给客户端。</li><li><strong>存储 JWT</strong>：客户端通常将 JWT 存储在本地存储（如 Cookies）或内存中（如 localStorage）。</li><li><strong>发送请求</strong>：客户端在随后的每个请求中将 JWT 放在 HTTP 头部（通常是 Authorization 字段）中发送给服务器。</li><li><strong>验证 JWT</strong>：服务器接收到请求后，验证 JWT 的签名以确保其未被篡改，并根据有效载荷中的声明来处理请求。</li></ol><p><strong>简而言之：用户成功登录一次后，服务器创建了一个牌子（jwt）并签名（服务器亲自生成的）给用户（以后你就是熟人），用户拿到JWT后，以后每次发送数据都带上牌子（我是熟人），服务器检验签名及JWT信息让该用户进屋。</strong></p><h3 id="不同类中还有什么办法可以获取某个变量？"><a href="#不同类中还有什么办法可以获取某个变量？" class="headerlink" title="不同类中还有什么办法可以获取某个变量？"></a>不同类中还有什么办法可以获取某个变量？</h3><p>只要在同一线程中(Thread.currentThread().getID())，可以使用ThreadLocal来存取某一变量，该变量只有在同一线程内部才能获取</p><h3 id="Handle如何执行？"><a href="#Handle如何执行？" class="headerlink" title="Handle如何执行？"></a>Handle如何执行？</h3><h3 id="代码开发思路"><a href="#代码开发思路" class="headerlink" title="代码开发思路"></a>代码开发思路</h3><ul><li>Yapi查看接口（参数，返回值，请求方法）</li><li>定义DTO对象作为传输参数-&gt;controller（地址映射）</li><li>controller新建并调用对应service</li><li>service 调用 mapper方法</li><li>mapper语句由mapper.xml绑定，yml文件指定扫描xml地址</li><li>mapper拿到data，封装进Result返回给前端</li></ul><h3 id="分页PageHelper实现原理"><a href="#分页PageHelper实现原理" class="headerlink" title="分页PageHelper实现原理"></a>分页PageHelper实现原理</h3><p>PageHelper.startPage的底层实现，ThreadLocal线程存Page进内存里，在执行查询之前将Page作为sql语句的limit语句拼进XML对应语句里<strong>（动态SQL）</strong></p><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/page_1.png" alt="page_1"></p><h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ol><li>配置属性类</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;sky.alioss&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class AliOssProperties &#123;</span><br><span class="line"></span><br><span class="line">    private String endpoint;</span><br><span class="line">    private String accessKeyId;</span><br><span class="line">    private String accessKeySecret;</span><br><span class="line">    private String bucketName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从yml文件获取值赋值给属性类。定义配置类，加载配置类时，创建对象并获取属性类的值。</p><ol start="2"><li>文件上传控制器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String originalFilename = file.getOriginalFilename();</span><br><span class="line">//截取后缀</span><br><span class="line">String extension = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));</span><br><span class="line">String objectName = UUID.randomUUID().toString() + extension; //搞个独一无人的新名字防止重名</span><br><span class="line">aliOssUtil.upload(file.getBytes(),objectName);</span><br></pre></td></tr></table></figure><ol start="3"><li>上传工具类进行上传</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建OSSClient实例。</span><br><span class="line">OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">// 创建PutObject请求。</span><br><span class="line">ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));</span><br></pre></td></tr></table></figure><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p><strong>批量插入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertBatch&quot;&gt;</span><br><span class="line">    insert into dish_flavor (dish_id,name,value)</span><br><span class="line">        values</span><br><span class="line">   &lt;foreach collection=&quot;flavors&quot; item=&quot;df&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">       (#&#123;df.dish_id&#125;,#&#123;df.name&#125;,#&#123;df.value&#125;)</span><br><span class="line">   &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><p><strong>返回数据库自增值（主键）的方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>左连接（外）&#x2F;右连接（外）&#x2F;全连接（外）&#x2F;内连接</strong></p><ul><li><p>左&#x2F;右连接：主表数据完全保留, 副表字段匹配到则数据保留,填充到结果集, 未匹配到数据置空.</p><p><code>SELECT *</code><br><code>FROM table1</code><br><code>LEFT JOIN table2 ON table1.column_name = table2.column_name;</code></p></li><li><p>全连接：两表取并集</p></li><li><p>内连接：取交集</p></li></ul><h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul><li><p>key-value形式保存在内存中</p></li><li><p>常用数据类型：<img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/redis_1.png" alt="redis_1"></p></li><li><p>常用命令：</p><ul><li>String： Setex key second value  (数据的过期时间，过期后释放内存)</li><li>Hash: HSET key field value&#x2F;HGET key&#x2F;HDEL key&#x2F;HKEYS key &#x2F; HVALUES key</li><li>List: <img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/redis_2.png" alt="redis_2"></li><li>Set：<img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/redis_3.png" alt="redis_3"></li><li>sort(有序集合)：<img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/redis_4.png" alt="redis_4"></li></ul><h2 id="spring-redis"><a href="#spring-redis" class="headerlink" title="spring-redis"></a>spring-redis</h2><p><strong>流程</strong>：配置—&gt;配置类（Bean）通过该对象操作Redis</p></li></ul><h1 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h1><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p><strong>Http协议的客户端编程工具包</strong>：向服务端请求GET&#x2F;发送POST数据</p><p><strong>执行流程</strong>：创建httpclient对象-&gt;创建请求对象（HttpPost）-&gt;发送请求(对象封装为StringEntity)-&gt;解析结果-&gt;关闭资源</p><h2 id="小程序微信登录流程"><a href="#小程序微信登录流程" class="headerlink" title="小程序微信登录流程"></a>小程序微信登录流程</h2><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/api-login.png" alt="api-login"></p><ul><li>小程序要调用wx（第三方）：获取临时授权码（wx.login）-&gt;后端服务器以该码+app信息调用微信接口获取身份信息-&gt;后端服务器为小程序返回身份信息（token）-&gt;后续小程序在请求时都携带该token用于验证身份</li></ul><h2 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h2><p><img src="/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E3%80%8B/wc-offer.png" alt="wc-offer"></p><ul><li>服务端为小程序返回订单号</li><li>点击支付后，服务端根据订单号和<strong>小程序各种配置信息调</strong>用wx接口获取<strong>交易标识</strong>并返回给小程序</li><li>小程序根据标识直接调用wx接口请求支付</li><li>为小程序返回支付结果&#x2F;根据交易标识中的回调地址为服务端返回支付结果</li></ul><h1 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h1><h2 id="缓存与Spring-Cache"><a href="#缓存与Spring-Cache" class="headerlink" title="缓存与Spring Cache"></a>缓存与Spring Cache</h2><p><strong>用途</strong>：多用户同时访问数据库时导致性能下降（查询商品等），引入缓存机制（放入内存）</p><p><strong>Spring Cache</strong>：基于注解实现缓存的功能（Redis）等</p><ul><li><p>CachePut(cacheNames &#x3D; “A”, key&#x3D;”#B(和形参有关)”) &#x2F;&#x2F;key构造为A：：B 将返回结果作为值存入Redis</p></li><li><p>Cacheable 查询缓存，若没查询到调数据库并存入</p></li><li><p>CacheEvict 清理缓存（cacheNames &#x3D; ，allEntries &#x3D; true(CacheNames下的全删了)）</p></li></ul><h1 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h1><h2 id="SpringTask"><a href="#SpringTask" class="headerlink" title="SpringTask"></a>SpringTask</h2><ul><li>用途：定时执行方法（查询&#x2F;更新状态），启动类增加注解@EnableScheduling</li><li>注解使用：在方法中加入@Scheduled(cron&#x3D;”cron表达式”)  表达式可通过在线网站生成</li><li>通常定义定时类配合mapper操作底层数据库</li></ul><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul><li>用途：服务端和管理端保持长连接，相比对同一对象的调用和返回，通过它可以实现接收小程序对象数据，并处理转发值管理端（收发面向不同对象）</li><li>创建连接时通常也会经过nginx转发</li></ul><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ul><li><p>Result 在查询时指定泛型， 其他操作不用添加</p></li><li><p>对象属性拷贝：BeanUtils.copyProperties(src,des)</p></li><li><p>@AllArgsConstructor 生成构造函数注解</p></li><li><p>@RequestParam从请求的查询参数中获取值</p><ul><li>例： <code>?param1=value1&amp;param2=value2</code></li></ul></li><li><p>@PathVariable 从URL 路径中的部分获取值</p></li><li><p>例：&#x2F;users&#x2F;{userId}</p></li><li><p>构建器构建对象模式：例</p><ul><li><pre><code>Dish dish = Dish.builder()                .status(status)                .id(id)                .build();</code></pre></li></ul></li><li><p>对象封装时：DTO前端-&gt;后端，VO 反之</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2024/11/20/%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E3%80%8A%E</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://senwh.github.io/2024/11/19/%E6%95%B0%E7%BB%84/"/>
    <id>https://senwh.github.io/2024/11/19/%E6%95%B0%E7%BB%84/</id>
    <published>2024-11-19T02:59:22.000Z</published>
    <updated>2025-01-01T14:04:29.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><strong>算法特征</strong></p><ul><li>有序不重复数组</li><li>时间复杂度O(logn)  空间复杂度O(1)</li></ul><p><strong>解题思路</strong></p><ol><li>定义左右下标-&gt;左闭右闭（<strong>荐</strong>）&#x2F;左闭右开（right指向数组后一位）</li><li>While循环条件与1定义相关，左闭右闭循环条件含left&#x3D;right，right指向数组数据</li></ol><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">LC34. 在排序数组中查找元素的第一个和最后一个位置</a></p><ul><li>变形：数组含重复元素</li><li>基于二分查找思想获取左右边界值</li></ul><p><a href="https://leetcode.cn/problems/sqrtx/">LC69.x 的平方根</a></p><ul><li>平方根结果可以通过二分查找</li><li>Tips：long可表示64位，注意精度问题</li></ul><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p><strong>算法特征</strong></p><ul><li><p>空间复杂度O（1）</p></li><li><p>移除元素</p></li><li><p>不改变元素相对顺序</p></li><li><p>代替暴力解双循环</p></li></ul><p><strong>解题思路</strong></p><ul><li>使用暴力解时注意判断条件里数组长度的变化</li><li>关注慢指针在遇到条件时如何变化, 快指针通过for循环一直递加</li></ul><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/remove-element/">LC27.移除数组元素</a></p><ul><li>慢指针前进</li></ul><p><a href="https://leetcode.cn/problems/backspace-string-compare/">LC844.比较含退格的字符串</a></p><ul><li>慢指针后退</li></ul><h3 id="首尾指针"><a href="#首尾指针" class="headerlink" title="首尾指针"></a>首尾指针</h3><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">LC977. 有序数组的平方</a></p><ul><li>空间复杂度O（n）</li></ul><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><strong>算法特征</strong></p><ul><li><p>求最大&#x2F;最小长度子数组</p></li><li><p>代替暴力解双循环</p></li></ul><p><strong>解题思路</strong></p><ul><li>关注左右指针变化的条件</li><li>内部while循环放左指针移动方案</li></ul><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">LC209. 长度最小的子数组</a></p><ul><li>时间复杂度：O(n)</li></ul><p><a href="https://leetcode.cn/problems/fruit-into-baskets/">LC904. 水果成篮</a> </p><ul><li><p>求长度最大子数组</p></li><li><p>熟悉map的使用：Map&lt;&gt; &#x3D; new HashMap&lt;&gt;() getOrDefault &#x2F; remove&#x2F; size &#x2F; get &#x2F;put</p></li></ul><p><a href="https://leetcode.cn/problems/minimum-window-substring/">LC.76. 最小覆盖子串</a></p><ul><li>滑动窗口基础+熟悉字符串和HashMap的使用</li></ul><h2 id="数组的边界处理（模拟过程）"><a href="#数组的边界处理（模拟过程）" class="headerlink" title="数组的边界处理（模拟过程）"></a>数组的边界处理（模拟过程）</h2><p><strong>解题思路</strong></p><ul><li>在遍历时，各边界的判断保持相同的原则</li></ul><p><strong>相关例题</strong></p><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">LC.59. 螺旋矩阵 II</a></p><ul><li>注意每圈的起点坐标</li><li>左闭右开</li></ul><p><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">LCR.146. 螺旋遍历二维数组</a></p><ul><li>左闭右闭</li></ul><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p><strong>解题思路</strong></p><ul><li>用一个数组记录累加和，空间换时间</li></ul><p><strong>相关例题</strong></p><p><a href="https://kamacoder.com/problempage.php?pid=1070">Kama58.区间和</a></p><ul><li>一维前缀和</li></ul><p><a href="https://kamacoder.com/problempage.php?pid=1044">Kama开发商购买土地</a></p><ul><li>二维前缀和</li></ul><p><strong>Note</strong></p><ul><li><p>对于无符号数除法，例：右移&gt;&gt;1进行位运算比除以2运算速度更快</p></li><li><p>int 4字节 long 8字节 float 4字节 double 8字节  前两表示整数精度更高 后两者表示浮点数（牺牲精度增加表示范围）</p></li><li><p>Integer.MAX_VALUE 和 Integer.MIN_VALUE</p></li><li><p>简单判断语句 （等式）? A：B；</p></li><li><p>字符串操作：</p><ul><li>长度：str.length()</li><li>连接：string1.concat(string2) &#x2F; “ “ + “ “</li><li>访问元素：charAt(index)</li><li>转数组：byte[] Str2 &#x3D; Str1.getBytes()</li><li>子串：substring(int beginIndex, int endIndex) 不包含结束索引</li></ul></li><li><p>Mapper操作：</p><ul><li>访问value： get(key)  &#x2F; 迭代 <strong>for</strong> (Integer i : mapper.keySet())</li><li>删除：remove(key) &#x2F; clear()</li><li>元素数量：size() </li><li>检查键值存在：containsKey() &#x2F; containsValue()</li><li><strong>不存在时赋予key默认值：getOrDefault</strong></li><li>比较元素要用equals</li></ul></li><li><p>输入数据处理</p><ul><li>new Scanner(System.in) </li><li>数据访问：int scanner.nextInt() &#x2F;String scanner.next()</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;h2 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h</summary>
      
    
    
    
    
  </entry>
  
</feed>
